(function () {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("vendor/almond", function(){});

define('pjs',[], function() {
var P = (function(prototype, ownProperty, undefined) {
  // helper functions that also help minification
  function isObject(o) { return typeof o === 'object'; }
  function isFunction(f) { return typeof f === 'function'; }

  // used to extend the prototypes of superclasses (which might not
  // have `.Bare`s)
  function SuperclassBare() {}

  function P(_superclass /* = Object */, definition) {
    // handle the case where no superclass is given
    if (definition === undefined) {
      definition = _superclass;
      _superclass = Object;
    }

    // C is the class to be returned.
    //
    // It delegates to instantiating an instance of `Bare`, so that it
    // will always return a new instance regardless of the calling
    // context.
    //
    //  TODO: the Chrome inspector shows all created objects as `C`
    //        rather than `Object`.  Setting the .name property seems to
    //        have no effect.  Is there a way to override this behavior?
    function C() {
      var self = new Bare;
      if (isFunction(self.init)) self.init.apply(self, arguments);
      return self;
    }

    // C.Bare is a class with a noop constructor.  Its prototype is the
    // same as C, so that instances of C.Bare are also instances of C.
    // New objects can be allocated without initialization by calling
    // `new MyClass.Bare`.
    function Bare() {}
    C.Bare = Bare;

    // Set up the prototype of the new class.
    var _super = SuperclassBare[prototype] = _superclass[prototype];
    var proto = Bare[prototype] = C[prototype] = new SuperclassBare;

    // other variables, as a minifier optimization
    var extensions;


    // set the constructor property on the prototype, for convenience
    proto.constructor = C;

    C.mixin = function(def) {
      Bare[prototype] = C[prototype] = P(C, def)[prototype];
      return C;
    }

    return (C.open = function(def) {
      extensions = {};

      if (isFunction(def)) {
        // call the defining function with all the arguments you need
        // extensions captures the return value.
        extensions = def.call(C, proto, _super, C, _superclass);
      }
      else if (isObject(def)) {
        // if you passed an object instead, we'll take it
        extensions = def;
      }

      // ...and extend it
      if (isObject(extensions)) {
        for (var ext in extensions) {
          if (ownProperty.call(extensions, ext)) {
            proto[ext] = extensions[ext];
          }
        }
      }

      // if there's no init, we assume we're inheriting a non-pjs class, so
      // we default to applying the superclass's constructor.
      if (!isFunction(proto.init)) {
        proto.init = _superclass;
      }

      return C;
    })(definition);
  }

  // ship it
  return P;

  // as a minifier optimization, we've closured in a few helper functions
  // and the string 'prototype' (C[p] is much shorter than C.prototype)
})('prototype', ({}).hasOwnProperty);
return P;
});

/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function( window, undefined ) {
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === "complete" ) {
			// we're here because readyState === "complete" in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context && context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.8.3",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			"slice", core_slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Support tests won't run in some limited or non-browser environments
	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !all || !a || !all.length ) {
		return {};
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";
	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	input.setAttribute( "checked", "checked" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement("div");
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Remove at next major release (1.9/2.0)
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				// Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery.removeData( elem, type + "queue", true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			removes = ( value || "" ).split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {

					className = (" " + elem.className + " ").replace( rclass, " " );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c < cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
							className = className.replace( " " + removes[ c ] + " " , " " );
						}
					}
					elem.className = value ? jQuery.trim( className ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i < attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.value = value + "" );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, "events", true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call( arguments ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "_submit_attached", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "_change_attached", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
	// Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) > Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
			return (cache[ key + " " ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

	// For matchExpr.POS and matchExpr.needsContext
	pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"POS": new RegExp( pos, "i" ),
		"CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var val,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( xml || assertAttributes ) {
		return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			val.specified ? val.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		},

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		"NAME": assertUsableName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		"CLASS": assertUsableClassName && function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var unquoted, excess;
			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ expando ][ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem, context ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.substr( result.length - check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				return function( elem ) {
					var node, diff,
						parent = elem.parentNode;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					if ( parent ) {
						diff = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								diff++;
								if ( elem === node ) {
									break;
								}
							}
						}
					}

					// Incorporate the offset (or cast to NaN), then check against cycle size
					diff -= last;
					return diff === first || ( diff % first === 0 && diff / first >= 0 );
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputPseudo("radio"),
		"checkbox": createInputPseudo("checkbox"),
		"file": createInputPseudo("file"),
		"password": createInputPseudo("password"),
		"image": createInputPseudo("image"),

		"submit": createButtonPseudo("submit"),
		"reset": createButtonPseudo("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		},

		// Positional types
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 0; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 1; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ expando ][ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			tokens.push( matched = new Token( match.shift() ) );
			soFar = soFar.slice( matched.length );

			// Cast descendant combinators to space
			matched.type = match[0].replace( rtrim, " " );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {

				tokens.push( matched = new Token( match.shift() ) );
				soFar = soFar.slice( matched.length );
				matched.type = type;
				matched.matches = match;
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && combinator.dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( checkNonElements || elem.nodeType === 1  ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( !xml ) {
				var cache,
					dirkey = dirruns + " " + doneName + " ",
					cachedkey = dirkey + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem, context, xml ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( matcher( elem, context, xml ) ) {
							return elem;
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && tokens.join("")
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = superMatcher.el;
			}

			// Add elements passing elementMatchers directly to results
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++superMatcher.el;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				for ( j = 0; (matcher = setMatchers[j]); j++ ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	superMatcher.el = 0;
	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ expando ][ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
		match = tokenize( selector ),
		j = match.length;

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !xml &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().length );
			}

			// Fetch a seed set for right-to-left matching
			for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( rbackslash, "" ),
						rsibling.test( tokens[0].type ) && context.parentNode || context,
						xml
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && tokens.join("");
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		xml,
		results,
		rsibling.test( selector )
	);
	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

			// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
			// A support test would require too much code (would include document ready)
			rbuggyQSA = [ ":focus" ],

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [ ":active" ],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'/>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		// rbuggyQSA always contains :focus, so no need for a length check
		rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && !rbuggyQSA.test( selector ) ) {
				var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + groups[i].join("");
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( "!=", pseudos );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active and :focus, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && !rbuggyQSA.test( expr ) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( "", "find", selector );

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: "GET",
								dataType: "script",
								async: false,
								global: false,
								"throws": true
							});
						} else {
							jQuery.error("no ajax");
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === "object" ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType && context[0] || context;
	context = context.ownerDocument || context;

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit && fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

		if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i < l; i++ ) {
				elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === "undefined" ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement("div");
					safe.appendChild( div );

					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						hasBody = rtbody.test(elem);
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
					jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, "olddisplay" );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && elem.style.display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, "display" );

			if ( !values[ index ] && display !== "none" ) {
				jQuery._data( elem, "olddisplay", display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === "boolean";

		if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox
		)
	) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
		display = elem.css("display");
	elem.remove();

	// If the simple way fails,
	// get element's real default display by attaching it to a temp iframe
	if ( display === "none" || display === "" ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement("iframe"), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit & Firefox won't allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write("<!doctype html><html><body>");
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, "display" );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
				style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "marginRight" );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery("<div>")

				// inject the contents of the document in, removing the scripts
				// to avoid any 'Permission Denied' errors in IE
				.append( responseText.replace( rscript, "" ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader("Etag");
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test( url ),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test( data );

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, "$1" + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, "$1" + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( e ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( "hidden" in dataShow ) {
			hidden = dataShow.hidden;
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, "fxshow", true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ||
			// special check for .toggle( handler, handler, ... )
			( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== "undefined" ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	return {
		top: box.top  + scrollTop  - clientTop,
		left: box.left + scrollLeft - clientLeft
	};
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

})( window );

//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
define("underscore", (function (global) {
    return function () {
        var ret, fn;
        return ret || global._;
    };
}(this)));

define('lib/clone',['require'],function(require){
  var clone = function (json) {
    return JSON.parse(JSON.stringify(json));
  };
  return clone;
});

// There are a few ways we can define the configuration.
define('config',['require','lib/clone'],function(require) {
  /*global Desmos*/
  var clone = require('lib/clone');
  
  var config = {};
  
  // 1) Read from Desmos.config if it exists
  if (typeof Desmos !== 'undefined' && Desmos.config) {
    config = clone(Desmos.config);
  }
  
  // 2) Read from url if it specifies a desmos_config
  var re = new RegExp('desmos_config=([^&]+)');
  var match = location.search.match(re);
  if (match !== null) {
    config = JSON.parse(decodeURIComponent(match[1]));
  }
  
  return {
    
    get: function (prop) {
      return config[prop];
    },
    
    use: function (props, func) {
      // save a copy of the config
      var configOriginal = clone(config);
      
      // copy over the temporary changes
      for (var prop in props) {
        config[prop] = props[prop];
      }
      
      // run the function and reset config afterwards
      try {
        func();
      } finally {
        config = configOriginal;
      }
    },
    
    all: function () {
      return clone(config);
    }
    
  };
});

//Definition of built-in functions and variables

define('math/builtin',['require'],function(require){

var BuiltIn = {};

BuiltIn.mod = function(a, b){
  return a - b * Math.floor(a/b);
};

BuiltIn.min = function(a, b){
  return (a < b) ? a : b;
};

BuiltIn.max = function(a, b){
  return (a > b) ? a : b;
};

BuiltIn.sign = function(x){
  if(x === 0) return 0;
  if(x > 0) return 1;
  if(x < 0) return -1;
  return NaN;
};

BuiltIn.lcm = function(a, b){
  a = BuiltIn.smartTruncate(a);
  b = BuiltIn.smartTruncate(b);
  var gcd = BuiltIn.getGCD(a, b);
  return Math.abs(a * b / gcd);
};

BuiltIn.gcd = function(a, b){
  return BuiltIn.getGCD(a, b);
};

BuiltIn.nCr = function(n, r){
  n = BuiltIn.smartTruncate(n);
  r = BuiltIn.smartTruncate(r);
  
  //Error conditions
  if(r > n || n < 0 || r < 0){
    return 0;
  }

  var total = 1;
  for(var i = 0; i < r; i++)
  {
    total *= (n - i) / (i + 1);
  }
  return total;
};

BuiltIn.nPr = function(n, r){
  n = BuiltIn.smartTruncate(n);
  r = BuiltIn.smartTruncate(r);

  //Error conditions
  if(r > n || n < 0 || r < 0){
    return 0;
  }

  var total = 1;
  for(var i = 0; i < r; i++){
    total *= (n-i);
  }
  return total;
};

BuiltIn.factorial = function (x) {
  return BuiltIn.gamma(x + 1);
};

BuiltIn._integerFactorial = function (n) {
  if (n !== Math.floor(n)) return NaN;
  if (n < 0) return NaN;
  if (n > 170) return NaN; // Overflows double point floats
  if (n === 0 || n === 1) return 1;

  var output = 1;
  for (var i = 2; i <= n; i++) output *= i;

  return output;
};

BuiltIn.gamma = function (x) {
  if (x === Math.floor(x)) return BuiltIn._integerFactorial(x - 1);
  // Euler's reflection formula
  if (x < 0) return Math.PI/(Math.sin(Math.PI*x)*BuiltIn.gamma(1-x));
  return Math.exp(BuiltIn.lnGamma(x));
};

BuiltIn.lnGamma = function (x) {
  if (x < 0) return NaN; // Alternates between real and complex on integers.

  // 15 term rational approximation of lnGamma, valid for positive numbers.
  // Original source not known, but verified by JM using Mathematica to give
  // at least 14 correct digits of gamma = Math.exp(Math.lnGamma(x)) for
  // integers and half integers between 0 and 60, and at least 12 correct
  // digits up to 170.
  var cof = [
    57.1562356658629235,
    -59.5979603554754912,
    14.1360979747417471,
    -0.491913816097620199,
    0.339946499848118887e-4,
    0.465236289270485756e-4,
    -0.983744753048795646e-4,
    0.158088703224912494e-3,
    -0.210264441724104883e-3,
    0.217439618115212643e-3,
    -0.164318106536763890e-3,
    0.844182239838527433e-4,
    -0.261908384015814087e-4,
    0.368991826595316234e-5
  ];

  var s = 0.999999999999997092;
  for (var i=0; i < 14; i++) s += cof[i]/(x + i + 1);

  var t = x + 5.24218750000000000;

  return (x + 0.5)*Math.log(t) - t + Math.log(2.5066282746310005*s/x);
};

// BernoulliB_{2k} for k=1..14
BuiltIn.bernoulliTable = [
  1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510,
  43867/798, -174611/330, 854513/138, -236364091/2730, 8553103/6,
  -23749461029/870
];

// mth derivative of cot(x)
//
// Used in evaluating reflection formula for polygamma
//
// Uses fact that (d/dx)^m cot(x) = p_m(cos(x))/sin(x)^{m+1} where p_m(x) is a
// polynomial with coefficents that obey the following recursion relation:
//
// a_{m+1, n} = -((m - n + 2) a_{m, n-1} + (n+1) a_{m, n+1})
//            = -(            t1         +        t2       )
// a_{0, 0} = 0, a_{0, 1} = 1
//
// Could improve performance by taking advantage of fact that p is even/odd
// when m is odd/even. Didn't feel worth the added trickiness.
BuiltIn.cotDerivative = function(m, x) {
  if (m !== Math.floor(m)) return NaN;
  if (m < 0) return NaN;

  if (m === 0) return 1/BuiltIn.tan(x);

  var sinx = BuiltIn.sin(x);
  if (m === 1) return -1/(sinx*sinx);

  var cosx = BuiltIn.cos(x);
  if (m === 2) return 2*cosx/(sinx*sinx*sinx);

  var aprev = [0, 2];
  var a;
  var mp, n;
  var t1, t2;
  for (mp = 3; mp <= m; mp++) {
    a = [];
    for (n = 0; n < mp; n++) {
      t1 = 0;
      t2 = 0;
      if (n > 0) t1 = (mp - n + 1)*aprev[n - 1];
      if (n + 2 < mp) t2 = (n + 1)*aprev[n + 1];
      a.push(-(t1 + t2));
    }
    aprev = a;
  }

  var s = 0;
  // Horner's method for polynomial evaluation
  for (n = m - 1; n >= 0; n--) s = a[n] + cosx*s;

  return s/Math.pow(sinx, m + 1);
};

// polyGamma(m, n) is the (m+1)th derivative of lnGamma(n)
//
// Implemented by differentiating Stirling's approximation:
//
// d/dn ln(Gamma(n)) = -\left(
//         ln(n) + 1/2n + \sum_{k=1}^{\infty} B_{2k}/(2k n^{2k})
//       /right)
//
// d^{m+1}/dn^{m+1} ln(Gamma(n)) =
//      m! (-1)^{m + 1} \left(
//        1/(m n^m) - 1/(2 n^{1+m}) +
//        \sum_{k=1}^{\infty} B_{2k} (2k + m - 1)!/(m!(2k)!n^{2k+m})
//      \right)
//
// B_{2k} are the Bernoulli numbers.
//
// Uses recurrence relation to bring arguments above 10, and reflection
// formula for negative n. In this case, 14 term sum gives results accurate to
// machine precision for values of m between 0 and at least 8.
//
// Only get 8 digits for polyGamma(100, 30)
//
// Recurrence relation:
//
// polyGamma(m, n) = polyGamma(m, n + 1) + (-1)^m m!/n^{m+1}
//
// Reflection formula:
//
// polyGamma(m, n) = (-1)^{m}polyGamma(m, 1 - n) - pi d^m/dn^m cot(pi*n)
//
// Can lose some accuracy in reflection formula for large m because of large
// powers of trig functions.
BuiltIn.polyGamma = function (m, n) {
  if (m < 0) return NaN;
  if (m !== Math.floor(m)) return NaN;
  var sign = (m % 2 === 0) ? -1 : 1;
  // Use reflection formula for negative n
  if (n < 0) {
    return -sign*BuiltIn.polyGamma(m, 1 - n) -
      Math.pow(Math.PI, m + 1)*BuiltIn.cotDerivative(m, Math.PI*n);
  }

  var mfac = BuiltIn.factorial(m);

  // Use recurrence relation to bring n above 10
  var s = 0;
  var npmm = Math.pow(n, -(m + 1));
  while (n < 10) {
    s += npmm;
    n++;
    npmm = Math.pow(n, -(m + 1));
  }

  s += (m === 0) ? -Math.log(n) : npmm*n/m;
  s += 0.5*npmm;

  var bt = BuiltIn.bernoulliTable;
  var num = m + 1;
  var denom = 2;
  var pre = npmm*n*num/denom;
  var nsqinv = 1/(n*n);
  for (var k = 1; k <= 14; k++) {
    pre *= nsqinv;
    s += pre*bt[k-1];
    num++; denom++;
    pre *= num/denom;
    num++; denom++;
    pre *= num/denom;
  }
  return mfac*sign*s;
};

BuiltIn.getGCD = function(x,y)
{
    //Only defined over integers
    var a = BuiltIn.smartTruncate(x);
    var b = BuiltIn.smartTruncate(y);

    // Positive values only
    if (a < 0)
        a = -a;
    if (b < 0)
        b = -b;

    // Reverse order if necessary.
    // b should be smaller than a
    if (b > a)
    {
        var temp = b;
        b = a;
        a = temp;
    }

    //GCD(0, x) = x
    if(b === 0){
      return a;
    }
    
    var m = a % b;
    
    while (m > 0)
    {
        a = b;
        b = m;
        m = a % b;
    }
    
    return b;
};

// Returns a reduced fraction approximation of x with denominator less than
// maxDenominator. maxDenominator defaults to 1e6.
BuiltIn.toFraction = function (x, maxDenominator) {
  
  if (x === Infinity) return { n: Infinity, d: 1 };
  if (x === -Infinity) return { n: -Infinity, d: 1};
  if (!isFinite(x)) return { n: NaN, d: 1};
  
  var whole, n0 = 0, n1 = 1, d0 = 1, d1 = 0, n, d;
  if (!maxDenominator) maxDenominator = 1e6;
  while (true) {
    whole = Math.floor(x);
    n = whole*n1 + n0;
    d = whole*d1 + d0;
    if (d > maxDenominator) break;
    n0 = n1;
    d0 = d1;
    n1 = n;
    d1 = d;
    if (x === whole) break;
    x = 1/(x - whole);
  }
  return { n: n1, d: d1 };
};

// Check if two values are equal to within the given number of bits of
// precision. For numbers smaller than one, compares the difference in the
// numbers to 1 instead of the larger of the numbers. This makes calculations like
// BuiltIn.approx(Math.sin(Math.Pi), 0) work out.
BuiltIn.approx = function (x1, x2, bits) {
  var m = Math.max(Math.max(Math.abs(x1), Math.abs(x2)), 1);
  var d = (bits === undefined) ? 0.5 : Math.pow(0.5, bits);
  return m === m + d*Math.abs(x2 - x1);
};

BuiltIn.smartTruncate = function(x){
  if (x < 0){
    return Math.ceil(x);
  } else {
    return Math.floor(x);
  }
};

BuiltIn.log_base = function(n, base){return Math.log(n) / Math.log(base)};

BuiltIn.pow = function (x, n) {
  if (x >= 0 || n === Math.floor(n)) return Math.pow(x, n);
  var frac = BuiltIn.toFraction(n, 100);
  if (BuiltIn.approx(frac.n/frac.d, n, 2) && frac.d % 2 === 1) return (frac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, n);
  return NaN;
};
BuiltIn.nthroot = function(x, n) { return BuiltIn.pow(x, 1/n) };

var PI_INV = 1/Math.PI;

//Trig functions
BuiltIn.sin = function (x) {
  if (2*PI_INV*x % 2 === 0) return 0;
  return Math.sin(x);
};

BuiltIn.cos = function (x) {
  if (Math.abs(2*PI_INV*x % 2) === 1) return 0;
  return Math.cos(x);
};

BuiltIn.tan = function (x) {
  if (2*PI_INV*x % 2 === 0) return 0;
  if (Math.abs(2*PI_INV*x % 2) === 1) return Infinity;
  return Math.tan(x);
};

BuiltIn.sec = function (x) {
  if (Math.abs(2*PI_INV*x % 2) === 1) return Infinity;
  return 1/Math.cos(x);
};

BuiltIn.csc = function(x) {
  if (2*PI_INV*x % 2 === 0) return Infinity;
  return 1/Math.sin(x);
};

BuiltIn.cot = function(x) {
  if (2*PI_INV*x % 2 === 0) return Infinity;
  if (Math.abs(2*PI_INV*x % 2) === 1) return 0;
  return 1/Math.tan(x);
};

//Inverse trig functions
BuiltIn.acot = function(x){return Math.PI / 2 - Math.atan(x)};
BuiltIn.acsc = function(x){return Math.asin(1/x)};
BuiltIn.asec = function(x){return Math.acos(1/x)};

//Hyperbolic trig functions
BuiltIn.sinh = function(x){return (Math.exp(x) - Math.exp(-x)) / 2};
BuiltIn.cosh = function(x){return (Math.exp(x) + Math.exp(-x)) / 2};
BuiltIn.tanh = function(x) {
  // This definition avoids overflow of sinh and cosh for large x
  if (x > 0) {
    return (1 - Math.exp(-2*x))/(1 + Math.exp(-2*x));
  } else {
    return (Math.exp(2*x) - 1)/(Math.exp(2*x) + 1);
  }
};

BuiltIn.sech = function(x){return 1 / BuiltIn.cosh(x)};
BuiltIn.csch = function(x){return 1 / BuiltIn.sinh(x)};
BuiltIn.coth = function(x){return 1 / BuiltIn.tanh(x)};

//Inverse hyperbolic trig functions
BuiltIn.asinh = function(x){return Math.log(x+Math.sqrt(x*x+1))};
BuiltIn.acosh = function(x){return Math.log(x+Math.sqrt(x+1)*Math.sqrt(x-1))};
BuiltIn.atanh = function(x){return 0.5 * Math.log((1+x)/(1-x))};

BuiltIn.asech = function(x){return Math.log(1/x + Math.sqrt((1/x + 1)) * Math.sqrt((1/x - 1)))};
BuiltIn.acsch = function(x){return Math.log(1/x + Math.sqrt((1/(x*x)+1)))};
BuiltIn.acoth = function(x){return 0.5 * Math.log((x+1)/(x-1))};

return BuiltIn;
});

define('math/evalframe',['require','pjs'],function(require){
  var P = require('pjs');

var EvalFrame = P(function(frame){
  frame.init = function(parentFrame){
    if(parentFrame instanceof EvalFrame){
      this.parentFrame = parentFrame;
    }
    else{
      this.parentFrame = null;
    }
    this.variables = {};
    this.functions = {};
    this.evalStrings = {};
    this.definitionIds = {};
    if(this.parentFrame){
      for(var variable in this.parentFrame.evalStrings){
        this.evalStrings[variable] = this.parentFrame.getEvalStrings(variable);
      }
    }
  };

  frame.setVariable = function(name, value){
    this.variables[name] = value;
  };

  frame.getVariable = function(name){
    if(this.variables.hasOwnProperty(name)){
      return this.variables[name];
    }

    if(this.parentFrame){
      return this.parentFrame.getVariable(name);
    }

    throw("Variable '"+name+"' not defined");
  };

  frame.setDefinitionId = function (name, id) {
    this.definitionIds[name] = id;
  };

  frame.getDefinitionId = function (name) {
    return this.definitionIds[name];
  };

  frame.setFunction = function(name, arity, body, tree, args, source){
    this.functions[name] = {arity: arity, body:body, tree:tree, source:source, args:args};
  };

  frame.hasFunction = function(name){
    if(this.functions.hasOwnProperty(name)){
      return true;
    }
    if(this.parentFrame){
      return this.parentFrame.hasFunction(name);
    }
    return false;
  };

  frame.hasFunctionWithArity = function(name, arity){
    if(this.functions.hasOwnProperty(name) && this.functions[name].arity == arity){
      return true;
    }
    if(this.parentFrame){
      return this.parentFrame.hasFunction(name);
    }
    return false;
  };

  frame.hasVariable = function(name){
    if (this.variables.hasOwnProperty(name)){
      return true;
    }
    if(this.parentFrame){
      return this.parentFrame.hasVariable(name);
    }
    return false;
  };

  frame.getFunctionTree = function(name){
    if(this.functions.hasOwnProperty(name)){
      var f = this.functions[name];
      return f.tree;
    }

    if(this.parentFrame) return this.parentFrame.getFunctionTree(name);
    
    throw("Function '"+name+"' not defined");
  };

  frame.callFunction = function(name, args){
    if(this.functions.hasOwnProperty(name)){
      var f = this.functions[name];
      if(f.arity == args.length){
        return f.body.apply(null, args);
      }
      throw("Function " + name + " expects " + f.arity + " arguments, but was called with " + args.length);
    }
    
    if (this.parentFrame){
      return this.parentFrame.callFunction(name, args);
    }

    throw("Function '"+name+"' not defined");
  };

  frame.defines = function(name){
    return this.hasVariable(name) || this.hasFunction(name);
  };

  frame.arity = function(name){
    if(this.hasVariable(name)) return 0;
    if(this.hasFunction(name)) return this.functions[name].arity;
    if(this.parentFrame){
      return this.parentFrame.arity(name);
    }
  };

  //Needed for compilation.  Have different semantics (don't go up scope chain) for now.  Don't know if that's right
  frame.setEvalStrings = function(name, s){
    this.evalStrings[name] = s;
  };

  frame.getEvalStrings = function(name){
    if(this.evalStrings.hasOwnProperty(name)){
      return this.evalStrings[name];
    }
    else{
      return {expression:name, statements:''};
    }
  };

  frame.functionMap = function(leafOnly){
    var allFunctions = {};
    if(this.parentFrame && !leafOnly){
      allFunctions = this.parentFrame.functionMap();
    }
    for(var name in this.functions){
      if(this.functions.hasOwnProperty(name)){
        allFunctions[name] = this.functions[name].body;
      }
    }
    return allFunctions;
  };

  frame.leafFunctionMap = function(){
    return this.functionMap(true);
  };

  frame.functionSourceMap = function(leafOnly){
    var compiledFunctions = {};
    if(this.parentFrame && !leafOnly){
      compiledFunctions = this.parentFrame.functionSourceMap();
    }
    for(var name in this.functions){
      if(this.functions.hasOwnProperty(name) && this.functions[name].source){
        compiledFunctions[name] = {
          args: this.functions[name].args,
          source: this.functions[name].source
        };
      }
    }
    return compiledFunctions;
  };

  frame.leafFunctionSourceMap = function(){
    return this.functionSourceMap(true);
  };
});

return EvalFrame;

});

//Use this table to get rid of all the string comparisons used to interpret comparators
define('math/comparators',['require'],function(require){

var ComparatorTable = {
   '<': {inclusive: false, direction: -1},
  '!=': {inclusive: false, direction:  0},
   '>': {inclusive: false, direction:  1},
  '<=': {inclusive: true,  direction: -1},
  '=': {inclusive: true,  direction:  0},
  '>=': {inclusive: true,  direction:  1}
};

var getComparator = function(inclusive, direction){
  switch(direction){
    case -1:
      return (inclusive ? '<=' : '<');
    case 0:
      return (inclusive ? '=' : '!=');
    case 1:
      return (inclusive ? '>=' : '>');
    default:
      throw "Programming error.  Comparators must have a direction of -1, 0, or 1";
  }
};

return{
  table: ComparatorTable,
  get: getComparator
};

});

define('parser',[], function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"sentence":3,"expr":4,"EOF":5,"assignment":6,"equation":7,"function_declaration":8,"ordered_pair_list":9,"double_inequality":10,"boolean":11,"identifier":12,"=":13,"FUNCTION_PROTOTYPE":14,",":15,"comparator":16,"IDENTIFIER_BASE":17,"ordered_pair_list_elements":18,"ordered_pair":19,"[":20,"]":21,"(":22,")":23,"expr_sum":24,"<":25,">":26,">=":27,"<=":28,"+":29,"expr_product":30,"-":31,"expr_atom_impmul":32,"*":33,"expr_atom":34,"/":35,"exponent":36,"^N":37,"^I":38,"^":39,"{":40,"}":41,"function_call":42,"function_call_unary":43,"trig_function_call":44,"log_function_call":45,"left|":46,"right|":47,"FRAC":48,"SQRT":49,"!":50,"repeated_operator":51,"DERIVATIVE":52,"expr_piecewise":53,"constant":54,"NUMBER":55,"repeated_operator_symbol":56,"SUM":57,"PROD":58,"_":59,"{_visible":60,"piecewise_list":61,"}_visible":62,"incomplete_piecewise_list":63,"piecewise_element":64,":":65,"trig_function":66,"TRIG_FUNCTION":67,"log_prefix":68,"LN":69,"LOG":70,"LOG_BASE_N":71,"function_argument_list":72,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",13:"=",14:"FUNCTION_PROTOTYPE",15:",",17:"IDENTIFIER_BASE",20:"[",21:"]",22:"(",23:")",25:"<",26:">",27:">=",28:"<=",29:"+",31:"-",33:"*",35:"/",37:"^N",38:"^I",39:"^",40:"{",41:"}",46:"left|",47:"right|",48:"FRAC",49:"SQRT",50:"!",52:"DERIVATIVE",55:"NUMBER",57:"SUM",58:"PROD",59:"_",60:"{_visible",62:"}_visible",65:":",67:"TRIG_FUNCTION",69:"LN",70:"LOG",71:"LOG_BASE_N"},
productions_: [0,[3,2],[3,2],[3,2],[3,2],[3,2],[3,2],[3,2],[3,3],[3,2],[3,4],[3,1],[6,3],[6,3],[7,3],[10,5],[12,1],[9,1],[18,1],[18,3],[19,5],[19,5],[4,1],[16,1],[16,1],[16,1],[16,1],[11,3],[11,3],[11,5],[24,3],[24,3],[24,1],[30,2],[30,3],[30,3],[30,1],[36,1],[36,1],[36,4],[32,1],[32,1],[32,1],[32,1],[32,1],[32,3],[32,3],[32,3],[32,2],[32,7],[32,4],[32,7],[32,2],[32,1],[32,2],[32,1],[34,1],[34,3],[34,2],[34,2],[34,2],[34,1],[56,1],[56,1],[51,9],[53,3],[53,2],[61,3],[61,1],[63,3],[63,1],[64,3],[64,1],[54,1],[54,2],[43,5],[43,4],[66,1],[44,4],[44,2],[44,7],[44,9],[44,3],[44,5],[68,1],[68,1],[68,1],[68,3],[68,5],[45,4],[45,2],[45,5],[45,3],[42,4],[72,3],[72,3],[8,2]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return $$[$0-1]; 
break;
case 2: return $$[$0-1]; 
break;
case 3: return $$[$0-1]; 
break;
case 4: return $$[$0-1]; 
break;
case 5: return $$[$0-1]; 
break;
case 6: return $$[$0-1]; 
break;
case 7: return $$[$0-1]; 
break;
case 8: return yy.ErrorNode("What do you want variable \'" + $$[$0-2].identifier + "\' to equal?");
break;
case 9: var val = yy.parseFunctionDeclaration($$[$0-1]);
          return yy.ErrorNode("What do you want function \'" + val.identifier.identifier + "\' to equal?");
        
break;
case 10: return yy.ErrorNode("Points are written like this: (1, 2)"); 
break;
case 11: return yy.ErrorNode("You haven't written anything yet"); 
break;
case 12: this.$ = yy.AssignmentNode($$[$0-2], $$[$0]);
break;
case 13: this.$ = yy.AssignmentNode($$[$0-2], yy.ErrorNode);
break;
case 14: this.$ = yy.EquationNode($$[$0-2], $$[$0]);
break;
case 15:this.$ = yy.DoubleInequalityNode($$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);
break;
case 16:this.$ = yy.IdentifierNode(yytext);
        yy.setInput(this.$, this._$);
      
break;
case 17: this.$ = yy.OrderedPairListNode($$[$0]);
break;
case 18: this.$ = [($$[$0])]; 
break;
case 19: $$[$0-2].push($$[$0]); this.$ = $$[$0-2] 
break;
case 20: this.$ = yy.OrderedPairNode($$[$0-3], $$[$0-1]); 
break;
case 21: this.$ = yy.OrderedPairNode($$[$0-3], $$[$0-1]); 
break;
case 22:this.$ = $$[$0]; 
      yy.setInput(this.$, this._$);
    
break;
case 23:this.$ = '<'
break;
case 24:this.$ = '>'
break;
case 25:this.$ = '>='
break;
case 26:this.$ = '<='
break;
case 27:this.$ = yy.ComparatorNode($$[$0-1], $$[$0-2], $$[$0]); 
break;
case 28:this.$ = yy.ComparatorNode('===', $$[$0-2], $$[$0]); 
break;
case 29:this.$ = yy.ChainedComparatorNode([$$[$0-3], $$[$0-1]], [$$[$0-4], $$[$0-2], $$[$0]]); 
break;
case 30:this.$ = yy.BinaryOperatorNode('+', $$[$0-2], $$[$0]);
break;
case 31:this.$ = yy.BinaryOperatorNode('-', $$[$0-2], $$[$0]);
break;
case 32:this.$ = $$[$0]
break;
case 33:this.$ = yy.BinaryOperatorNode('*', $$[$0-1], $$[$0]);
break;
case 34:this.$ = yy.BinaryOperatorNode('*', $$[$0-2], $$[$0]);
break;
case 35:this.$ = yy.BinaryOperatorNode('/', $$[$0-2], $$[$0]);
break;
case 36:this.$ = $$[$0];
break;
case 37:this.$ = yy.ConstantNode(Number($$[$0]));
break;
case 38:this.$ = yy.IdentifierNode($$[$0]);
break;
case 39:this.$ = $$[$0-1];
break;
case 40:this.$ = $$[$0];
break;
case 41:this.$ = $$[$0];
break;
case 42:this.$ = $$[$0];
break;
case 43:this.$ = $$[$0];
break;
case 44:this.$ = $$[$0];
break;
case 45:this.$ = $$[$0-1];
break;
case 46:this.$ = $$[$0-1];
break;
case 47:this.$ = yy.FunctionNode(yy.IdentifierNode('\\abs'), [$$[$0-1]]);
break;
case 48:this.$ = yy.BinaryOperatorNode('^', $$[$0-1], $$[$0]);
break;
case 49:this.$ = yy.BinaryOperatorNode('/', $$[$0-4], $$[$0-1]);
break;
case 50:this.$ = yy.FunctionNode(yy.IdentifierNode('\\sqrt'), [$$[$0-1]]);
break;
case 51:this.$ = yy.FunctionNode(yy.IdentifierNode('\\nthroot'), [$$[$0-1], $$[$0-4]]);
break;
case 52:this.$ = yy.FunctionNode(yy.IdentifierNode('\\factorial'), [$$[$0-1]])
break;
case 53:this.$ = $$[$0];
break;
case 54:this.$ = yy.DerivativeNode(yy.IdentifierNode($$[$0-1]), $$[$0]);
break;
case 55:this.$ = $$[$0]
break;
case 56:this.$ = $$[$0];
break;
case 57:this.$ = yy.NegationNode(yy.BinaryOperatorNode('^', yy.ConstantNode(Number($$[$0-1])), $$[$0]));
break;
case 58:this.$ = yy.BinaryOperatorNode('^', $$[$0-1], $$[$0]);
break;
case 59:this.$ = yy.FunctionNode(yy.IdentifierNode('\\factorial'), [$$[$0-1]])
break;
case 60:this.$ = yy.NegationNode($$[$0])
break;
case 61:this.$ = $$[$0]
break;
case 62:this.$ = yy.SummationNode;
break;
case 63:this.$ =  yy.ProductNode;
break;
case 64:this.$ = $$[$0-8]($$[$0-5], $$[$0-3], $$[$0-1], $$[$0]);
break;
case 65:this.$ = $$[$0-1];
break;
case 66:this.$ = yy.ConstantNode(1);
break;
case 67:this.$ = $$[$0-2].append_else(yy.PiecewiseNode(yy.ConstantNode(true), $$[$0]));
break;
case 68:this.$ = $$[$0];
break;
case 69:this.$ = $$[$0-2].append_else($$[$0]);
break;
case 70:this.$ = $$[$0];
break;
case 71: this.$ = yy.PiecewiseNode($$[$0-2], $$[$0]); 
break;
case 72: this.$ = yy.PiecewiseNode($$[$0], yy.ConstantNode(1)); 
break;
case 73:this.$ = yy.ConstantNode(Number(yytext));
break;
case 74:this.$ = yy.ConstantNode(-$$[$0])
break;
case 75:this.$ = yy.FunctionCallExponentNode($$[$0-4], $$[$0-2], $$[$0]);
break;
case 76:this.$ = yy.FunctionNode($$[$0-3], [$$[$0-1]]);
break;
case 77:this.$ = yy.IdentifierNode(yytext);
break;
case 78:this.$ = yy.FunctionNode($$[$0-3], [$$[$0-1]]);
break;
case 79:
          if(!$$[$0].okForImplicitFunction()) {throw 'Too complicated.  Use parens'};
          this.$ = yy.FunctionNode($$[$0-1], [$$[$0]]);
        
break;
case 80: 
          if(!$$[$0].okForImplicitFunction()) {throw 'Too complicated.  Use parens'};
          if($$[$0-2].value != 1) {throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens'};
          this.$ = yy.FunctionNode(yy.IdentifierNode(yy.inverses[$$[$0-6].identifier]), [$$[$0]]);
        
break;
case 81:
          if($$[$0-4].value != 1) {throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens'};
          this.$ = yy.FunctionNode(yy.IdentifierNode(yy.inverses[$$[$0-8].identifier]), [$$[$0-1]]); 
        
break;
case 82:
          if(!$$[$0].okForImplicitFunction()) {throw 'Too complicated.  Use parens'};
          if($$[$0-1] != "2") {throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens'};
          this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode($$[$0-2], [$$[$0]]), yy.ConstantNode(2));
        
break;
case 83:
          if($$[$0-3] != "2") {throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens'};
          this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode($$[$0-4], [$$[$0-1]]), yy.ConstantNode(2)); 
        
break;
case 84: this.$ = yy.ConstantNode(Math.E) 
break;
case 85: this.$ = yy.ConstantNode(10) 
break;
case 86: this.$ = yy.ConstantNode(Number(yytext)); 
break;
case 87: this.$ = $$[$0]
break;
case 88: this.$ = $$[$0-1]
break;
case 89:this.$ = yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0-1], $$[$0-3]])
break;
case 90:
      if(!$$[$0].okForImplicitFunction()) {throw 'Too complicated.  Use parens'};
      this.$ = yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0], $$[$0-1]])
    
break;
case 91:
      if($$[$0-3] != "2") {throw 'Only log^2 is supported.  Use parens'}
      this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0-1], $$[$0-4]]), yy.ConstantNode(2))
    
break;
case 92:
      if(!$$[$0].okForImplicitFunction()) {throw 'Too complicated.  Use parens'};
      if($$[$0-1] != "2") {throw 'Only log^2 is supported.  Use parens'}
      this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0], $$[$0-2]]), yy.ConstantNode(2))
    
break;
case 93:this.$ = yy.FunctionNode($$[$0-3], $$[$0-1]);
break;
case 94:this.$ = $$[$0-2].concat([$$[$0]]);
break;
case 95:this.$ = [$$[$0-2], $$[$0]];
break;
case 96:var val = yy.parseFunctionDeclaration($$[$0-1]); this.$ = yy.FunctionDeclarationNode(val.identifier, val.args, $$[$0]);
        this.$.setInputString(val.input_string);
      
break;
}
},
table: [{3:1,4:2,5:[1,11],6:3,7:4,8:5,9:6,10:7,11:8,12:9,14:[1,10],17:[1,14],18:13,19:16,20:[1,18],22:[1,19],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{1:[3]},{5:[1,45],13:[1,47],15:[1,46],16:48,25:[1,49],26:[1,50],27:[1,51],28:[1,52]},{5:[1,53]},{5:[1,54]},{5:[1,55]},{5:[1,56]},{5:[1,57]},{5:[1,58]},{5:[2,40],13:[1,59],15:[2,40],17:[2,40],22:[1,60],25:[2,40],26:[2,40],27:[2,40],28:[2,40],29:[2,40],31:[2,40],33:[2,40],35:[2,40],37:[2,40],38:[2,40],39:[2,40],40:[2,40],46:[2,40],48:[2,40],49:[2,40],50:[2,40],52:[2,40],57:[2,40],58:[2,40],60:[2,40],67:[2,40],69:[2,40],70:[2,40],71:[2,40]},{4:62,5:[1,61],12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{1:[2,11]},{5:[2,22],13:[2,22],15:[2,22],17:[2,22],21:[2,22],22:[2,22],23:[2,22],25:[2,22],26:[2,22],27:[2,22],28:[2,22],29:[1,65],31:[1,66],33:[2,22],35:[2,22],37:[2,22],38:[2,22],39:[2,22],40:[2,22],41:[2,22],46:[2,22],47:[2,22],48:[2,22],49:[2,22],50:[2,22],52:[2,22],57:[2,22],58:[2,22],60:[2,22],62:[2,22],65:[2,22],67:[2,22],69:[2,22],70:[2,22],71:[2,22]},{5:[2,17],15:[1,67]},{5:[2,16],13:[2,16],15:[2,16],17:[2,16],21:[2,16],22:[2,16],23:[2,16],25:[2,16],26:[2,16],27:[2,16],28:[2,16],29:[2,16],31:[2,16],33:[2,16],35:[2,16],37:[2,16],38:[2,16],39:[2,16],40:[2,16],41:[2,16],46:[2,16],47:[2,16],48:[2,16],49:[2,16],50:[2,16],52:[2,16],55:[2,16],57:[2,16],58:[2,16],60:[2,16],62:[2,16],65:[2,16],67:[2,16],69:[2,16],70:[2,16],71:[2,16]},{5:[2,32],12:63,13:[2,32],15:[2,32],17:[1,14],21:[2,32],22:[1,64],23:[2,32],25:[2,32],26:[2,32],27:[2,32],28:[2,32],29:[2,32],31:[2,32],32:68,33:[1,69],35:[1,70],37:[2,32],38:[2,32],39:[2,32],40:[1,28],41:[2,32],42:24,43:25,44:26,45:27,46:[1,29],47:[2,32],48:[1,30],49:[1,31],50:[2,32],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,32],65:[2,32],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,18],15:[2,18]},{5:[2,36],13:[2,36],15:[2,36],17:[2,36],21:[2,36],22:[2,36],23:[2,36],25:[2,36],26:[2,36],27:[2,36],28:[2,36],29:[2,36],31:[2,36],33:[2,36],35:[2,36],36:71,37:[1,73],38:[1,74],39:[1,75],40:[2,36],41:[2,36],46:[2,36],47:[2,36],48:[2,36],49:[2,36],50:[1,72],52:[2,36],57:[2,36],58:[2,36],60:[2,36],62:[2,36],65:[2,36],67:[2,36],69:[2,36],70:[2,36],71:[2,36]},{4:76,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:77,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,56],13:[2,56],15:[2,56],17:[2,56],21:[2,56],22:[2,56],23:[2,56],25:[2,56],26:[2,56],27:[2,56],28:[2,56],29:[2,56],31:[2,56],33:[2,56],35:[2,56],37:[2,56],38:[2,56],39:[2,56],40:[2,56],41:[2,56],46:[2,56],47:[2,56],48:[2,56],49:[2,56],50:[2,56],52:[2,56],57:[2,56],58:[2,56],60:[2,56],62:[2,56],65:[2,56],67:[2,56],69:[2,56],70:[2,56],71:[2,56]},{12:63,17:[1,14],22:[1,64],31:[1,21],32:22,34:79,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,78],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,61],13:[2,61],15:[2,61],17:[2,61],21:[2,61],22:[2,61],23:[2,61],25:[2,61],26:[2,61],27:[2,61],28:[2,61],29:[2,61],31:[2,61],33:[2,61],35:[2,61],36:80,37:[1,73],38:[1,74],39:[1,75],40:[2,61],41:[2,61],46:[2,61],47:[2,61],48:[2,61],49:[2,61],50:[1,81],52:[2,61],57:[2,61],58:[2,61],60:[2,61],62:[2,61],65:[2,61],67:[2,61],69:[2,61],70:[2,61],71:[2,61]},{5:[2,73],13:[2,73],15:[2,73],17:[2,73],21:[2,73],22:[2,73],23:[2,73],25:[2,73],26:[2,73],27:[2,73],28:[2,73],29:[2,73],31:[2,73],33:[2,73],35:[2,73],37:[2,73],38:[2,73],39:[2,73],40:[2,73],41:[2,73],46:[2,73],47:[2,73],48:[2,73],49:[2,73],50:[2,73],52:[2,73],57:[2,73],58:[2,73],60:[2,73],62:[2,73],65:[2,73],67:[2,73],69:[2,73],70:[2,73],71:[2,73]},{5:[2,41],13:[2,41],15:[2,41],17:[2,41],21:[2,41],22:[2,41],23:[2,41],25:[2,41],26:[2,41],27:[2,41],28:[2,41],29:[2,41],31:[2,41],33:[2,41],35:[2,41],37:[2,41],38:[2,41],39:[2,41],40:[2,41],41:[2,41],46:[2,41],47:[2,41],48:[2,41],49:[2,41],50:[2,41],52:[2,41],57:[2,41],58:[2,41],60:[2,41],62:[2,41],65:[2,41],67:[2,41],69:[2,41],70:[2,41],71:[2,41]},{5:[2,42],13:[2,42],15:[2,42],17:[2,42],21:[2,42],22:[2,42],23:[2,42],25:[2,42],26:[2,42],27:[2,42],28:[2,42],29:[2,42],31:[2,42],33:[2,42],35:[2,42],37:[2,42],38:[2,42],39:[2,42],40:[2,42],41:[2,42],46:[2,42],47:[2,42],48:[2,42],49:[2,42],50:[2,42],52:[2,42],57:[2,42],58:[2,42],60:[2,42],62:[2,42],65:[2,42],67:[2,42],69:[2,42],70:[2,42],71:[2,42]},{5:[2,43],13:[2,43],15:[2,43],17:[2,43],21:[2,43],22:[2,43],23:[2,43],25:[2,43],26:[2,43],27:[2,43],28:[2,43],29:[2,43],31:[2,43],33:[2,43],35:[2,43],37:[2,43],38:[2,43],39:[2,43],40:[2,43],41:[2,43],46:[2,43],47:[2,43],48:[2,43],49:[2,43],50:[2,43],52:[2,43],57:[2,43],58:[2,43],60:[2,43],62:[2,43],65:[2,43],67:[2,43],69:[2,43],70:[2,43],71:[2,43]},{5:[2,44],13:[2,44],15:[2,44],17:[2,44],21:[2,44],22:[2,44],23:[2,44],25:[2,44],26:[2,44],27:[2,44],28:[2,44],29:[2,44],31:[2,44],33:[2,44],35:[2,44],37:[2,44],38:[2,44],39:[2,44],40:[2,44],41:[2,44],46:[2,44],47:[2,44],48:[2,44],49:[2,44],50:[2,44],52:[2,44],57:[2,44],58:[2,44],60:[2,44],62:[2,44],65:[2,44],67:[2,44],69:[2,44],70:[2,44],71:[2,44]},{4:82,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:83,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{40:[1,84]},{20:[1,86],40:[1,85]},{5:[2,53],13:[2,53],15:[2,53],17:[2,53],21:[2,53],22:[2,53],23:[2,53],25:[2,53],26:[2,53],27:[2,53],28:[2,53],29:[2,53],31:[2,53],33:[2,53],35:[2,53],37:[2,53],38:[2,53],39:[2,53],40:[2,53],41:[2,53],46:[2,53],47:[2,53],48:[2,53],49:[2,53],50:[2,53],52:[2,53],57:[2,53],58:[2,53],60:[2,53],62:[2,53],65:[2,53],67:[2,53],69:[2,53],70:[2,53],71:[2,53]},{12:63,17:[1,14],22:[1,64],30:87,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,55],13:[2,55],15:[2,55],17:[2,55],21:[2,55],22:[2,55],23:[2,55],25:[2,55],26:[2,55],27:[2,55],28:[2,55],29:[2,55],31:[2,55],33:[2,55],35:[2,55],37:[2,55],38:[2,55],39:[2,55],40:[2,55],41:[2,55],46:[2,55],47:[2,55],48:[2,55],49:[2,55],50:[2,55],52:[2,55],57:[2,55],58:[2,55],60:[2,55],62:[2,55],65:[2,55],67:[2,55],69:[2,55],70:[2,55],71:[2,55]},{12:63,17:[1,14],22:[1,88],30:89,31:[1,21],32:22,34:17,37:[1,91],39:[1,90],40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:63,17:[1,14],22:[1,92],30:93,31:[1,21],32:22,34:17,37:[1,94],40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{59:[1,95]},{4:101,11:100,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],61:96,62:[1,97],63:98,64:99,66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{17:[2,77],22:[2,77],31:[2,77],37:[2,77],39:[2,77],40:[2,77],46:[2,77],48:[2,77],49:[2,77],52:[2,77],55:[2,77],57:[2,77],58:[2,77],60:[2,77],67:[2,77],69:[2,77],70:[2,77],71:[2,77]},{17:[2,84],22:[2,84],31:[2,84],37:[2,84],40:[2,84],46:[2,84],48:[2,84],49:[2,84],52:[2,84],55:[2,84],57:[2,84],58:[2,84],60:[2,84],67:[2,84],69:[2,84],70:[2,84],71:[2,84]},{17:[2,85],22:[2,85],31:[2,85],37:[2,85],40:[2,85],46:[2,85],48:[2,85],49:[2,85],52:[2,85],55:[2,85],57:[2,85],58:[2,85],59:[1,102],60:[2,85],67:[2,85],69:[2,85],70:[2,85],71:[2,85]},{17:[2,86],22:[2,86],31:[2,86],37:[2,86],40:[2,86],46:[2,86],48:[2,86],49:[2,86],52:[2,86],55:[2,86],57:[2,86],58:[2,86],60:[2,86],67:[2,86],69:[2,86],70:[2,86],71:[2,86]},{59:[2,62]},{59:[2,63]},{1:[2,1]},{4:103,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:104,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:106,12:105,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{17:[2,23],22:[2,23],31:[2,23],40:[2,23],46:[2,23],48:[2,23],49:[2,23],52:[2,23],55:[2,23],57:[2,23],58:[2,23],60:[2,23],67:[2,23],69:[2,23],70:[2,23],71:[2,23]},{17:[2,24],22:[2,24],31:[2,24],40:[2,24],46:[2,24],48:[2,24],49:[2,24],52:[2,24],55:[2,24],57:[2,24],58:[2,24],60:[2,24],67:[2,24],69:[2,24],70:[2,24],71:[2,24]},{17:[2,25],22:[2,25],31:[2,25],40:[2,25],46:[2,25],48:[2,25],49:[2,25],52:[2,25],55:[2,25],57:[2,25],58:[2,25],60:[2,25],67:[2,25],69:[2,25],70:[2,25],71:[2,25]},{17:[2,26],22:[2,26],31:[2,26],40:[2,26],46:[2,26],48:[2,26],49:[2,26],52:[2,26],55:[2,26],57:[2,26],58:[2,26],60:[2,26],67:[2,26],69:[2,26],70:[2,26],71:[2,26]},{1:[2,2]},{1:[2,3]},{1:[2,4]},{1:[2,5]},{1:[2,6]},{1:[2,7]},{2:[1,109],4:108,5:[1,107],12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:111,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42],72:110},{1:[2,9]},{5:[2,96]},{5:[2,40],13:[2,40],15:[2,40],17:[2,40],21:[2,40],22:[1,60],23:[2,40],25:[2,40],26:[2,40],27:[2,40],28:[2,40],29:[2,40],31:[2,40],33:[2,40],35:[2,40],37:[2,40],38:[2,40],39:[2,40],40:[2,40],41:[2,40],46:[2,40],47:[2,40],48:[2,40],49:[2,40],50:[2,40],52:[2,40],57:[2,40],58:[2,40],60:[2,40],62:[2,40],65:[2,40],67:[2,40],69:[2,40],70:[2,40],71:[2,40]},{4:112,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:63,17:[1,14],22:[1,64],30:113,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:63,17:[1,14],22:[1,64],30:114,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{19:115,20:[1,18],22:[1,116]},{5:[2,33],13:[2,33],15:[2,33],17:[2,33],21:[2,33],22:[2,33],23:[2,33],25:[2,33],26:[2,33],27:[2,33],28:[2,33],29:[2,33],31:[2,33],33:[2,33],35:[2,33],36:80,37:[1,73],38:[1,74],39:[1,75],40:[2,33],41:[2,33],46:[2,33],47:[2,33],48:[2,33],49:[2,33],50:[1,81],52:[2,33],57:[2,33],58:[2,33],60:[2,33],62:[2,33],65:[2,33],67:[2,33],69:[2,33],70:[2,33],71:[2,33]},{12:63,17:[1,14],22:[1,64],31:[1,21],32:22,34:117,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:63,17:[1,14],22:[1,64],31:[1,21],32:22,34:118,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,58],13:[2,58],15:[2,58],17:[2,58],21:[2,58],22:[2,58],23:[2,58],25:[2,58],26:[2,58],27:[2,58],28:[2,58],29:[2,58],31:[2,58],33:[2,58],35:[2,58],37:[2,58],38:[2,58],39:[2,58],40:[2,58],41:[2,58],46:[2,58],47:[2,58],48:[2,58],49:[2,58],50:[2,58],52:[2,58],57:[2,58],58:[2,58],60:[2,58],62:[2,58],65:[2,58],67:[2,58],69:[2,58],70:[2,58],71:[2,58]},{5:[2,59],13:[2,59],15:[2,59],17:[2,59],21:[2,59],22:[2,59],23:[2,59],25:[2,59],26:[2,59],27:[2,59],28:[2,59],29:[2,59],31:[2,59],33:[2,59],35:[2,59],37:[2,59],38:[2,59],39:[2,59],40:[2,59],41:[2,59],46:[2,59],47:[2,59],48:[2,59],49:[2,59],50:[2,59],52:[2,59],57:[2,59],58:[2,59],60:[2,59],62:[2,59],65:[2,59],67:[2,59],69:[2,59],70:[2,59],71:[2,59]},{5:[2,37],13:[2,37],15:[2,37],17:[2,37],21:[2,37],22:[2,37],23:[2,37],25:[2,37],26:[2,37],27:[2,37],28:[2,37],29:[2,37],31:[2,37],33:[2,37],35:[2,37],37:[2,37],38:[2,37],39:[2,37],40:[2,37],41:[2,37],46:[2,37],47:[2,37],48:[2,37],49:[2,37],50:[2,37],52:[2,37],55:[2,37],57:[2,37],58:[2,37],60:[2,37],62:[2,37],65:[2,37],67:[2,37],69:[2,37],70:[2,37],71:[2,37]},{5:[2,38],13:[2,38],15:[2,38],17:[2,38],21:[2,38],22:[2,38],23:[2,38],25:[2,38],26:[2,38],27:[2,38],28:[2,38],29:[2,38],31:[2,38],33:[2,38],35:[2,38],37:[2,38],38:[2,38],39:[2,38],40:[2,38],41:[2,38],46:[2,38],47:[2,38],48:[2,38],49:[2,38],50:[2,38],52:[2,38],55:[2,38],57:[2,38],58:[2,38],60:[2,38],62:[2,38],65:[2,38],67:[2,38],69:[2,38],70:[2,38],71:[2,38]},{40:[1,119]},{15:[1,120]},{15:[1,121],23:[1,122]},{5:[2,74],13:[2,74],15:[2,74],17:[2,74],21:[2,74],22:[2,74],23:[2,74],25:[2,74],26:[2,74],27:[2,74],28:[2,74],29:[2,74],31:[2,74],33:[2,74],35:[2,74],36:123,37:[1,73],38:[1,74],39:[1,75],40:[2,74],41:[2,74],46:[2,74],47:[2,74],48:[2,74],49:[2,74],50:[2,74],52:[2,74],57:[2,74],58:[2,74],60:[2,74],62:[2,74],65:[2,74],67:[2,74],69:[2,74],70:[2,74],71:[2,74]},{5:[2,60],13:[2,60],15:[2,60],17:[2,60],21:[2,60],22:[2,60],23:[2,60],25:[2,60],26:[2,60],27:[2,60],28:[2,60],29:[2,60],31:[2,60],33:[2,60],35:[2,60],36:71,37:[1,73],38:[1,74],39:[1,75],40:[2,60],41:[2,60],46:[2,60],47:[2,60],48:[2,60],49:[2,60],50:[1,72],52:[2,60],57:[2,60],58:[2,60],60:[2,60],62:[2,60],65:[2,60],67:[2,60],69:[2,60],70:[2,60],71:[2,60]},{5:[2,48],13:[2,48],15:[2,48],17:[2,48],21:[2,48],22:[2,48],23:[2,48],25:[2,48],26:[2,48],27:[2,48],28:[2,48],29:[2,48],31:[2,48],33:[2,48],35:[2,48],37:[2,48],38:[2,48],39:[2,48],40:[2,48],41:[2,48],46:[2,48],47:[2,48],48:[2,48],49:[2,48],50:[2,48],52:[2,48],57:[2,48],58:[2,48],60:[2,48],62:[2,48],65:[2,48],67:[2,48],69:[2,48],70:[2,48],71:[2,48]},{5:[2,52],13:[2,52],15:[2,52],17:[2,52],21:[2,52],22:[2,52],23:[2,52],25:[2,52],26:[2,52],27:[2,52],28:[2,52],29:[2,52],31:[2,52],33:[2,52],35:[2,52],37:[2,52],38:[2,52],39:[2,52],40:[2,52],41:[2,52],46:[2,52],47:[2,52],48:[2,52],49:[2,52],50:[2,52],52:[2,52],57:[2,52],58:[2,52],60:[2,52],62:[2,52],65:[2,52],67:[2,52],69:[2,52],70:[2,52],71:[2,52]},{41:[1,124]},{47:[1,125]},{4:126,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:127,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:128,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,54],12:63,13:[2,54],15:[2,54],17:[1,14],21:[2,54],22:[1,64],23:[2,54],25:[2,54],26:[2,54],27:[2,54],28:[2,54],29:[2,54],31:[2,54],32:68,33:[1,69],35:[1,70],37:[2,54],38:[2,54],39:[2,54],40:[1,28],41:[2,54],42:24,43:25,44:26,45:27,46:[1,29],47:[2,54],48:[1,30],49:[1,31],50:[2,54],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,54],65:[2,54],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:129,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,79],12:63,13:[2,79],15:[2,79],17:[1,14],21:[2,79],22:[1,64],23:[2,79],25:[2,79],26:[2,79],27:[2,79],28:[2,79],29:[2,79],31:[2,79],32:68,33:[1,69],35:[1,70],37:[2,79],38:[2,79],39:[2,79],40:[1,28],41:[2,79],42:24,43:25,44:26,45:27,46:[1,29],47:[2,79],48:[1,30],49:[1,31],50:[2,79],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,79],65:[2,79],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{40:[1,130]},{12:63,17:[1,14],22:[1,132],30:131,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:133,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,90],12:63,13:[2,90],15:[2,90],17:[1,14],21:[2,90],22:[1,64],23:[2,90],25:[2,90],26:[2,90],27:[2,90],28:[2,90],29:[2,90],31:[2,90],32:68,33:[1,69],35:[1,70],37:[2,90],38:[2,90],39:[2,90],40:[1,28],41:[2,90],42:24,43:25,44:26,45:27,46:[1,29],47:[2,90],48:[1,30],49:[1,31],50:[2,90],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,90],65:[2,90],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:63,17:[1,14],22:[1,134],30:135,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{40:[1,136]},{62:[1,137]},{5:[2,66],13:[2,66],15:[2,66],17:[2,66],21:[2,66],22:[2,66],23:[2,66],25:[2,66],26:[2,66],27:[2,66],28:[2,66],29:[2,66],31:[2,66],33:[2,66],35:[2,66],37:[2,66],38:[2,66],39:[2,66],40:[2,66],41:[2,66],46:[2,66],47:[2,66],48:[2,66],49:[2,66],50:[2,66],52:[2,66],57:[2,66],58:[2,66],60:[2,66],62:[2,66],65:[2,66],67:[2,66],69:[2,66],70:[2,66],71:[2,66]},{15:[1,138],62:[2,68]},{15:[2,70],62:[2,70]},{15:[2,72],62:[2,72],65:[1,139]},{13:[1,141],16:140,25:[1,49],26:[1,50],27:[1,51],28:[1,52]},{12:142,17:[1,14],40:[1,143]},{5:[1,144]},{5:[2,14]},{5:[2,40],16:145,17:[2,40],22:[1,60],25:[1,49],26:[1,50],27:[1,51],28:[1,52],29:[2,40],31:[2,40],33:[2,40],35:[2,40],37:[2,40],38:[2,40],39:[2,40],40:[2,40],46:[2,40],48:[2,40],49:[2,40],50:[2,40],52:[2,40],57:[2,40],58:[2,40],60:[2,40],67:[2,40],69:[2,40],70:[2,40],71:[2,40]},{5:[2,27],15:[2,27],16:146,25:[1,49],26:[1,50],27:[1,51],28:[1,52],62:[2,27],65:[2,27]},{1:[2,8]},{5:[2,12]},{5:[2,13]},{15:[1,148],23:[1,147]},{15:[1,150],23:[1,149]},{23:[1,122]},{5:[2,30],12:63,13:[2,30],15:[2,30],17:[1,14],21:[2,30],22:[1,64],23:[2,30],25:[2,30],26:[2,30],27:[2,30],28:[2,30],29:[2,30],31:[2,30],32:68,33:[1,69],35:[1,70],37:[2,30],38:[2,30],39:[2,30],40:[1,28],41:[2,30],42:24,43:25,44:26,45:27,46:[1,29],47:[2,30],48:[1,30],49:[1,31],50:[2,30],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,30],65:[2,30],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,31],12:63,13:[2,31],15:[2,31],17:[1,14],21:[2,31],22:[1,64],23:[2,31],25:[2,31],26:[2,31],27:[2,31],28:[2,31],29:[2,31],31:[2,31],32:68,33:[1,69],35:[1,70],37:[2,31],38:[2,31],39:[2,31],40:[1,28],41:[2,31],42:24,43:25,44:26,45:27,46:[1,29],47:[2,31],48:[1,30],49:[1,31],50:[2,31],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,31],65:[2,31],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,19],15:[2,19]},{4:151,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,34],13:[2,34],15:[2,34],17:[2,34],21:[2,34],22:[2,34],23:[2,34],25:[2,34],26:[2,34],27:[2,34],28:[2,34],29:[2,34],31:[2,34],33:[2,34],35:[2,34],36:71,37:[1,73],38:[1,74],39:[1,75],40:[2,34],41:[2,34],46:[2,34],47:[2,34],48:[2,34],49:[2,34],50:[1,72],52:[2,34],57:[2,34],58:[2,34],60:[2,34],62:[2,34],65:[2,34],67:[2,34],69:[2,34],70:[2,34],71:[2,34]},{5:[2,35],13:[2,35],15:[2,35],17:[2,35],21:[2,35],22:[2,35],23:[2,35],25:[2,35],26:[2,35],27:[2,35],28:[2,35],29:[2,35],31:[2,35],33:[2,35],35:[2,35],36:71,37:[1,73],38:[1,74],39:[1,75],40:[2,35],41:[2,35],46:[2,35],47:[2,35],48:[2,35],49:[2,35],50:[1,72],52:[2,35],57:[2,35],58:[2,35],60:[2,35],62:[2,35],65:[2,35],67:[2,35],69:[2,35],70:[2,35],71:[2,35]},{4:152,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:153,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:154,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,45],13:[2,45],15:[2,45],17:[2,45],21:[2,45],22:[2,45],23:[2,45],25:[2,45],26:[2,45],27:[2,45],28:[2,45],29:[2,45],31:[2,45],33:[2,45],35:[2,45],37:[2,45],38:[2,45],39:[2,45],40:[2,45],41:[2,45],46:[2,45],47:[2,45],48:[2,45],49:[2,45],50:[2,45],52:[2,45],57:[2,45],58:[2,45],60:[2,45],62:[2,45],65:[2,45],67:[2,45],69:[2,45],70:[2,45],71:[2,45]},{5:[2,57],13:[2,57],15:[2,57],17:[2,57],21:[2,57],22:[2,57],23:[2,57],25:[2,57],26:[2,57],27:[2,57],28:[2,57],29:[2,57],31:[2,57],33:[2,57],35:[2,57],37:[2,57],38:[2,57],39:[2,57],40:[2,57],41:[2,57],46:[2,57],47:[2,57],48:[2,57],49:[2,57],50:[2,57],52:[2,57],57:[2,57],58:[2,57],60:[2,57],62:[2,57],65:[2,57],67:[2,57],69:[2,57],70:[2,57],71:[2,57]},{5:[2,46],13:[2,46],15:[2,46],17:[2,46],21:[2,46],22:[2,46],23:[2,46],25:[2,46],26:[2,46],27:[2,46],28:[2,46],29:[2,46],31:[2,46],33:[2,46],35:[2,46],37:[2,46],38:[2,46],39:[2,46],40:[2,46],41:[2,46],46:[2,46],47:[2,46],48:[2,46],49:[2,46],50:[2,46],52:[2,46],57:[2,46],58:[2,46],60:[2,46],62:[2,46],65:[2,46],67:[2,46],69:[2,46],70:[2,46],71:[2,46]},{5:[2,47],13:[2,47],15:[2,47],17:[2,47],21:[2,47],22:[2,47],23:[2,47],25:[2,47],26:[2,47],27:[2,47],28:[2,47],29:[2,47],31:[2,47],33:[2,47],35:[2,47],37:[2,47],38:[2,47],39:[2,47],40:[2,47],41:[2,47],46:[2,47],47:[2,47],48:[2,47],49:[2,47],50:[2,47],52:[2,47],57:[2,47],58:[2,47],60:[2,47],62:[2,47],65:[2,47],67:[2,47],69:[2,47],70:[2,47],71:[2,47]},{41:[1,155]},{41:[1,156]},{21:[1,157]},{23:[1,158]},{31:[1,159]},{5:[2,82],12:63,13:[2,82],15:[2,82],17:[1,14],21:[2,82],22:[1,64],23:[2,82],25:[2,82],26:[2,82],27:[2,82],28:[2,82],29:[2,82],31:[2,82],32:68,33:[1,69],35:[1,70],37:[2,82],38:[2,82],39:[2,82],40:[1,28],41:[2,82],42:24,43:25,44:26,45:27,46:[1,29],47:[2,82],48:[1,30],49:[1,31],50:[2,82],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,82],65:[2,82],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:160,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{23:[1,161]},{4:162,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,92],12:63,13:[2,92],15:[2,92],17:[1,14],21:[2,92],22:[1,64],23:[2,92],25:[2,92],26:[2,92],27:[2,92],28:[2,92],29:[2,92],31:[2,92],32:68,33:[1,69],35:[1,70],37:[2,92],38:[2,92],39:[2,92],40:[1,28],41:[2,92],42:24,43:25,44:26,45:27,46:[1,29],47:[2,92],48:[1,30],49:[1,31],50:[2,92],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,92],65:[2,92],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{12:163,17:[1,14]},{5:[2,65],13:[2,65],15:[2,65],17:[2,65],21:[2,65],22:[2,65],23:[2,65],25:[2,65],26:[2,65],27:[2,65],28:[2,65],29:[2,65],31:[2,65],33:[2,65],35:[2,65],37:[2,65],38:[2,65],39:[2,65],40:[2,65],41:[2,65],46:[2,65],47:[2,65],48:[2,65],49:[2,65],50:[2,65],52:[2,65],57:[2,65],58:[2,65],60:[2,65],62:[2,65],65:[2,65],67:[2,65],69:[2,65],70:[2,65],71:[2,65]},{4:164,11:100,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],64:165,66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:166,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:106,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:167,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{17:[2,87],22:[2,87],31:[2,87],37:[2,87],40:[2,87],46:[2,87],48:[2,87],49:[2,87],52:[2,87],55:[2,87],57:[2,87],58:[2,87],60:[2,87],67:[2,87],69:[2,87],70:[2,87],71:[2,87]},{4:168,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{1:[2,10]},{4:169,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:170,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,93],13:[2,93],15:[2,93],17:[2,93],21:[2,93],22:[2,93],23:[2,93],25:[2,93],26:[2,93],27:[2,93],28:[2,93],29:[2,93],31:[2,93],33:[2,93],35:[2,93],37:[2,93],38:[2,93],39:[2,93],40:[2,93],41:[2,93],46:[2,93],47:[2,93],48:[2,93],49:[2,93],50:[2,93],52:[2,93],57:[2,93],58:[2,93],60:[2,93],62:[2,93],65:[2,93],67:[2,93],69:[2,93],70:[2,93],71:[2,93]},{4:171,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,76],13:[2,76],15:[2,76],17:[2,76],21:[2,76],22:[2,76],23:[2,76],25:[2,76],26:[2,76],27:[2,76],28:[2,76],29:[2,76],31:[2,76],33:[2,76],35:[2,76],36:172,37:[1,73],38:[1,74],39:[1,75],40:[2,76],41:[2,76],46:[2,76],47:[2,76],48:[2,76],49:[2,76],50:[2,76],52:[2,76],57:[2,76],58:[2,76],60:[2,76],62:[2,76],65:[2,76],67:[2,76],69:[2,76],70:[2,76],71:[2,76]},{4:173,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{15:[1,121]},{41:[1,174]},{21:[1,175]},{23:[1,176]},{40:[1,177]},{5:[2,50],13:[2,50],15:[2,50],17:[2,50],21:[2,50],22:[2,50],23:[2,50],25:[2,50],26:[2,50],27:[2,50],28:[2,50],29:[2,50],31:[2,50],33:[2,50],35:[2,50],37:[2,50],38:[2,50],39:[2,50],40:[2,50],41:[2,50],46:[2,50],47:[2,50],48:[2,50],49:[2,50],50:[2,50],52:[2,50],57:[2,50],58:[2,50],60:[2,50],62:[2,50],65:[2,50],67:[2,50],69:[2,50],70:[2,50],71:[2,50]},{40:[1,178]},{5:[2,78],13:[2,78],15:[2,78],17:[2,78],21:[2,78],22:[2,78],23:[2,78],25:[2,78],26:[2,78],27:[2,78],28:[2,78],29:[2,78],31:[2,78],33:[2,78],35:[2,78],37:[2,78],38:[2,78],39:[2,78],40:[2,78],41:[2,78],46:[2,78],47:[2,78],48:[2,78],49:[2,78],50:[2,78],52:[2,78],57:[2,78],58:[2,78],60:[2,78],62:[2,78],65:[2,78],67:[2,78],69:[2,78],70:[2,78],71:[2,78]},{31:[1,180],54:179,55:[1,23]},{23:[1,181]},{5:[2,89],13:[2,89],15:[2,89],17:[2,89],21:[2,89],22:[2,89],23:[2,89],25:[2,89],26:[2,89],27:[2,89],28:[2,89],29:[2,89],31:[2,89],33:[2,89],35:[2,89],37:[2,89],38:[2,89],39:[2,89],40:[2,89],41:[2,89],46:[2,89],47:[2,89],48:[2,89],49:[2,89],50:[2,89],52:[2,89],57:[2,89],58:[2,89],60:[2,89],62:[2,89],65:[2,89],67:[2,89],69:[2,89],70:[2,89],71:[2,89]},{23:[1,182]},{13:[1,183]},{13:[1,141],16:140,25:[1,49],26:[1,50],27:[1,51],28:[1,52],62:[2,67]},{15:[2,69],62:[2,69]},{15:[2,71],62:[2,71]},{15:[2,28],62:[2,28],65:[2,28]},{41:[1,184]},{5:[2,15]},{5:[2,29],15:[2,29],62:[2,29],65:[2,29]},{15:[2,94],23:[2,94]},{5:[2,75],13:[2,75],15:[2,75],17:[2,75],21:[2,75],22:[2,75],23:[2,75],25:[2,75],26:[2,75],27:[2,75],28:[2,75],29:[2,75],31:[2,75],33:[2,75],35:[2,75],37:[2,75],38:[2,75],39:[2,75],40:[2,75],41:[2,75],46:[2,75],47:[2,75],48:[2,75],49:[2,75],50:[2,75],52:[2,75],57:[2,75],58:[2,75],60:[2,75],62:[2,75],65:[2,75],67:[2,75],69:[2,75],70:[2,75],71:[2,75]},{15:[2,95],23:[2,95]},{5:[2,39],13:[2,39],15:[2,39],17:[2,39],21:[2,39],22:[2,39],23:[2,39],25:[2,39],26:[2,39],27:[2,39],28:[2,39],29:[2,39],31:[2,39],33:[2,39],35:[2,39],37:[2,39],38:[2,39],39:[2,39],40:[2,39],41:[2,39],46:[2,39],47:[2,39],48:[2,39],49:[2,39],50:[2,39],52:[2,39],55:[2,39],57:[2,39],58:[2,39],60:[2,39],62:[2,39],65:[2,39],67:[2,39],69:[2,39],70:[2,39],71:[2,39]},{5:[2,20],15:[2,20]},{5:[2,21],15:[2,21]},{4:185,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:186,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{41:[1,187]},{55:[1,188]},{5:[2,83],13:[2,83],15:[2,83],17:[2,83],21:[2,83],22:[2,83],23:[2,83],25:[2,83],26:[2,83],27:[2,83],28:[2,83],29:[2,83],31:[2,83],33:[2,83],35:[2,83],37:[2,83],38:[2,83],39:[2,83],40:[2,83],41:[2,83],46:[2,83],47:[2,83],48:[2,83],49:[2,83],50:[2,83],52:[2,83],57:[2,83],58:[2,83],60:[2,83],62:[2,83],65:[2,83],67:[2,83],69:[2,83],70:[2,83],71:[2,83]},{5:[2,91],13:[2,91],15:[2,91],17:[2,91],21:[2,91],22:[2,91],23:[2,91],25:[2,91],26:[2,91],27:[2,91],28:[2,91],29:[2,91],31:[2,91],33:[2,91],35:[2,91],37:[2,91],38:[2,91],39:[2,91],40:[2,91],41:[2,91],46:[2,91],47:[2,91],48:[2,91],49:[2,91],50:[2,91],52:[2,91],57:[2,91],58:[2,91],60:[2,91],62:[2,91],65:[2,91],67:[2,91],69:[2,91],70:[2,91],71:[2,91]},{4:189,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{17:[2,88],22:[2,88],31:[2,88],37:[2,88],40:[2,88],46:[2,88],48:[2,88],49:[2,88],52:[2,88],55:[2,88],57:[2,88],58:[2,88],60:[2,88],67:[2,88],69:[2,88],70:[2,88],71:[2,88]},{41:[1,190]},{41:[1,191]},{12:63,17:[1,14],22:[1,193],30:192,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{41:[2,74]},{41:[1,194]},{5:[2,49],13:[2,49],15:[2,49],17:[2,49],21:[2,49],22:[2,49],23:[2,49],25:[2,49],26:[2,49],27:[2,49],28:[2,49],29:[2,49],31:[2,49],33:[2,49],35:[2,49],37:[2,49],38:[2,49],39:[2,49],40:[2,49],41:[2,49],46:[2,49],47:[2,49],48:[2,49],49:[2,49],50:[2,49],52:[2,49],57:[2,49],58:[2,49],60:[2,49],62:[2,49],65:[2,49],67:[2,49],69:[2,49],70:[2,49],71:[2,49]},{5:[2,51],13:[2,51],15:[2,51],17:[2,51],21:[2,51],22:[2,51],23:[2,51],25:[2,51],26:[2,51],27:[2,51],28:[2,51],29:[2,51],31:[2,51],33:[2,51],35:[2,51],37:[2,51],38:[2,51],39:[2,51],40:[2,51],41:[2,51],46:[2,51],47:[2,51],48:[2,51],49:[2,51],50:[2,51],52:[2,51],57:[2,51],58:[2,51],60:[2,51],62:[2,51],65:[2,51],67:[2,51],69:[2,51],70:[2,51],71:[2,51]},{5:[2,80],12:63,13:[2,80],15:[2,80],17:[1,14],21:[2,80],22:[1,64],23:[2,80],25:[2,80],26:[2,80],27:[2,80],28:[2,80],29:[2,80],31:[2,80],32:68,33:[1,69],35:[1,70],37:[2,80],38:[2,80],39:[2,80],40:[1,28],41:[2,80],42:24,43:25,44:26,45:27,46:[1,29],47:[2,80],48:[1,30],49:[1,31],50:[2,80],51:32,52:[1,33],53:34,56:37,57:[1,43],58:[1,44],60:[1,38],62:[2,80],65:[2,80],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{4:195,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{36:196,37:[1,73],38:[1,74],39:[1,75]},{23:[1,197]},{4:198,12:63,17:[1,14],22:[1,64],24:12,30:15,31:[1,21],32:22,34:17,40:[1,28],42:24,43:25,44:26,45:27,46:[1,29],48:[1,30],49:[1,31],51:32,52:[1,33],53:34,54:20,55:[1,23],56:37,57:[1,43],58:[1,44],60:[1,38],66:35,67:[1,39],68:36,69:[1,40],70:[1,41],71:[1,42]},{5:[2,81],13:[2,81],15:[2,81],17:[2,81],21:[2,81],22:[2,81],23:[2,81],25:[2,81],26:[2,81],27:[2,81],28:[2,81],29:[2,81],31:[2,81],33:[2,81],35:[2,81],37:[2,81],38:[2,81],39:[2,81],40:[2,81],41:[2,81],46:[2,81],47:[2,81],48:[2,81],49:[2,81],50:[2,81],52:[2,81],57:[2,81],58:[2,81],60:[2,81],62:[2,81],65:[2,81],67:[2,81],69:[2,81],70:[2,81],71:[2,81]},{5:[2,64],13:[2,64],15:[2,64],17:[2,64],21:[2,64],22:[2,64],23:[2,64],25:[2,64],26:[2,64],27:[2,64],28:[2,64],29:[2,64],31:[2,64],33:[2,64],35:[2,64],37:[2,64],38:[2,64],39:[2,64],40:[2,64],41:[2,64],46:[2,64],47:[2,64],48:[2,64],49:[2,64],50:[2,64],52:[2,64],57:[2,64],58:[2,64],60:[2,64],62:[2,64],65:[2,64],67:[2,64],69:[2,64],70:[2,64],71:[2,64]}],
defaultActions: {11:[2,11],43:[2,62],44:[2,63],45:[2,1],53:[2,2],54:[2,3],55:[2,4],56:[2,5],57:[2,6],58:[2,7],61:[2,9],62:[2,96],104:[2,14],107:[2,8],108:[2,12],109:[2,13],144:[2,10],169:[2,15],188:[2,74]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    //this.reductionCount = this.shiftCount = 0;

    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == 'undefined')
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);

    var ranges = this.lexer.options && this.lexer.options.ranges;

    if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

    function popStack (n) {
        stack.length = stack.length - 2*n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

    function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length-1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        _handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {

            var errStr = '';
            if (!recovering) {
                // Report error
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                    expected.push("'"+this.terminals_[p]+"'");
                }
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol)+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr,
                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                }

                // discard current lookahead and grab another
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            while (1) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    break;
                }
                if (state === 0) {
                    throw new Error(errStr || 'Parsing halted.');
                }
                popStack(1);
                state = stack[stack.length-1];
            }

            preErrorSymbol = symbol == 2 ? null : symbol; // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {

            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                        recovering--;
                } else { // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2: // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
                }
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3: // accept
                return true;
        }

    }

    return true;
}};
/* Jison generated lexer */
var lexer = (function(){
var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        if (this.options.ranges) this.yylloc.range = [0,0];
        this.offset = 0;
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) this.yylloc.range[1]++;

        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length-1);
        this.matched = this.matched.substr(0, this.matched.length-1);

        if (lines.length-1) this.yylineno -= lines.length-1;
        var r = this.yylloc.range;

        this.yylloc = {first_line: this.yylloc.first_line,
          last_line: this.yylineno+1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
              this.yylloc.first_column - len
          };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
less:function (n) {
        this.unput(this.match.slice(n));
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            tempMatch,
            index,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex) break;
            }
        }
        if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {first_line: this.yylloc.last_line,
                           last_line: this.yylineno+1,
                           first_column: this.yylloc.last_column,
                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;
            else return;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.options = {};
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 40
break;
case 2:return 41
break;
case 3:return 'MATH_SHIFT'
break;
case 4:yy_.yytext = this.matches[this.matches.length - 1]; return 37
break;
case 5:yy_.yytext = this.matches[this.matches.length - 1]; return 38
break;
case 6:return 39
break;
case 7:return 55
break;
case 8:return 33
break;
case 9:return 35
break;
case 10:yy_.yytext = this.matches[3]; return 52
break;
case 11:yy_.yytext = this.matches[this.matches.length - 1]; return 71
break;
case 12:return 69
break;
case 13:return 70
break;
case 14:return 48
break;
case 15:return 49
break;
case 16:return 57
break;
case 17:return 58
break;
case 18:return 46  /* rely on mathquill */
break;
case 19:return 47 /* for pairing */
break;
case 20:return 31
break;
case 21:return 29
break;
case 22:return 13
break;
case 23:return 59
break;
case 24:return 50
break;
case 25:return 5
break;
case 26:return 22
break;
case 27:return 23
break;
case 28:return 20
break;
case 29:return 21
break;
case 30:return 60
break;
case 31:return 62
break;
case 32:return 65
break;
case 33:return 27
break;
case 34:return 28
break;
case 35:return 26
break;
case 36:return 25
break;
case 37:return 15
break;
case 38:return 14 
break;
case 39:return 67        /* sin, cos, sinh, ln*/
break;
case 40:yy_.yytext = '\\sign'; return 17
break;
case 41:yy_.yytext = '\\gcd'; return 17
break;
case 42:yy_.yytext = '\\lcm'; return 17
break;
case 43:return 17          /* Predefined functions, as well as user-defined variables.  Doesn't include subscripts */
break;
case 44:/* skip LINE_START if it's not needed for something else */
break;
case 45:return 'UNRECOGNIZED'
break;
}
};
lexer.rules = [/^(?:(\\space|\\:|\s)+)/,/^(?:\{)/,/^(?:\})/,/^(?:\$)/,/^(?:\^([0-9]))/,/^(?:\^([a-zA-Z]))/,/^(?:\^)/,/^(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))/,/^(?:\*|(\\cdot))/,/^(?:\/)/,/^(?:(\\frac((?:\s|\\space|\\:)*)\{d\}\{d(((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))\}))/,/^(?:(\\log)((?:\s|\\space|\\:)*)*_([0-9]))/,/^(?:(\\ln))/,/^(?:(\\log))/,/^(?:(\\frac))/,/^(?:(\\sqrt))/,/^(?:(\\sum))/,/^(?:(\\prod))/,/^(?:\\left\|)/,/^(?:\\right\|)/,/^(?:-)/,/^(?:\+)/,/^(?:=)/,/^(?:[_])/,/^(?:!)/,/^(?:$)/,/^(?:(\()|\\left\()/,/^(?:(\))|\\right\))/,/^(?:(\[)|\\left\[)/,/^(?:(\])|\\right\])/,/^(?:(\\\{)|\\left\\\{)/,/^(?:(\\\})|\\right\\\})/,/^(?::)/,/^(?:(\\ge|>=))/,/^(?:(\\le|<=))/,/^(?:(\\gt|>))/,/^(?:(\\lt|<))/,/^(?:,)/,/^(?:(###)(((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*)(\\left\(|\()((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)(((?:\s|\\space|\\:)*),((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*))*((?:\s|\\space|\\:)*)(\\right\)|\))((?:\s|\\space|\\:)*)=))/,/^(?:(\\(arc)?(sin|cos|tan|cot|sec|csc)h?))/,/^(?:(\\signum))/,/^(?:(\\(gcf|mcd)))/,/^(?:(\\mcm))/,/^(?:((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))/,/^(?:(###))/,/^(?:.)/];
lexer.conditions = {"conditional":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45],"inclusive":true}};
return lexer;})()
parser.lexer = lexer;
return parser;
});
define('math/inverses',[],function () {
  var inverses = {};

  // Functions with an inverse spelled arcname
  var arcNames = [
    'sin',
    'cos',
    'tan',
    'cot',
    'sec',
    'csc',
    'sinh',
    'cosh',
    'tanh',
    'coth',
    'sech',
    'csch'
  ];

  arcNames.forEach(function (name) {
    inverses[name] = 'arc' + name;
    inverses['arc' + name] = name;
  });

  return inverses;
});
var define_enum_constant;
var enum_strings = {};
var debuggable_enums = true;

if(debuggable_enums){
  define_enum_constant = function(s){
    this[s] = s;
  };
}
else{
  var next_enum = 1000;
  define_enum_constant = function(s){
    enum_strings[next_enum] = s;
    this[s] = next_enum++;
  };
}

//Statement types (determined entirely from the root element of the parse tree)
define_enum_constant("EXPRESSION");              //a+1 or 1+1
define_enum_constant("FUNCTION_DEFINITION");     //f(x)=???
define_enum_constant("VARIABLE_DEFINITION");     //a=???
define_enum_constant("ORDERED_PAIR_LIST");     // (?, ?), (?, ?).  Support lists of points, but only single parametrics
define_enum_constant("DOUBLE_INEQUALITY");       // expr < y < expr, shade-between
define_enum_constant("COMPARATOR");       // expr < expr - unsolved inequality
define_enum_constant("CHAINED_COMPARATOR");       // a < ??? - not a conditional as an expression
define_enum_constant("EQUATION");         // expr = expr
define_enum_constant("CONSTANT");
define_enum_constant("IDENTIFIER");

define("math/enums", function(){});

define('math/parser_util',['require','pjs','./evalframe','./comparators','parser','./inverses','./builtin','./enums'],function(require){
  /* jshint maxlen: false */
  var P = require('pjs');
  var EvalFrame = require('./evalframe');
  var Comparators = require('./comparators');
  var latex = require('parser');
  var inverses = require('./inverses');
  var BuiltIn = require('./builtin');
  require('./enums');

var exports = {};

latex.yy.inverses = inverses;

var ParseNode = exports.ParseNode = P(function (node) {
  node.init = function () {
    this._dependencies = {};
    this._referencedSymbols = {};
  };
  //TODO - consider just storing ranges, and linking them to the latex string at request time
  node.setInputString = function (s) {
    this._inputString = s;
  };
  node.getInputString = function () {
    return this._inputString;
  };
  node.statementType = EXPRESSION;
  node.assigns = null;
  node.valid = true;
  node.exportDefinitionsTo = function (frame, compiler) {};
  node.evaluateOnce = function (frame) {return "Unable to evaluate"};
  node.addDependency = function (identifier, arity) {
    //_dependency stores the identifiers which are depended on, as well as their required arity/type
    //0 => variable
    //1 => ambiguous between unary function and implicit multiplication
    //n>1 => function of arity n
    this.referenceSymbol(identifier);
  
    if(!this._dependencies.hasOwnProperty(identifier)) { //New dependency
      this._dependencies[identifier] = arity;
      return;
    }

    //We already depend on this, need to make sure new and old dependencies are consistent
    var prior_arity = this._dependencies[identifier];

    if (arity === prior_arity) { return } //Consistent - no change to dependency structure

    if (arity === 1 && prior_arity === 0) { return } //New ambiguous entry is consistent with prior variable definition

    if (arity === 0 && prior_arity === 1) {
      this._dependencies[identifier] = arity;  //Dependency on identifier as a variable resolves previous ambiguity
      return;
    }

    if (arity === 0 || prior_arity === 0) {
      throw("You're referencing '" + identifier + "' as both a function and a variable. Make up your mind!");
    } else {
      throw("You're referencing '" + identifier + "' as both a " + prior_arity + "-variable and a " + arity + "-variable function. Make up your mind!");
    }
  };

  node.referenceSymbol = function (identifier) {
    this._referencedSymbols[identifier] = true;
  };

  node.shadowVariable = function (identifier) {
    this.referenceSymbol(identifier);
    if(!this._dependencies.hasOwnProperty(identifier)) return;

    var prior_arity = this._dependencies[identifier];
    if(prior_arity <= 1) {
      delete this._dependencies[identifier];
      return;
    }
    throw("Cannot redefine function "+identifier+" as a variable");
  };

  node.addDependencies = function (dependencies) {
    for (var identifier in dependencies) {
      if(!dependencies.hasOwnProperty(identifier)) continue;

      var arity = dependencies[identifier];
      this.addDependency(identifier, arity);
    }
  };

  //Used to determine re-computation dependencies
  //Needs to be different than dependencies, because f(a)=a doesn't depend on a, but throws an error when a is defined
  node.references = function (identifier) {
    if(this._referencedSymbols[identifier]) return true; //For shadowed varibles, etc.
  };

  node.dependencies = function () {
    return this._dependencies;
  };

  node.getEvalStrings = function () {
    throw("Cannot call getEvalStrings on base ParseNode");
  };

  node.polynomialOrder = function () {
    return Infinity;
  };

  //Generate non-colliding names
  //To play it safe, we want to never re-use temp variables;
  //This shouldn't wrap around until 2^52.  2^52 microseconds is 142 years.
  //All variables will be of the form tmp123, which we don't allow as a real variable name
  node.uid_counter = [0]; //Same reference for everyone
  node.tmp = function () {
    return 'tmp'+this.uid_counter[0]++;
  };

  node.okForImplicitFunction = function () {
    return false;
  };
 
});

exports.AssignmentNode = P(ParseNode, function (node, _super) {
  node.init = function (identifier, expression) {
    _super.init.call(this);
    this.assigns = identifier;
    this.referenceSymbol(this.assigns.identifier);
    this.arity = 0;
    this.expression = expression;
    this.addDependencies(expression.dependencies());
    this.lhs = identifier; //masquerade as equation
    this.rhs = expression; //masquerade as equation
    //Decide if we should act as an assignment or an equation
    //TODO - may want this policy to live somewhere else
    //Current policy is just whether we have a circular dependency
    if(this.dependencies().hasOwnProperty(this.assigns.identifier)) {
      this.statementType = EQUATION;
    }
  };
  node.statementType = VARIABLE_DEFINITION;
  node.evaluateOnce = function (frame) {
    return this.expression.evaluateOnce(frame);
  };
  node.exportDefinitionsTo = function (frame, compiler) {  //Uses the same frame as evaluation context
    if(this.statementType === EQUATION) return;
    try{
      var constant_value = this.expression.evaluateOnce(frame);
      var constant_node = ConstantNode(constant_value);
      frame.setVariable(this.assigns.identifier, constant_node);
      frame.setEvalStrings(this.assigns.identifier, constant_node.getEvalStrings(frame));
    }
    catch(e) {
      frame.setVariable(this.assigns.identifier, this.expression);
      frame.setEvalStrings(this.assigns.identifier, this.expression.getEvalStrings(frame));
    }
  };
  node.getEvalStrings = function (frame) {
    if(this.statementType === EQUATION) return _super.getEvalStrings(frame);
    return this.expression.getEvalStrings(frame);
  };
  
  node.toString = function () {
    return this.assigns + ' = ' + this.expression;
  };
});

exports.DoubleInequalityNode = P(ParseNode, function (node, _super) {
  node.init = function (expression1, comparator1, expressionm, comparator2, expression2) {
    _super.init.call(this);
    this._inequalities = [];

    if(Comparators.table[comparator1].direction != Comparators.table[comparator2].direction) {
      throw "Double inequalities must both go the same way, e.g. 1 < y < 2"; //TODO - need better error message
    }

    this.direction = Comparators.table[comparator1].direction;
    this.inclusive = (
        Comparators.table[comparator1].inclusive &&
        Comparators.table[comparator2].inclusive
    );
    var validity_comparator = Comparators.get(this.inclusive, this.direction);

    var valid_predicate = ComparatorNode(validity_comparator, expression1, expression2);
    var expression1_valid = PiecewiseNode(valid_predicate, expression1);
    var expression2_valid = PiecewiseNode(valid_predicate, expression2);

    this._inequalities.push(ComparatorNode(comparator1, expressionm,  expression1_valid)); //TODO - invert comparator
    this._inequalities.push(ComparatorNode(comparator2, expressionm, expression2_valid));


    this.addDependencies(expressionm.dependencies());
    this.addDependencies(expression1.dependencies());
    this.addDependencies(expression2.dependencies());

    node.statementType = DOUBLE_INEQUALITY;
  };

  node.getInequality = function (i) {
    return this._inequalities[i];
  };
});

exports.EquationNode = P(ParseNode, function (node, _super) {
  node.init = function (lhs, rhs) {
    _super.init.call(this);
    this.lhs = lhs;
    this.rhs = rhs;
    this.addDependencies(lhs.dependencies());
    this.addDependencies(rhs.dependencies());
  };

  node.statementType = EQUATION;

  node.toString = function () { return this.lhs + ' = ' + this.rhs; };
});

//Represents if-else
var PiecewiseNode = exports.PiecewiseNode = P(ParseNode, function (node, _super) {
  node.init = function (condition, if_expr, else_expr) {
    _super.init.call(this);
    this.condition = condition;
    this.if_expr = if_expr;
    this.frozen = false;
    if(else_expr) {
      this.else_expr = else_expr;
      this.addDependencies(this.else_expr._partial_dependencies());
    }
    this.addDependencies(condition.dependencies());
    this.addDependencies(if_expr.dependencies());
    //TODO - add dependencies
  };

  //Don't want to freeze dependencies while building the if-else chain
  //Only want to freeze once someone else asks about our dependencies, since they won't update in response to changes
  node._partial_dependencies = function () {
    return _super.dependencies;
  };

  //Chained if-else nodes (from {a:b, c:d, e} notation) are created by passing each subsequent clause down the parse tree, updating dependencies as it goes.
  //This is only valid when used "correctly" (e.g. start passing in the from the top node, and only pass during construction, not after use)
  node.append_else = function (else_expr) {
    if(this.frozen) throw("Programming Error - please treat me as immutable.  Cannot change PiecewiseNode after getting dependencies");
    if(this.else_expr) {
      this.else_expr.append_else(else_expr);
    }
    else{
      this.else_expr = else_expr;
    }
    this.addDependencies(else_expr.dependencies());  //Needs to be added to everyone all the way down the if-else chain to have correct dependencies for the whole tree.
    return this;
  };

  node.evaluateOnce = function (frame) {
    this.frozen = true;
    if(this.condition.evaluateOnce(frame)) {
      return this.if_expr.evaluateOnce(frame);
    }
    else if (this.else_expr) {
      return this.else_expr.evaluateOnce(frame);
    }
    return undefined;
  };

  node.getEvalStrings = function (frame) {
    var condition_strings = this.condition.getEvalStrings(frame);
    var if_strings = this.if_expr.getEvalStrings(frame);
    var else_strings;

    if(this.else_expr) {
      else_strings = this.else_expr.getEvalStrings(frame);
    }
    else{
      else_strings = {statements:'', expression:'undefined'};
    }

    var result = this.tmp();
    var statements = 'var '+result+';'+condition_strings.statements+
                     'if('+condition_strings.expression+') {'+
                      if_strings.statements+result+'='+if_strings.expression+
                     ';}else{'+
                      else_strings.statements+result+'='+else_strings.expression+';}';
    return { expression: result, statements: statements };
  };

  node.polynomialOrder = function (frame, variable) {
    if(this.dependencies().hasOwnProperty(variable)) {
      return Infinity;
    }
    else{
      return 0;
    }
  };

  node.quadraticCoefficients = function (frame, variable) {
    return [0, 0, this.evaluateOnce(frame)];
  };

  node.polynomialEvalStrings = function (frame, variable, arg) {
    var eval_strings = this.getEvalStrings(frame);
    return {statements:eval_strings.statements, expressions:[eval_strings.expression]};
  };

  node.toString = function () {

    if (!this.else_expr) {
      return '\\left\\{' +
        this.condition + ': ' + this.if_expr +
        '\\right\\}';
    }

    // Can't reparse literal true, so use special form.
    var elseString;
    if (this.else_expr.condition && this.else_expr.condition.value === true) {
      elseString = String(this.else_expr.if_expr);
    } else {
      // Unwind elses
      elseString = String(this.else_expr).replace(/^\\left\\\{(.*)\\right\\\}$/, '$1');
    }

    return '\\left\\{' +
      this.condition + ': ' + this.if_expr + ', ' + elseString +
      '\\right\\}';
  };

});

exports.OrderedPairNode = P(ParseNode, function (node, _super) {
  node.init = function (first, second) {
    _super.init.call(this);
    this.children = [first, second];
    this.addDependencies(first.dependencies());
    this.addDependencies(second.dependencies());
  };

  node.getEvalStrings = function (frame) {
    var first_strings = this.children[0].getEvalStrings(frame);
    var second_strings = this.children[1].getEvalStrings(frame);
    var statements = first_strings.statements + second_strings.statements;
    var expression = '['+first_strings.expression+','+second_strings.expression+']';
    return {statements: statements, expression:expression};
  };

  node.evaluateOnce = function (frame) {
    return [this.children[0].evaluateOnce(frame), this.children[1].evaluateOnce(frame)];
  };
  
  this.toString = function () {
    return '\\left(' +
      this.children[0] + ', ' +
      this.children[1] +
    '\\right)';
  };
});

var ErrorNode = exports.ErrorNode = P(ParseNode, function (node, _super) {
  node.init = function (msg) {
    _super.init.call(this);
    this.error_msg = msg;
  };
  node.valid = false;

  this.evaluateOnce = function (frame) {
    return this.error_msg;
  };
});

var ConstantNode = exports.ConstantNode = P(ParseNode, function (node, _super) {
  node.init = function (value) {
    _super.init.call(this);
    this.value = value;
  };
  node.evaluateOnce = function (frame) {
    return this.value;
  };
  node.getEvalStrings = function () {
    var statements = '';
    var expression = (this.value < 0 ? '('+String(this.value)+')' : String(this.value));
    return {expression:expression, statements:statements};
  };
  node.quadraticCoefficients = function (frame, variable) {
    return [0, 0, this.value];
  };
  node.polynomialEvalStrings = function (frame, variable, arg) {
    return {statements:'', expressions:['('+String(this.value)+')']};
  };

  node.polynomialOrder = function (frame, variable) {
    return 0;
  };

  node.okForImplicitFunction = function () {
    return true;
  };
  
  node.toString = function () { return String(this.value); };
  
  node.statementType = CONSTANT;
});

var NegationNode = exports.NegationNode = P(ParseNode, function (node, _super) {
    node.init = function (expression) {
      _super.init.call(this);
      this.expression = expression;
      this.addDependencies(this.expression.dependencies());
    };
    node.evaluateOnce = function (frame) {
      return -(this.expression.evaluateOnce(frame));
    };
    node.quadraticCoefficients = function (frame, variable) {
      var coeffs = this.expression.quadraticCoefficients(frame, variable);
      return [-coeffs[0], -coeffs[1], -coeffs[2]];
    };
    node.polynomialEvalStrings = function (frame, variable, arg) {
      var strings = this.expression.polynomialEvalStrings(frame, variable, arg);
      for (var i = 0; i < strings.expressions.length; i++) {
        strings.expressions[i] = '(-'+strings.expressions[i]+')';
      }
      return strings;
    };
    node.polynomialOrder = function (frame, variable) {
      return this.expression.polynomialOrder(frame, variable);
    };
    node.getEvalStrings = function (frame) {
      var evalStrings = this.expression.getEvalStrings(frame);
      return {expression:'(-'+evalStrings.expression+')', statements:evalStrings.statements};
    };
    node.toString = function () { return '-' + this.expression; };
    
});

var IdentifierNode = exports.IdentifierNode = P(ParseNode, function (node, _super) {
  node.init = function (identifier) {
    _super.init.call(this);
    identifier = identifier.replace('\\', ''); //TODO - want to verify this remapping
    identifier = identifier.replace('{', '');
    identifier = identifier.replace('}', '');
    this.identifier = identifier;
    this.addDependency(this.identifier, 0);
  };
  node.evaluateOnce = function (frame) {
    return frame.getVariable(this.identifier).evaluateOnce(frame);
  };
  node.getEvalStrings = function (frame) {
    return frame.getEvalStrings(this.identifier);
  };
  node.quadraticCoefficients = function (frame, variable) {
    if (variable === this.identifier) {
      return [0, 1, 0];
    }
    else{
      var tree = frame.getVariable(this.identifier);
      return tree.quadraticCoefficients(frame, variable);
    }
  };
  node.polynomialEvalStrings = function (frame, variable, arg) {
    if(variable === this.identifier) {
      return {statements:'', expressions:['0', '1']};
    }
    else if(arg === this.identifier) {
      return {statements:'', expressions:[this.identifier]};
    }
    else{
      var tree = frame.getVariable(this.identifier);
      return tree.polynomialEvalStrings(frame, variable, arg);
    }
  };
  node.polynomialOrder = function (frame, variable) {
    if(variable === this.identifier) return 1;
    if(!frame.hasVariable(this.identifier)) return 0;
    var tree = frame.getVariable(this.identifier);
    return tree.polynomialOrder(frame, variable);
  };
  node.okForImplicitFunction = function () {
    return true;
  };

  node.toString = function () {
    var m = this.identifier.match(/^([^_]+)(_(.*))?$/);
    var base = m[1];
    var subscript = m[3];

    if (base.length > 1) base = '\\' + base;
    if (!subscript) return base;
    return base + '_{' + subscript + '}';
  };
  
  node.statementType = IDENTIFIER;
});

exports.ChainedComparatorNode = P(ParseNode, function (node, _super) {
  node.init = function (comparators, args) {
    _super.init.call(this);
    if(!(comparators.length === 2 && args.length === 3)) throw "Can't chain more than 2 comparators";

    this.comparators = comparators;
    this.args = args;
    

    for (var i = 0; i  < 3; i++) {
      this.addDependencies(args[i].dependencies());
    }

    this.node1 = ComparatorNode(this.comparators[0], this.args[0], this.args[1]);
    this.node2 = ComparatorNode(this.comparators[1], this.args[1], this.args[2]);
  };

  node.evaluateOnce = function (frame) {
    return this.node1.evaluateOnce(frame) && this.node2.evaluateOnce(frame);
  };

  //TODO - stop double-evaluating middle value
  node.getEvalStrings = function (frame) {
    var s1 = this.node1.getEvalStrings(frame);
    var s2 = this.node2.getEvalStrings(frame);
    var statements = s1.statements + s2.statements;
    var expression =  "(" + s1.expression + "&&" + s2.expression + ")";
    return {expression:expression, statements:statements};
  };
  
  node.toString = function () {
    return [
      this.args[0],
      this.comparators[0],
      this.args[1],
      this.comparators[1],
      this.args[2]
    ].join(' ');
  };
  
  node.statementType = CHAINED_COMPARATOR;
});

var BinaryOperatorTable = {
  '+': 'arg1+arg2',
  '-': 'arg1-arg2',
  '*': 'arg1*arg2',
  '/': 'arg1/arg2',
  '>' : 'arg1>arg2',
  '<' : 'arg1<arg2',
  '>=': 'arg1>=arg2',
  '<=': 'arg1<=arg2',
  '===': 'arg1===arg2',
  '^': 'this.pow(arg1, arg2)' //Function not compiled from this text
};


var BinaryOperatorFunctionTable = {};
for (var operator in BinaryOperatorTable) {
  /*jshint evil:true*/
  if(BinaryOperatorTable.hasOwnProperty(operator)) {
    var fn;
    if(operator === '^')
      fn = BuiltIn.pow;
    else
      fn = new Function(['arg1', 'arg2'], 'return ' + BinaryOperatorTable[operator]);
    BinaryOperatorFunctionTable[operator] = fn;
  }
}

var BinaryOperatorNode = exports.BinaryOperatorNode = P(ParseNode, function (node, _super) {
  node.init = function (operator, x1, x2) {
    _super.init.call(this);
    this.args = [x1, x2];
    this.operator = operator;
    this.evaluator = BinaryOperatorFunctionTable[operator];
    this.addDependencies(this.args[0].dependencies());
    this.addDependencies(this.args[1].dependencies());
  };

  node.evaluateOnce = function (frame) {
    return this.evaluator(this.args[0].evaluateOnce(frame), this.args[1].evaluateOnce(frame));
  };

  node.getEvalStrings = function (frame) {
    var s0 = this.args[0].getEvalStrings(frame);
    var s1 = this.args[1].getEvalStrings(frame);
    var template = BinaryOperatorTable[this.operator];
    var expression = '(' +
      template.replace('arg1', s0.expression)
      .replace('arg2', s1.expression) +
    ')';
    var statements = s0.statements + s1.statements;
    return { expression: expression, statements: statements };
  };

  node.quadraticCoefficients = function (frame, variable) {
    var coeffs0 = this.args[0].quadraticCoefficients(frame, variable);
    var coeffs1 = this.args[1].quadraticCoefficients(frame, variable);

    switch(this.operator) {
    case '+':
      return [coeffs0[0] + coeffs1[0], coeffs0[1] + coeffs1[1], coeffs0[2] + coeffs1[2]];

    case '-':
      return [coeffs0[0] - coeffs1[0], coeffs0[1] - coeffs1[1], coeffs0[2] - coeffs1[2]];

    case '*':
      var new_coeffs = [0, 0, 0, 0, 0];
      for (var i = 0; i <= 2; i++) {
        for (var j = 0; j <= 2; j++) {
          new_coeffs[i+j] += coeffs0[i] * coeffs1[j];
        }
      }
      var invalid_coeffs = new_coeffs.splice(0, 2);  //invalid_coeffs gets first 2 coeffs.  Last 3 stay in new_coeffs.
      if (invalid_coeffs[0] !== 0 || invalid_coeffs[1] !== 0) return [NaN, NaN, NaN]; //throw "Greater than quadratic";
      return new_coeffs;

    case '/':
      if(coeffs1[0] !== 0 || coeffs1[1] !== 0) return [NaN, NaN, NaN]; //throw "Can't solve with x in the denominator";
      return [coeffs0[0] / coeffs1[2], coeffs0[1] / coeffs1[2], coeffs0[2] / coeffs1[2]];

    case '^':
      // Exponent can't depend on variable
      if(coeffs1[0] !== 0 || coeffs1[1] !== 0) return [NaN, NaN, NaN];//throw "Can't solve with x in the exponent";

      //If we don't depend on x, return [0, 0, evalOnce];
      if(coeffs0[0] === 0 && coeffs0[1] === 0) {
        return [0, 0, this.evaluator(coeffs0[2], coeffs1[2])]; //optimization for this.evaluateOnce(frame), since we already have our arguments.
      }
      
      //Otherwise, only return if exponent is small constant positive integer
      if (coeffs1[2] === 1) return coeffs0;
      if (coeffs1[2] === 2) {
        if(coeffs0[0] !== 0) return [NaN, NaN, NaN];//throw "Greater than quadratic";
        return [coeffs0[1] * coeffs0[1], 2 * coeffs0[1] * coeffs0[2], coeffs0[2] * coeffs0[2]];
      }
    }
    return [NaN, NaN, NaN];
  };

  node.polynomialEvalStrings = function (frame, variable, arg) {
    var coeffs0 = this.args[0].polynomialEvalStrings(frame, variable, arg);
    var coeffs1 = this.args[1].polynomialEvalStrings(frame, variable, arg);
    var order0 = coeffs0.expressions.length - 1;
    var order1 = coeffs1.expressions.length - 1;
    var statements = coeffs0.statements+coeffs1.statements;
    var expressions = [];
    var i, j, term;

    switch(this.operator) {
    case '+':
    case '-':
      for (i = 0; i <= Math.min(order0, order1); i++) {
        expressions[i] = '('+coeffs0.expressions[i]+this.operator+coeffs1.expressions[i]+')';
      }
      for (i = Math.min(order0, order1) + 1; i <= Math.max(order0, order1); i++) {
        if(this.operator === '+') {
          expressions[i] = (order0 > order1 ? coeffs0.expressions[i] : coeffs1.expressions[i]);
        }
        if(this.operator === '-') {
          expressions[i] = (order0 > order1 ? coeffs0.expressions[i] : '(-'+coeffs1.expressions[i]+')');
        }
      }
      return {statements: statements, expressions:expressions};

    case '*':
      for (i = 0; i <= order0; i++) {
        for (j = 0; j <= order1; j++) {
          term = '('+coeffs0.expressions[i]+'*'+coeffs1.expressions[j]+')';
          if(expressions[i+j] === undefined) {
            expressions[i+j] = term;
          }
          else{
            expressions[i+j] += '+'+term;
          }
        }
      }
      for (i = 0; i < expressions.length; i++) {
        expressions[i] = '(' + expressions[i] + ')';
      }
      return {statements:statements, expressions:expressions};
    case '/':
      if(order1 >= 1) throw "can't solve for variable in denominator";
      for (i=0; i <= order0; i++) {
        expressions[i] = '((' + coeffs0.expressions[i] + ')' + '/' + '(' + coeffs1.expressions[0] + '))';
      }
      return {statements:statements, expressions:expressions};
    case '^':
      if(order1 >= 1) throw "can't solve for variable in exponent";
      //Compute it if the base doesn't depend on the variable
      if(order0 === 0) return {statements:statements, expressions:['this.pow('+coeffs0.expressions[0]+','+coeffs1.expressions[0]+')']};
      //Only continue if the exponent is a small, constant, integer.  Figure this out with tree.evaluateOnce(frame).
      //If we can't evaluate, this will throw and solving will fail
      var exponent = this.args[1].evaluateOnce(frame);
      switch(exponent) {
      case 0:
        return {statements:'', expressions:['1']};
      case 1:
        return coeffs1;
      case 2:
        for (i = 0; i <= order0; i++) {
          for (j = 0; j <= order0; j++) {
            term = '('+coeffs0.expressions[i]+'*'+coeffs0.expressions[j]+')';
            if(expressions[i+j] === undefined) {
              expressions[i+j] = term;
            }
            else{
              expressions[i+j] += '+'+term;
            }
          }
        }
        for (i = 0; i < expressions.length; i++) {
          expressions[i] = '(' + expressions[i] + ')';
        }
        return {statements:statements, expressions:expressions};
      }
    }
    throw "Unable to compile polyomial representation of BinaryOperatorNode";
  };

  node.polynomialOrder = function (frame, variable) {
    var order0 = this.args[0].polynomialOrder(frame, variable);
    var order1 = this.args[1].polynomialOrder(frame, variable);
    switch(this.operator) {
    case '+':
    case '-':
      return Math.max(order0, order1);
    case '*':
      return order0 + order1;
    case '/':
      if (order1 > 0) return Infinity;
      return order0;
    case '^':
      if(order0 === 0 && order1 === 0) return 0;
      try{
        var exponent = this.args[1].evaluateOnce(frame);
        if (exponent !== Math.round(exponent)) return Infinity;
        if (exponent < 0) return Infinity;
        return exponent * order0;
      }
      catch(e) {
        return Infinity; //Exponent depends on free variables
      }
    }
    return Infinity;
  };

  node.okForImplicitFunction = function () {
    return this.args[0].okForImplicitFunction() && this.args[1].okForImplicitFunction();
  };

  var powString = function (base, exponent) {
    var baseString = base.toString();
    var exponentString = exponent.toString();
    if (base instanceof BinaryOperatorNode) {
      baseString = '(' + baseString + ')';
    }
    if (exponent instanceof BinaryOperatorNode) {
      exponentString = '{' + exponentString + '}';
    }
    return baseString + '^' + exponentString;
  };

  var timesString = function (arg1, arg2) {
    var s1 = String(arg1);
    var s2 = String(arg2);
    if (
      (
        arg1 instanceof BinaryOperatorNode &&
        (arg1.operator === '+' || arg1.operator === '-')
      ) ||
      arg1 instanceof NegationNode
    ) {
      s1 = '(' + s1 + ')';
    }
    if (
      (
        arg2 instanceof BinaryOperatorNode &&
        (arg2.operator === '+' || arg2.operator === '-')
      ) ||
      arg2 instanceof NegationNode
    ) {
      s2 = '(' + s2 + ')';
    }
    return s1 + '*' + s2;
  };

  node.toString = function () {
    if (this.operator === '^') return powString(this.args[0], this.args[1]);
    if (this.operator === '/') {
      return '\\frac{' + this.args[0] + '}{' + this.args[1] + '}';
    }
    if (this.operator === '*') return timesString(this.args[0], this.args[1]);
    return this.args[0] + ' ' + this.operator + ' ' + this.args[1];
  };

});

var ComparatorNode = exports.ComparatorNode = P(BinaryOperatorNode, function (node, _super) {
  node.init = function (operator, x1, x2) {
    _super.init.call(this, operator, x1, x2);
  };
  
  node.polynomialOrder = function (frame, variable) {
    var order0 = this.args[0].polynomialOrder(frame, variable);
    var order1 = this.args[1].polynomialOrder(frame, variable);
    return Math.max(order0, order1);
  };
  
  node.quadraticCoefficients = function (frame, variable) {
    return [NaN, NaN, NaN]; //TODO Not implemented
  };
  
  node.statementType = COMPARATOR;
  
});

var FunctionNode = exports.FunctionNode = P(ParseNode, function (node, _super) {
  node.init = function (identifier, args) {
    _super.init.call(this);
    this.identifier = identifier;
    this.args = args;
    this.arity = this.args.length;
    this.addDependency(this.identifier.identifier, this.arity);
    for (var i = 0; i < args.length; i++) {
      this.addDependencies(args[i].dependencies());
    }
  };

  node.evaluateOnce = function (frame) {
    if(this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
      return frame.callFunction(this.identifier.identifier,
                                this.args.map(function (arg) {return arg.evaluateOnce(frame)}));
    }
    //We don't have a function.  This could be implicit multiplication instead.
    if(this.args.length === 1 && frame.hasVariable(this.identifier.identifier)) {
      return this.args[0].evaluateOnce(frame) * frame.getVariable(this.identifier.identifier).evaluateOnce(frame);
    }
  };

  node.getEvalStrings = function (frame) {
    if(this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
      var arg_eval_strings = this.args.map(function (a) {return a.getEvalStrings(frame)});
      var arg_expressions = arg_eval_strings.map(function (a) {return a.expression});
      var arg_statements = arg_eval_strings.map(function (a) {return a.statements});
      var statements = arg_statements.join('');
      var expression = 'this.'+this.identifier.identifier + '(' + arg_expressions.join(',') + ')';
      return {expression:expression, statements:statements};
    }
    else{
      var variable_node = IdentifierNode(this.identifier.identifier);
      var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
      return multiplication_node.getEvalStrings(frame);
    }
  };

  node.quadraticCoefficients = function (frame, variable) {
    if(this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
      /*Find polynomial order for each function argument*/
      var arg_orders = this.args.map(function (a) {return a.polynomialOrder(frame, variable)});
      var max_order = Math.max.apply(null, arg_orders);

      //Return static value if no arguments depend on X
      if(max_order === 0) {
        return [0, 0, this.evaluateOnce(frame)];
      }

      //Return infinity if arguments depend on X, and can't be analyzed
      var fn = frame.getFunctionTree(this.identifier.identifier);
      if(!fn) throw ("Can't solve equations with " + this.identifier.identifier);

      //Create local frame and ask function expression for polynomial order
      var local_frame = EvalFrame(frame);
      for (var i = 0; i < fn.arity; i++) {
        local_frame.setVariable(fn.args[i].identifier, this.args[i]);
      }
      return fn.expression.quadraticCoefficients(local_frame, variable);
    }
    else{ //Implicit multiplication
      var variable_node = IdentifierNode(this.identifier.identifier);
      var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
      return multiplication_node.quadraticCoefficients(frame, variable);
    }
  };

  node.polynomialEvalStrings = function (frame, variable, arg) {
    if(this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
      var arg_strings = this.args.map(function (a) {return a.polynomialEvalStrings(frame, variable, arg)});
      var arg_orders = arg_strings.map(function (x) {return x.expressions.length - 1;});
      var max_order = Math.max.apply(null, arg_orders);

      if(max_order === 0) {
        var eval_strings = this.getEvalStrings(frame);
        return {statements:eval_strings.statements, expressions:[eval_strings.expression]};
      }
      //If order is infinity, this shouldn't get called?
      //TODO - deal wih "create local frame" logic from polynomialOrder
    }
    else{ //Implicit multiplication
      var variable_node = IdentifierNode(this.identifier.identifier);
      var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
      return multiplication_node.polynomialEvalStrings(frame, variable, arg);
    }
  };

  node.polynomialOrder = function (frame, variable) {
    if(this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
      /*Find polynomial order for each function argument*/
      var arg_orders = this.args.map(function (a) {return a.polynomialOrder(frame, variable)});
      var max_order = Math.max.apply(null, arg_orders);

      //Return 0 if no arguments depend on X
      if(max_order === 0) {
        return 0;
      }

      return Infinity; //TODO - analyze order of function calls that depend on X
    }
    else{ //Implicit multiplication
      var variable_node = IdentifierNode(this.identifier.identifier);
      var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
      return multiplication_node.polynomialOrder(frame, variable);
    }
  };

  node.toString = function () {
    if (this.identifier.identifier === 'sqrt') {
      return this.identifier + '{' + this.args[0] + '}';
    }
    return this.identifier + '(' + this.args.join(', ') + ')';
  };
});

exports.FunctionCallExponentNode = P(ParseNode, function (node, _super) {
  node.init = function (identifier, arg, exponent) {
    _super.init.call(this);
    this.identifier = identifier;
    this.arg = arg;
    this.exponent = exponent;
    this.as_function_node = BinaryOperatorNode('^', FunctionNode(this.identifier, [this.arg]), this.exponent);
    this.as_multiplication_node = BinaryOperatorNode('*', this.identifier, BinaryOperatorNode('^', this.arg, this.exponent));

    this.addDependency(this.identifier.identifier, 1);  //Ambiguous (see note in addDependency)
    this.addDependencies(this.arg.dependencies());
    this.addDependencies(this.exponent.dependencies());
  };

  node.getEquivalentNode = function (frame) {
    if(frame.hasFunction(this.identifier.identifier)) return this.as_function_node;
    return this.as_multiplication_node;
  };

  node.evaluateOnce = function (frame) {
    return this.getEquivalentNode(frame).evaluateOnce(frame);
  };

  node.getEvalStrings = function (frame) {
    return this.getEquivalentNode(frame).getEvalStrings(frame);
  };

  node.polynomialOrder = function (frame, variable) {
    return this.getEquivalentNode(frame).polynomialOrder(frame, variable);
  };

  node.quadraticCoefficients = function (frame, variable) {
    return this.getEquivalentNode(frame).quadraticCoefficients(frame, variable);
  };

  node.polynomialEvalStrings = function (frame, variable, arg) {
    return this.getEquivalentNode(frame).polynomialEvalStrings(frame, variable, arg);
  };

  node.toString = function () {
    return this.as_function_node.toString();
  };
});

exports.FunctionDeclarationNode = P(ParseNode, function (node, _super) {
  node.init = function (identifier, args, expression) {
    _super.init.call(this);
    this.assigns = identifier;
    this.referenceSymbol(this.assigns.identifier);
    this.args = args;
    this.arity = this.args.length;
    this.expression = expression;
    this.passed_variables = this.args.map(function (arg) {return arg.identifier});
    var possible_dependencies = this.expression.dependencies();
    for (var id in possible_dependencies) {
      if(!possible_dependencies.hasOwnProperty(id)) {continue;}

      var arity = possible_dependencies[id];
      if(this.passed_variables.indexOf(id) >= 0) {
        //Identifier is shadowed by arguments.  Make sure it's ok being a variable
        if(arity > 1) {throw("Cannot call argument " + id + " as a function")}
        //Otherwise, don't need to do anything.  It's shadowed, so it's not a dependency
      }
      else{
        //Not shadowed - becomes a dependency
        this.addDependency(id, arity);
      }
    }
  };
  node.statementType = FUNCTION_DEFINITION;
  node.exportDefinitionsTo = function (frame, compiler) {
    var self = this;
    /*
    frame.setFunction(self.assigns.identifier, self.args.length, function (args, f) {
        var shadow_frame = EvalFrame(frame)
        for (var i = 0; i < self.args.length; i++) {
          shadow_frame.setVariable(self.args[i].identifier, ConstantNode(args[i]));
        }
        return self.expression.evaluateOnce(shadow_frame);
      });
    */
    var evalStrings = self.expression.getEvalStrings(frame);
    var function_source = evalStrings.statements + "return " + evalStrings.expression;
    var function_args = self.args.map(function (a) {return a.identifier});
    var fn = compiler.compile(function_args, function_source);
    frame.setFunction(self.assigns.identifier, self.args.length, fn, self, function_args, function_source);
  };

  node.passedVariables = function () {
    return this.passed_variables; //TODO - deleteme
  };

  node.evaluateOnce = function (frame) {
    return "Defines function " + this.assigns.identifier;
  };

  node.getEvalStrings = function (frame) {
    return this.expression.getEvalStrings(frame);
  };

  node.toString = function () {
    return this.assigns + '\\left(' + this.args.join(', ') + '\\right)' +
      ' = ' + this.expression;
  };
});

var DerivativeNode = exports.DerivativeNode = P(ParseNode, function (node, _super) {
  node.init = function (variable, expression) {
    _super.init.call(this);
    this.derivative_variable = variable;
    this.expression = expression;
    this.addDependencies(expression.dependencies());
    this.addDependency(variable.identifier, 0);
  };

  node.evaluateOnce = function (frame) {
    var variable = this.derivative_variable;
    var dtree = this.expression.takeDerivative(frame, variable);

    if (!(dtree instanceof DerivativeNode)) {
      return dtree.evaluateOnce(frame);
    }

    var center_point = frame.getVariable(variable.identifier).evaluateOnce(frame);
    var local_frame = EvalFrame(frame);
    var epsilon = 5e-5;

    //Evaluate slightly below
    local_frame.setVariable(variable.identifier, ConstantNode(center_point - epsilon));
    var val0 = this.expression.evaluateOnce(local_frame);
    //Evaluate slightly above
    local_frame.setVariable(variable.identifier, ConstantNode(center_point + epsilon));
    var val1 = this.expression.evaluateOnce(local_frame);
    //Divide by dx and return
    return (val1 - val0) / (2 * epsilon);
  };

  node.getEvalStrings = function (frame) {
    var variable = this.derivative_variable;
    var dtree = this.expression.takeDerivative(frame, variable);

    if (!(dtree instanceof DerivativeNode)) {
      return dtree.getEvalStrings(frame);
    }

    var derivative = this.tmp();
    var variable_value = this.tmp();
    var epsilon = '(5e-5)';
    var high_value = this.tmp();
    var low_value = this.tmp();

    //Get and store value of the differentiation variable
    var variable_value_strings = variable.getEvalStrings(frame);
    var initialize = variable_value_strings.statements + 'var '+variable_value+'='+variable_value_strings.expression+';';

    //Compile expression
    var expression_strings = this.expression.getEvalStrings(frame);

    var sample_low  = variable.identifier+'='+variable_value+'-'+epsilon+';'+
                      expression_strings.statements+
                      'var '+low_value+'='+expression_strings.expression+';';

    var sample_high = variable.identifier+'='+variable_value+'+'+epsilon+';'+
                      expression_strings.statements+
                      'var '+high_value+'='+expression_strings.expression+';';

    //Compute the derivative from that
    var divide = 'var '+derivative+'=('+high_value+'-'+low_value+')/(2*'+epsilon+');';

    //Reset the value of the initial variable, in case someone was using it
    var cleanup = variable.identifier+'='+variable_value+';';

    var statements = initialize + sample_low + sample_high + divide + cleanup;
    return {expression:derivative, statements:statements};
  };

  node.toString = function () {
    return '\\frac{d}{d' + this.derivative_variable +  '}' +
      '\\left(' + this.expression + '\\right)';
  };
});

var RepeatedOperatorNode = exports.RepeatedOperatorNode = P(ParseNode, function (node, _super) {
  node.init = function (index, lower_bound, upper_bound, summand) {
    _super.init.call(this);
    this.index = index;
    this.lower_bound = lower_bound;
    this.upper_bound = upper_bound;
    this.summand = summand;
    this.addDependencies(this.lower_bound.dependencies());
    this.addDependencies(this.upper_bound.dependencies());
    this.addDependencies(this.summand.dependencies());
    this.shadowVariable(this.index.identifier); //TODO - make sure we're tracking this the same we we track assignments
  };

  node.evaluateOnce = function (frame) {
    var local_frame = EvalFrame(frame);
    var lower = Math.round(this.lower_bound.evaluateOnce(frame));
    var upper = Math.round(this.upper_bound.evaluateOnce(frame));
    var total = this.starting_value;
    if(!isFinite(upper - lower)) {
      total = (upper < lower ? this.starting_value : NaN);
    }
    else{
      for (var i = lower; i <= upper; i++) {
        local_frame.setVariable(this.index.identifier, ConstantNode(i));
        total = this.fn(total, this.summand.evaluateOnce(local_frame)); //Addition or multiplication
      }
    }
    return total;
  };

  node.getEvalStrings = function (frame) {
    var sum = this.tmp();
    var index = this.index.identifier;
    var lower_bound = this.tmp();
    var upper_bound = this.tmp();

    var lower_bound_strings = this.lower_bound.getEvalStrings(frame);
    var upper_bound_strings = this.upper_bound.getEvalStrings(frame);
    var summand_strings = this.summand.getEvalStrings(frame);

    var set_lower_bound = lower_bound_strings.statements + 'var '+lower_bound+' = Math.round(' + lower_bound_strings.expression + ');';
    var set_upper_bound = upper_bound_strings.statements + 'var '+upper_bound+' = Math.round(' + upper_bound_strings.expression + ');';
    var initialize_sum = 'var '+sum+'='+this.starting_value+';';
    var loop = 'for (var '+index+'='+lower_bound+';'+index+'<='+upper_bound+';'+index+'++) {'+summand_strings.statements+sum+this.in_place_operator+summand_strings.expression+'};';
   
    var protected_loop = 'if(!isFinite('+upper_bound+'-'+lower_bound+')) {'+sum+'=('+upper_bound+'<'+lower_bound+'?'+this.starting_value+':NaN);}else{'+loop+'}';

    return {expression:sum, statements:set_lower_bound + set_upper_bound + initialize_sum + protected_loop};
  };

});

exports.SummationNode = P(RepeatedOperatorNode, function (node, _super) {
  node.init = function (index, lower_bound, upper_bound, summand) {
    _super.init.call(this, index, lower_bound, upper_bound, summand);
  };

  node.starting_value = 0;
  node.in_place_operator = '+=';
  node.fn = function (a, b) {return a + b;};
  
  node.toString = function () {
    return '\\sum_{' + this.index + '=' + this.lower_bound + '}' +
      '^{' + this.upper_bound + '} ' + this.summand;
  };
});

exports.ProductNode = P(RepeatedOperatorNode, function (node, _super) {
  node.init = function (index, lower_bound, upper_bound, summand) {
    _super.init.call(this, index, lower_bound, upper_bound, summand);
  };

  node.starting_value = 1;
  node.in_place_operator = '*=';
  node.fn = function (a, b) {return a * b;};
  
  node.toString = function () {
    return '\\prod_{' + this.index + '=' + this.lower_bound + '}' +
      '^{' + this.upper_bound + '} ' + this.summand;
  };
});

exports.OrderedPairListNode = P(ParseNode, function (node, _super) {
  node.init = function (elements) {
    _super.init.call(this);
    this.elements = elements;

    for (var i = 0; i < elements.length; i++) {
      this.addDependencies(elements[i].dependencies());
    }
  };

  node.evaluateOnce = function (frame) {
    return this.elements.map(function (x) {return x.evaluateOnce(frame)});
  };

  node.getEvalStrings = function (frame) {
    var statements = '';
    var expression = '[';
    for (var i = 0; i < this.elements.length; i++) {
      var element_strings = this.elements[i].getEvalStrings(frame);
      statements += element_strings.statements;
      expression += element_strings.expression;
      if(i < this.elements.length - 1) this.expression += ',';
    }
    expression += ']';
    return {statements: statements, expression:expression};
  };

  node.toString = function () {
    return '\\left(' + this.elements.join(', ') + '\\right)';
  };

  node.statementType = ORDERED_PAIR_LIST;
});

//Copy all ParseNodes from exports onto yy.latex
for (var node in exports) {
  if(exports.hasOwnProperty(node)) latex.yy[node] = exports[node];
}

/* This function takes the entire function declaration as a single lexed token and parses with a regexp,
 * to keep the overall grammar context-free and LALR(1)-parseable.
 * TODO - generate this once, not every time we parse a function declaration */
latex.yy.parseFunctionDeclaration = function (declaration_string) {
  declaration_string = declaration_string.replace('###', '');  //Strip off start-of-line marker
  var whitespace_pattern =  //Non-capturing latex whitespace pattern
     "(?:\\s|\\\\space|\\\\\\:)*";
     //   \s   \\space  \\ \ :
  var id_body_pattern = //Non-capturing latex identifier pattern
     "(?:[a-zA-Z]|\\\\[a-zA-Z]+)";
  var id_subscript_pattern = //Non-capturing latex subscript pattern
     "(?:_[a-zA-Z0-9]|_{[a-zA-Z0-9]+})?";
  var id_pattern = id_body_pattern+id_subscript_pattern;

  var arglist_pattern = //Non-capturing comma-separated list of identifiers in whitespace-free string
    "(?:" + id_pattern + "(?:\\," + id_pattern + ")*)";

  var declaration_pattern = //Captures function name as first group, and arglist as second group
    "(" + id_pattern + ")" + "(?:\\\\left)?\\((" + arglist_pattern + ")(?:\\\\right)?\\)=";

  var declaration_regexp = new RegExp(declaration_pattern);
  var whitespace_regexp = new RegExp(whitespace_pattern, "g"); //Want "g" flag to ensure global capturing of whitespace
  declaration_string = declaration_string.replace(whitespace_regexp, '');
  var match = declaration_regexp.exec(declaration_string);

  return {
    identifier: IdentifierNode(match[1]),
    args: match[2].split(',').map(IdentifierNode), //match[1] is the argument list.  Split it on commas, and create an IdentifierNode from each one
    input_string: declaration_string.split('=')[0]        //input_string is used for constructing function tables.  We want to strip the equality off the end
  };
};

//This code over-rides latex.parse with a version that prepends a line-start marker
exports.parse = function (input) {
  return latex.parse("###"+input);
};

exports.tryParse = function (input) {
  try{
    var tree = exports.parse(input);
    return tree;
  }
  catch(e) {
    return ErrorNode(e);
  }
};

latex.yy.setInput = function (node, range) {
  node.setInputString(latex.yy.lexer.matched.slice(Math.max(3, range.first_column), range.last_column)); //Don't ever show the '###' mark we insert to mark the start of the string
};

latex.yy.parseError = function (err, hash) {
  throw("Sorry - I don't understand this");
};

return exports;
});

define('math/quadratic',['require'],function(require){

var Quadratic = {
  formula: function(coeffs, rootNumber){
    if (coeffs.length != 3) throw 'Where did you learn the quadratic formula?';
    var a = coeffs[0];
    var b = coeffs[1];
    var c = coeffs[2];

    if(a === 0){
      return [-c/b, -c/b];  //Linear case
    }

    var radical = Math.sqrt(b * b - 4 * a * c);
    var root0 = (-b + radical) / (2 * a);
    var root1 = (-b - radical) / (2 * a);

    //Optional argument rootNumber specifies which root to return.  If not specified, returns list of all roots
    if(rootNumber === 0) return root0;
    if(rootNumber === 1) return root1;
    return [root0, root1];
  },

  // For a quadratic inequality of the form a*x^2 + b*x + c > 0, returns
  // regions for which the inequality is satisfied in the form [ lower, mid0,
  // mid1, upper ]. The inequality is satisfied for:
  //
  //   x < lower ||
  //   (x > mid0 && x < mid1) ||
  //   x > upper
  //
  // Values can be NaN to signal that no inequality of the given type is
  // satisfied. At least two of the return values will always be NaN.
  inequalityRegions: function (coeffs) {
    // Would ideally like large === Infinity, but it's convenient to feed
    // these results through the line coalescing/jump detection/poi finding
    // pipeline, and none of that is set up to deal with Infinity correctly.
    var large = 1e305;

    var a = coeffs[0];
    var b = coeffs[1];
    var c = coeffs[2];

    if (a === 0 && b === 0) {
      return (c > 0) ?
        [ NaN, -large, large, NaN ] :
        [ NaN, NaN, NaN, NaN ]
      ;
    }
    if (a === 0) {
      return (b > 0) ?
        [ NaN, NaN, NaN, -c/b ] :
        [ -c/b, NaN, NaN, NaN ]
      ;
    }
    var discriminant = Math.sqrt(b*b - 4*a*c);
    if (!isFinite(discriminant)) {
      return (a > 0) ?
        [ NaN, -large, large, NaN ] :
        [ NaN, NaN, NaN, NaN ];
  
    }
    var upper = (-b + discriminant)/(2*a);
    var lower = (-b - discriminant)/(2*a);
    return (a > 0) ?
      [ lower, NaN, NaN, upper ] :
      [ NaN, upper, lower, NaN ] // upper/lower switched because a < 0
    ;
  },

  formulaEvalStrings: function(strings){
    var function_1, function_2;
    switch(strings.expressions.length){
    case 2:
      function_1 = strings.statements + 'return ' + '-' +strings.expressions[0] + '/' + strings.expressions[1];
      return [function_1];
    case 3:
      var statements =
        strings.statements +
        'var coeffs = [' + strings.expressions[2] + ',' +
                           strings.expressions[1] + ',' +
                           strings.expressions[0] + '];';
      function_1 = statements + 'return this.quadraticFormula(coeffs, 0);';
      function_2 = statements + 'return this.quadraticFormula(coeffs, 1);';
      return [function_1, function_2];
    }
  },

  inequalityRegionEvalStrings: function (strings) {
    // Prepend zeros onto coefficient strings that are too short.
    var expressions = strings.expressions.slice();
    while (expressions.length < 3) expressions.push('0');
    
    var statements = strings.statements +
      'var coeffs = [' + expressions[2] + ',' +
                         expressions[1] + ',' +
                         expressions[0] + '];';
    // TODO, send in correct operator
    return [
      statements + 'return this.quadraticInequalityRegions(coeffs)[0]',
      statements + 'return this.quadraticInequalityRegions(coeffs)[1]',
      statements + 'return this.quadraticInequalityRegions(coeffs)[2]',
      statements + 'return this.quadraticInequalityRegions(coeffs)[3]'
    ];
  }
};

return Quadratic;
});

//Definition of built-in functions and variables

define('math/builtinframe',['require','./builtin','./evalframe','./parser_util','./inverses','math/quadratic'],function(require){
  var BuiltIn = require('./builtin');
  var EvalFrame = require('./evalframe');
  var Parser = require('./parser_util');
  var inverses = require('./inverses');
  var Quadratic = require('math/quadratic');

  var ConstantNode = Parser.ConstantNode;

  var frame = EvalFrame();

  frame.setVariable('pi', ConstantNode(Math.PI));
  frame.setEvalStrings('pi', {expression:String(Math.PI), statements:''});
  frame.setVariable('tau', ConstantNode(2*Math.PI));
  frame.setEvalStrings('tau', {expression:String(2*Math.PI), statements:''});
  frame.setVariable('e', ConstantNode(Math.E));
  frame.setEvalStrings('e', {expression:String(Math.E), statements:''});

  // angleMultiplier function is defined for use in trig derivatives. It would
  // be nice to just make this a constant, but making it a function allows us
  // to avoid the possibility of conflicting with a user symbol. We don't have
  // arity 0 functions, so make it an arity 1 function that ignores its 
  // argument.
  frame.setDegreeMode = function (on) {
    frame._angleMultiplier = (on ? Math.PI/180 : 1);
  };

  frame.setDegreeMode(false);

  frame.setFunction('angleMultiplier', 1, function () {
    return frame._angleMultiplier;
  });

  //Trig functions
  //
  //Helper function
  var registerTrig = function(name, fn, fn_inverse) {
    frame.setFunction(name, 1, function (x) {
      return fn(x*frame._angleMultiplier);
    });
    frame.setFunction(inverses[name], 1, function (x) {
      return fn_inverse(x)/frame._angleMultiplier;
    });
  };
  //Use helper to register forward and inverse
  registerTrig('sin', BuiltIn.sin, Math.asin);
  registerTrig('cos', BuiltIn.cos, Math.acos);
  registerTrig('tan', BuiltIn.tan, Math.atan);
  registerTrig('cot', BuiltIn.cot, BuiltIn.acot);
  registerTrig('sec', BuiltIn.sec, BuiltIn.asec);
  registerTrig('csc', BuiltIn.csc, BuiltIn.acsc);

  //Hyperbolic trig functions
  //
  //Helper function
  var registerHyperbolicTrig = function(name, fn, fn_inverse){
    frame.setFunction(name, 1, fn);
    frame.setFunction(inverses[name], 1, fn_inverse);
  };
  //Use helper to register forward and inverse
  registerHyperbolicTrig('sinh', BuiltIn.sinh, BuiltIn.asinh);
  registerHyperbolicTrig('cosh', BuiltIn.cosh, BuiltIn.acosh);
  registerHyperbolicTrig('tanh', BuiltIn.tanh, BuiltIn.atanh);
  registerHyperbolicTrig('coth', BuiltIn.coth, BuiltIn.acoth);
  registerHyperbolicTrig('sech', BuiltIn.sech, BuiltIn.asech);
  registerHyperbolicTrig('csch', BuiltIn.csch, BuiltIn.acsch);

  frame.setFunction('pow', 2, BuiltIn.pow);
  frame.setFunction('sqrt', 1, Math.sqrt);
  frame.setFunction('nthroot', 2, BuiltIn.nthroot);
  frame.setFunction('log', 2, BuiltIn.log_base);
  frame.setFunction('exp', 1, Math.exp);
 
  frame.setFunction('floor', 1, Math.floor);
  frame.setFunction('ceil', 1, Math.ceil);
  frame.setFunction('round', 1, Math.round);
  frame.setFunction('abs', 1, Math.abs);
  frame.setFunction('mod', 2, BuiltIn.mod);
  frame.setFunction('max', 2, BuiltIn.max);
  frame.setFunction('min', 2, BuiltIn.min);
  frame.setFunction('sign', 1, BuiltIn.sign);

  frame.setFunction('lcm', 2, BuiltIn.lcm);
  frame.setFunction('gcd', 2, BuiltIn.gcd);

  frame.setFunction('nCr', 2, BuiltIn.nCr);
  frame.setFunction('nPr', 2, BuiltIn.nPr);
  frame.setFunction('factorial', 1, BuiltIn.factorial);
  frame.setFunction('polyGamma', 2, BuiltIn.polyGamma);

  frame.setFunction('quadraticFormula', 2, Quadratic.formula);
  frame.setFunction('quadraticInequalityRegions', 1, Quadratic.inequalityRegions);

  return frame;
});

define('numeric',[],function () {


var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.precision = 4;
numeric.largeArray = 50;

// Wrapper around `new Function` that closures in the `numeric` object.
numeric.compile = function () {
  var args = Array.prototype.slice.call(arguments);
  var body = args.pop();
  body = 'return function (' + args.join(',') + ') {' + body + ';}';
  return (new Function(['numeric'], body))(numeric);
}

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return numeric.compile('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return numeric.compile('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return numeric.compile.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return numeric.compile.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = numeric.compile('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = numeric.compile('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = numeric.compile('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return numeric.compile(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return numeric.compile(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return numeric.compile('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = numeric.compile('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sébastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};

return numeric;

});
// Helper functions for computing distance.
//
// The name of this should probably be changed, once we learn what other
// kinds of things we're including here.

define('math/distance',['require','math/builtin','numeric'],function (require) {
  var Builtin = require('math/builtin');
  var Numeric = require('numeric');

  var Distance = {
    // sqrt(x^2 + y^2), computed to avoid overflow and underflow.
    // http://en.wikipedia.org/wiki/Hypot
    hypot: function(x, y) {
      if(x === 0 && y === 0) {
        return 0;
      }
      if (Math.abs(x) > Math.abs(y)) {
        return Math.abs(x) * Math.sqrt((y/x) * (y/x) + 1);
      } else {
        return Math.abs(y) * Math.sqrt((x/y) * (x/y) + 1);
      }
    },

    // (x1 + x2)/2, computed to avoid overflow.
    mean: function (x1, x2) {
      return ((x1 > 0) === (x2 > 0)) ? x1 + 0.5*(x2 - x1) : 0.5*(x1 + x2);
    },

    dot: function(x1, y1, x2, y2) {
      return x1*x2 + y1*y2;
    },

    // Consider the line extending the segment, parameterized as
    // v1 + t (v2 - v1), where p, v1, and v2 are (xp, yp), (x1, y1), and
    // (x2, y2) respectively.
    //
    // Return the value of the parameter t for the projected point of p onto
    // the line through the segment.
    //
    // It falls where t = [(p-v) . (w-v)] / |w-v|^2
    //
    // Returns 0 in the degenerate case where v1 === v2.
    pointToSegmentParameter: function(xp, yp, x1, y1, x2, y2) {
      var line_length = this.hypot(x2 - x1, y2 - y1);

      // Degenerate case of a point to a point
      if (line_length === 0) return 0;

      var t = this.dot(
        (xp - x1)/line_length,
        (yp - y1)/line_length,
        (x2 - x1)/line_length,
        (y2 - y1)/line_length
      );

      return t;
    },

    closestPointOnSegment: function (xp, yp, x1, y1, x2, y2) {
      var t = this.pointToSegmentParameter(xp, yp, x1, y1, x2, y2);
      
      if (t <= 0) return [x1, y1];
      if (t >= 1) return [x2, y2];
      return [x1 + t*(x2 - x1), y1 + t*(y2 - y1)];
    },

    // Shortest distance from a point to a line segment
    // http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
    pointToSegment: function (xp, yp, x1, y1, x2, y2) {
      var p = this.closestPointOnSegment(xp, yp, x1, y1, x2, y2);
      return this.hypot(xp - p[0], yp - p[1]);
    },

    // (Near) 0 if x3, y3 lies on the line from x1, y1 to x2, y2.
    // Positive if x3, y3 is on the left of the line, so that the points form a
    // triangle with clockwise orientation.
    isLine: function (x1, y1, x2, y2, x3, y3) {
      var S = Numeric.svd([
        [x1, y1, 1],
        [x2, y2, 1],
        [x3, y3, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    isCircle: function (x1, y1, x2, y2, x3, y3, x4, y4) {
      var S = Numeric.svd([
        [x1*x1 + y1*y1, x1, y1, 1],
        [x2*x2 + y2*y2, x2, y2, 1],
        [x3*x3 + y3*y3, x3, y3, 1],
        [x4*x4 + y4*y4, x4, y4, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    // (Near) 0 if x6, y6 lies on the conic defined by the first five points.
    // I don't quite know how to interpret the sign for a general conic.
    isConic: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
      var S =  Numeric.svd([
        [x1*x1, y1*y1, 2*x1*y1, x1, y1, 1],
        [x2*x2, y2*y2, 2*x2*y2, x2, y2, 1],
        [x3*x3, y3*y3, 2*x3*y3, x3, y3, 1],
        [x4*x4, y4*y4, 2*x4*y4, x4, y4, 1],
        [x5*x5, y5*y5, 2*x5*y5, x5, y5, 1],
        [x6*x6, y6*y6, 2*x6*y6, x6, y6, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    conicQuadraticParameters: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5) {
      return {
        a: Numeric.det([
          [y1*y1, 2*x1*y1, x1, y1, 1],
          [y2*y2, 2*x2*y2, x2, y2, 1],
          [y3*y3, 2*x3*y3, x3, y3, 1],
          [y4*y4, 2*x4*y4, x4, y4, 1],
          [y5*y5, 2*x5*y5, x5, y5, 1]
        ]),

        b: Numeric.det([
          [x1*x1, y1*y1, x1, y1, 1],
          [x2*x2, y2*y2, x2, y2, 1],
          [x3*x3, y3*y3, x3, y3, 1],
          [x4*x4, y4*y4, x4, y4, 1],
          [x5*x5, y5*y5, x5, y5, 1]
        ]),

        c: -Numeric.det([
          [x1*x1, 2*x1*y1, x1, y1, 1],
          [x2*x2, 2*x2*y2, x2, y2, 1],
          [x3*x3, 2*x3*y3, x3, y3, 1],
          [x4*x4, 2*x4*y4, x4, y4, 1],
          [x5*x5, 2*x5*y5, x5, y5, 1]
        ])
      };
    },

    // Classify a set of 6 points as line, circle, parabola, hyperbola, ellipse, or none for not a conic.
    classifyConic: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
      if (Distance.isLine(x1, y1, x3, y3, x6, y6)) return 'line';
      if (Distance.isCircle(x1, y1, x2, y2, x5, y5, x6, y6)) return 'circle';
      if (!Distance.isConic(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6)) return 'none';
      
      var p = Distance.conicQuadraticParameters(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5);
      var S = Numeric.svd([[p.a, p.b], [p.b, p.c]]).S;

      if (Builtin.approx(S[S.length - 1]/S[0], 0, 20)) return 'parabola';
      return (p.b*p.b > p.a*p.c) ? 'hyperbola' : 'ellipse';

    }
  };

  return Distance;
});

// Utilites for finding and refining points of interest in samled functions.
//
// bisect* are low level functions take endpoints and a function, and return
// a single [x, f(x)] pair, where f is the function that was passed in, or
// null if a non-finite value of the function is encountered during
// evaluation. These methods have preconditions on the endpoints that callers
// are expected to enforce (because they are called recursively). They bisect
// to machine precision.
//
// find* are higher level. They take an array of segments and a function.
// Each segment is an array of points representing a polyline that
// approximates the function over a range where the function is expected to be
// continuous. No more than one zero and one extremum will be returned between
// individual point pairs in the segments list.
//
// findPOIs collects the results of all the find* methods together.


define('math/poi',['require','./builtin','./distance'],function(require){
  var BuiltIn = require('./builtin');
  var Distance = require('./distance');

// floatMiddle is a helper function for bisecting floats. Necessary because
// floats are denser near 0 than they are elsewhere, so using a normal mean
// results in slow bisection to 0.
//
// This function returns the arithmetic mean if both numbers have
// magnitude larger than 1e-2, 0 if the numbers are small and have opposite
// signs, and the signed geometric mean if the numbers have the same sign. The
// geometric mean bisects the exponent instead of the mantissa, which is what
// we want near 0.

function floatMiddle(a, b) {
  var tmp;
  if (a > b) {
    tmp = a; a = b; b = tmp;
  }
  var aPos = a > 0;
  var bPos = b > 0;
  var aLarge = Math.abs(a) > 1e-2;
  var bLarge = Math.abs(b) > 1e-2;
  if (aLarge || bLarge) return Distance.mean(a, b);
  if (a === 0) return b*Math.abs(b);
  if (b === 0) return a*Math.abs(a);
  if (aPos !== bPos) return 0;
  var gMean = (aPos) ? Math.sqrt(a*b) : -Math.sqrt(a*b);
  // Check if the geometric mean actually lies between the numbers (it might
  // not because of floating point rounding). If it does not, return the
  // normal mean, which is computed in a way that guarantees it will be
  // between the inputs.
  return ((gMean >= a) && (b >= gMean)) ? gMean : Distance.mean(a, b);
}

function bisectZero(x0, y0, x2, y2, fn) {
  // Preconditions:
  // 1. y0 and y2 are finite and non-zero and have opposite sign
  if (!(isFinite(y0) && isFinite(y2) && (y0 < 0) !== (y2 < 0))) {
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    
    if (!isFinite(y1)) return null;

    // We can't bisect any further; return x for side with y closer to 0.
    if (x1 === x0 || x1 === x2) {
      return Math.abs(y0) <= Math.abs(y2) ? [x0, y0] : [x2, y2];
    }

    // Found a 0 early. Check if we're on a flat, and return the center of it.
    if (y1 === 0) return flatCenter(x0, y0, x1, y1, x2, y2, fn);

    // Bisect on side that brackets zero
    if ((y0 < 0) !== (y1 < 0)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

// Returns the center of a possibly flat region with constant value y1
function flatCenter(x0, y0, x1, y1, x2, y2, fn) {
  // Preconditions:
  // 1. x0 < x1 < x2

  var edge;
  if (!isFinite(y1)) return;

  if (!isFinite(y0)) {
    edge = bisectFinite(x0, y0, x1, y1, fn);
    x0 = edge[0];
    y0 = edge[1];
  }

  if (!isFinite(y2)) {
    edge = bisectFinite(x1, y1, x2, y2, fn);
    x2 = edge[0];
    y2 = edge[1];
  }

  var flatLeft, flatRight;

  if (y0 === y1) {
    flatLeft = [x0, y0];
  } else {
    flatLeft = bisectConstant(x0, y0, x1, y1, fn, y1);
  }
  
  if (y2 === y1) {
    flatRight = [x2, y2];
  } else {
    flatRight = bisectConstant(x1, y1, x2, y2, fn, y1);
  }

  var xc = floatMiddle(flatLeft[0], flatRight[0]);
  return [xc, fn(xc)];
}

function bisectFinite(x0, y0, x2, y2, fn) {
  // Preconditions:
  // 1. isFinite(y0) !== isFinite(y2)
  if (isFinite(y0) === isFinite(y2)) {
    return;
  }
  
  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);

    // We can't bisect any further; return [x, y] pair for side that is finite.
    if (x1 === x0 || x1 === x2) return isFinite(y0) ? [x0, y0]: [x2, y2];

    // Bisect on side that brackets zero
    if (isFinite(y1) !== isFinite(y0)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

function bisectConstant(x0, y0, x2, y2, fn, constant) {
  // Preconditions:
  // 1. (y0 === constant) !== (y2 === constant)
  if ((y0 === constant) === (y2 === constant)) {
    return;
  }
  
  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    
    // We can't bisect any further; return [x, y] pair for side with
    // y === constant
    if (x1 === x0 || x1 === x2) return (y0 === constant) ? [x0, y0]: [x2, y2];
    
    if ((y1 === constant) !== (y0 === constant)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

function bisectExtremum(x0, y0, x2, y2, x4, y4, fn) {
  // Preconditions:
  // 1. x0 < x2 < x4
  // 2. y0, y2, and y4 are finite, non-equal, and y2 > y0 === y2 > y4.
  if (!(x0 < x2 && x2 < x4)) {
    return;
  }
  if (!(
    (isFinite(y0) && isFinite(y2) && isFinite(y4)) &&
    (y0 !== y2 && y2 !== y4) &&
    (y2 > y0) === (y2 > y4)
  )) {
    return;
  }
  
  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    var x3 = floatMiddle(x2, x4);
    var y3 = fn(x3);
    
    if (!isFinite(y1) || !isFinite(y3)) return null;
    
    // We can't bisect any further; return x and y for most extreme value
    if (x1 === x0 || x1 === x2 || x3 === x2 || x3 === x4) {
      if ((y1 > y2) === (y2 > y0)) return [x1, y1];
      if ((y3 > y2) === (y2 > y0)) return [x3, y3];
      return [x2, y2];
    }
    
    // We've hit a flat. Find its edges and return x and y for its center.
    if (y1 === y2 || y3 === y2) {
      return flatCenter(x0, y0, x2, y2, x4, y4, fn);
    }
    
    // Bisect on side that brackets zero
    if ((y1 > y0) === (y2 > y0) && (y1 > y0) === (y1 > y2)) {
      x4 = x2; y4 = y2; x2 = x1; y2 = y1;
    } else if ((y3 > y4) === (y2 > y4) && (y3 > y2) === (y3 > y4)) {
      x0 = x2; y0 = y2; x2 = x3; y2 = y3;
    } else {
      x0 = x1; y0 = y1; x4 = x3; y4 = y3;
    }
  }
}

// Returns larget jump among 4 points. Used in final step of bisectJump
function largestJump(x0, y0, x1, y1, x2, y2, x3, y3) {
  // Preconditions:
  // 1. y0, y1, y2, and y3 are all finite
  var d1 = Math.abs(y1 - y0);
  var d2 = Math.abs(y2 - y1);
  var d3 = Math.abs(y3 - y2);
  
  if (d1 > d2 && d1 > d3) return [[x0, y0], [x1, y1]];
  if (d3 > d2 && d3 > d1) return [[x2, y2], [x3, y3]];
  return [[x1, y1], [x2, y2]];
}

// Tries to find the largest jump in an interval. Returns left side and right
// side of jump as [[xl, yl], [xr, yr]], or null if no jump was found.
// Tolerance is allowed to be 0, and this works for some smooth functions,
// but returns false positives for others.
function bisectJump(x0, y0, x2, y2, x4, y4, fn, tolerance) {
  // Preconditions:
  // 1. x0 < x2 < x4
  // 2. y0, y2, and y4 are all finite.
  // Also expect x2 - x0 ~= x4 - x2
  if (!(x0 < x2 && x2 < x4)) {
    return;
  }
  if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) {
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    var x3 = floatMiddle(x2, x4);
    var y3 = fn(x3);
    var dy1 = Math.abs(y1 - Distance.mean(y0, y2));
    var dy3 = Math.abs(y3 - Distance.mean(y2, y4));
    var left;
    var right;
    if (!tolerance) tolerance = 0;

    if (dy1 <= tolerance && dy3 <= tolerance) return null;

    // An undefined region counts as a jump.
    if (!isFinite(y1)) {
      left = bisectFinite(x0, y0, x1, y1, fn);
      right = bisectFinite(x1, y1, x4, y4, fn);
      return [left, right];
    }

    if (!isFinite(y3)) {
      left = bisectFinite(x0, y0, x3, y3, fn);
      right = bisectFinite(x3, y3, x4, y4, fn);
      return [left, right];
    }

    if ((x1 === x0 || x1 === x2) && (x3 === x2 || x3 === x4)) {
      if (Math.abs(y2 - y0) > Math.abs(y4 - y2)) {
        left = [x0, y0];
        right = [x2, y2];
      } else {
        left = [x2, y2];
        right = [x4, y4];
      }
      return [left, right];
    } else if (x1 === x0 || x1 === x2) {
      return largestJump(x0, y0, x2, y2, x3, y3, x4, y4);
    } else if (x3 === x2 || x3 === x4) {
      return largestJump(x0, y0, x1, y1, x2, y2, x4, y4);
    }

    if (dy1 > dy3) {
      x4 = x2; y4 = y2; x2 = x1; y2 = y1;
    } else {
      x0 = x2; y0 = y2; x2 = x3; y2 = y3;
    }
  }
}

function findZeros(segments, fn) {
  var segment;
  var accumulator = { x: [], y: [] };
  var x0;
  var y0;
  var x2;
  var y2;
  var zero;
  var flatLeft;
  for (var i=0, li=segments.length; i<li; i++) {
    segment = segments[i];
    flatLeft = undefined;
    if (segment[1] === 0) flatLeft = [segment[0], segment[1]];
    for (var j=0, lj=segment.length; j<lj-2; j = j+2) {
      x0 = segment[j];
      y0 = segment[j+1];
      x2 = segment[j+2];
      y2 = segment[j+3];

      if (!flatLeft) {
        if (y2 === 0) {
          // Entering left side of a potential flat. Save its position.
          flatLeft = [x0, y0];
        } else if ((y0 < 0) !== (y2 < 0)) {
          zero = bisectZero(x0, y0, x2, y2, fn);
          if (zero) {
            accumulator.x.push(zero[0]);
            accumulator.y.push(zero[1]);
          }
        }
      } else {
        if (y2 !== 0) {
          // Leaving right side of a flat. Add its center as a root.
          // Don't label zeros that start on segment boundaries.
          if (flatLeft[0] !== segment[0]) {
            zero = flatCenter(flatLeft[0], flatLeft[1], x0, y0, x2, y2, fn);
            accumulator.x.push(zero[0]);
            accumulator.y.push(zero[1]);
          }
          flatLeft = undefined;
        }
        // Otherwise we're in the middle of the flat; do nothing
      }
    }
    // Don't label zero that ends on a segment boundary.
  }
  
  return accumulator;
}

function findExtrema(segments, fn) {
  var segment;
  var accumulator = { x: [], y: [] };
  var x0;
  var y0;
  var x2;
  var y2;
  var x4;
  var y4;
  var extremum;
  var flatLeft;
  for (var i=0, li=segments.length; i<li; i++) {
    segment = segments[i];
    for (var j=0, lj=segment.length; j<lj - 4; j = j+2) {
      x0 = segment[j];
      y0 = segment[j+1];
      x2 = segment[j+2];
      y2 = segment[j+3];
      x4 = segment[j+4];
      y4 = segment[j+5];
      
      //TODO handle extremal endpoints.
      if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) continue;

      if (y0 !== y2 && y2 === y4) {
        // Entering left side of a flat. Save its position.
        flatLeft = [x0, y0];
      } else if (y0 === y2 && y2 !== y4 && flatLeft) {
        // Leaving right side of a flat.
        if ((y2 > flatLeft[1]) === (y2 > y4)) {
          // Flat is an extremum. Push it's center.
          extremum = flatCenter(flatLeft[0], flatLeft[1], x2, y2, x4, y4, fn);
          accumulator.x.push(extremum[0]);
          accumulator.y.push(extremum[1]);
        }
        flatLeft = undefined;
      } else if (y0 === y2 && y2 === y4) {
        // Middle of a flat, do nothing
      } else if ((y2 > y0) === (y2 > y4)) {
        if (fn.derivative) {
          // If we have derivative information, find zeros of the derivative
          // to find extrema. This gives greater accuracy in the argmax/argmin
          // because the original function is flat at the extrema, but its
          // derivative is (usually) not.
          
          // Make sure we satisfy prereqs of bisectZero
          if ((fn.derivative(x0) > 0) === (fn.derivative(x4) > 0)) continue;
          extremum = bisectZero(
            x0, fn.derivative(x0),
            x4, fn.derivative(x4),
            fn.derivative
          );
          // Currently treat maxima and minima the same
          if (extremum) {
            accumulator.x.push(extremum[0]);
            accumulator.y.push(fn(extremum[0]));
          }
        } else {
          extremum = bisectExtremum(x0, y0, x2, y2, x4, y4, fn);
          // Currently treat maxima and minima the same
          if (extremum) {
            accumulator.x.push(extremum[0]);
            accumulator.y.push(extremum[1]);
          }
        }
      }
    }
  }
  return accumulator;
}

function findIntercept(segments, fn) {
  var intercept = fn(0);
  if (!isFinite(intercept)) return { x: [], y: []};
  return { x: [ 0 ], y: [ fn(0) ] };
}

function findEdges(segments, fn) {
  var slen = segments.length;
  var accumulator = { x: [], y: [] };
  //TODO work out robust system for labeling holes so that we can label all
  // edges.
  //
  // For now, only label edges that are close to zero as zeros.
  
  for (var i = 0; i < slen; i++) {
    var segment = segments[i];
    if (parseFloat(segment[1].toFixed(7)) === 0) {
      accumulator.x.push(segment[0]);
      accumulator.y.push(segment[1]);
    }
    
    if (parseFloat(segment[segment.length - 1].toFixed(7)) === 0) {
      accumulator.x.push(segment[segment.length - 2]);
      accumulator.y.push(segment[segment.length -1]);
    }
  }
  return accumulator;
}

function findPOIs(segments, fn) {
  var zeros = findZeros(segments, fn);
  var edges = findEdges(segments, fn);
  
  // Not displaying edges right now; combine them with zeros.
  zeros.x.push.apply(zeros.x, edges.x);
  zeros.y.push.apply(zeros.y, edges.y);
  
  return {
    zeros: zeros,
    intercept: findIntercept(segments, fn),
    extrema: findExtrema(segments, fn)
  };
}

function findIntersections (differenceSamples, fn1, fn2) {
  var differenceFn = function (x) { return fn2(x) - fn1(x); };

  var zeros = findZeros(differenceSamples, differenceFn);
  var i, elen, zlen;

  // Find tangent intersections.
  var extrema = findExtrema(differenceSamples, differenceFn);
  for (i = 0, elen = extrema.x.length; i < elen; i++) {
    if (BuiltIn.approx(extrema.y[i], 0)) {
      zeros.x.push(extrema.x[i]);
      zeros.y.push(extrema.y[i]);
    }
  }

  // Find original function intersection y values.
  for (i = 0, zlen = zeros.x.length; i < zlen; i++) {
    zeros.y[i] = fn1(zeros.x[i]);
  }
  return zeros;
}

return {
  bisectJump: bisectJump,
  bisectExtremum: bisectExtremum,
  bisectFinite: bisectFinite,
  bisectZero: bisectZero,
  findExtrema: findExtrema,
  findZeros: findZeros,
  findPOIs: findPOIs,
  findIntersections: findIntersections,

  //Enums for POI type
  INTERSECTION: 1001,
  ZERO: 1002,
  INTERCEPT: 1003,
  EXTREMUM: 1004,
  EDGE: 1005,
  DEFINITION: 1006
};

});

define('graphing/graphmode',{
  X: 1,
  Y: 2,
  XYPOINT: 3,
  XYPOINT_MOVABLE: 4,
  PARAMETRIC: 5,
  POLAR: 6,
  POLYGONFILL: 7
});

define('math/plotter',['require','./distance','./poi','graphing/graphmode','./builtinframe','config'],function(require){
  /* jshint maxlen: false */
  var Distance = require('./distance');
  var POI = require('./poi');
  var GRAPHMODE = require('graphing/graphmode');
  var BuiltInFrame = require('./builtinframe');
  var Config = require('config');

var Plotter = {

  //Accumulates a list of segments
  Accumulator: function (domain) {
    var xtolerance, ytolerance;
    
    if (domain) {
      xtolerance = domain.xtolerance || domain.tolerance || 0;
      ytolerance = domain.ytolerance || domain.tolerance || 0;
    } else {
      xtolerance = ytolerance = 0;
    }
    
    var colinear = function (p0, p1, p2, xtolerance, ytolerance) {
      
      if (domain && domain.map) {
        p0 = domain.map(p0);
        p1 = domain.map(p1);
        p2 = domain.map(p2);
      }
      
      var t = Distance.pointToSegmentParameter(
        p2[0], p2[1],
        p0[0], p0[1],
        p1[0], p1[1]
      );

      if (t < 1) return false;

      var closestPoint = [
        p0[0] + t*(p1[0] - p0[0]),
        p0[1] + t*(p1[1] - p0[1])
      ];

      return (
        Math.abs(p2[0] - closestPoint[0]) <= xtolerance &&
        Math.abs(p2[1] - closestPoint[1]) <= ytolerance
      );
    };
    
    return {
      xtolerance: xtolerance,
      ytolerance: ytolerance,
      segments:[],
      segment:null,

      // Second point added to colinear set; defines line direction
      pivotPoint: null,
      // Most recent point in colinear set
      pendingPoint: null,

      addPoint: function (p) {
        this.n+=1;
        var pivotPoint = this.pivotPoint;

        if (!this.segment) {
          this.segment = [p[0], p[1]];  //First point of the segment
          return;
        }

        if (xtolerance < 0 && ytolerance < 0) {
          this.segment.push(p[0], p[1]);
          return;
        }
 
        if (!pivotPoint) {
          this.pivotPoint = p;
          this.pendingPoint = p;
          return;
        }

        // Check if the new point lies on the line segment defined by the
        // last flushed point and the pivot point. If not, flush the pending
        // point and start a new linear section.
        var lastPoint = [
          this.segment[this.segment.length - 2],
          this.segment[this.segment.length - 1]
        ];

        if (!colinear(lastPoint, pivotPoint, p, xtolerance, ytolerance)) {
          this.flushPending();
          this.pivotPoint = p;
        }

        this.pendingPoint = p;
      },

      flushPending: function () {
        if (this.pendingPoint) { //Only happens when we have a segment
          this.segment.push(this.pendingPoint[0], this.pendingPoint[1]);
          this.pivotPoint = null;
          this.pendingPoint = null;
        }
      },
 
      breakSegment: function () {
        this.flushPending();

        if (this.segment) {
          if (this.segment.length > 2) {
            this.segments.push(this.segment);
          }
          this.segment = null;
        }
      },

      getSegments: function () {
        this.breakSegment();
        return this.segments;
      }
    };
  },

//Simple sampling of a [x(t), y(t)] function.
//Domain is provided in terms of the independent variable
//PARAMETERS
//fn(int) => [x, y]
//domain = {min, max, step}
//RETURNS
//Unclipped list of segments which can be passed directly into onGraph
  sampleParametricNaive: function(fn, domain){
    var accumulator = Plotter.Accumulator();
    var point;
    for(var independent = domain.min; independent <= domain.max + domain.step/2; independent += domain.step){
      point = fn(independent);
      if (isFinite(point[0]) && isFinite(point[1])){
        accumulator.addPoint(point);
      }
      else{
        accumulator.breakSegment();
      }
    }
    return accumulator.getSegments();
  },

  //Simple sampling of a y(x) function.
  //PARAMETERS
  //fn(int) => y
  //domain = {min, max, step}
  //RETURNS
  //Unclipped list of segments which can be passed directly into onGraph
  sampleXYNaive: function (fn, domain) {
    var accumulator = Plotter.Accumulator(domain);
    var y;
    for (var x = domain.min; x <= domain.max + domain.step/2; x += domain.step) {
      y = fn(x);
      if (isFinite(y)) {
        accumulator.addPoint([x, y]);
      } else {
        accumulator.breakSegment();
      }
    }
    return accumulator.getSegments();
  },

  sampleXY: function(fn, domain) {
    
    var accumulator = Plotter.Accumulator(domain);
    var edge;
    var x = domain.min;
    var y = fn(x);
    var previousPoint = [x, y];
    var jumpTolerance;
    
    if (domain) jumpTolerance = domain.ytolerance || domain.tolerance;
    
    var handleJump = function (previousPoint, point) {
      if (!isFinite(jumpTolerance) || (jumpTolerance <= 0)) return;
      var jump;
      var xc;
      xc = Distance.mean(previousPoint[0], point[0]);
      jump = POI.bisectJump(
        previousPoint[0], previousPoint[1],
        xc, fn(xc),
        point[0], point[1],
        fn, jumpTolerance
      );
      if (jump) {
        accumulator.addPoint(jump[0]);
        accumulator.breakSegment();
        accumulator.addPoint(jump[1]);
      }
    };
    
    if (isFinite(y)) accumulator.addPoint([x, y]);
    for (x += domain.step; x <= domain.max + domain.step/2; x += domain.step) {
      y = fn(x);
      if (isFinite(y) && isFinite(previousPoint[1])) {
        handleJump(previousPoint, [x, y]);
        accumulator.addPoint([x, y]);
      } else if (isFinite(y) && !isFinite(previousPoint[1])) {
        // left edge
        edge = POI.bisectFinite(previousPoint[0], previousPoint[1], x, y, fn);
        if (edge[0] !== x) accumulator.addPoint(edge);
        handleJump(edge, [x, y]);
        accumulator.addPoint([x, y]);
      } else if (!isFinite(y) && isFinite(previousPoint[1])) {
        // right edge
        edge = POI.bisectFinite(previousPoint[0], previousPoint[1], x, y, fn);
        handleJump(previousPoint, edge);
        if (edge[0] !== previousPoint[0]) accumulator.addPoint(edge);
        accumulator.breakSegment();
      }
      previousPoint = [x, y];
    }
    return accumulator.getSegments();
  },

  findPiPeriod: function (fn, domain, allowAntiperiods) {
    // If the function is periodic by a multiple of 2*pi, or antiperiodic by
    // a multiple of pi within the domain, return the period.
    //
    // Can optionally pass true to find antiperiods if they exist.
    var min = domain.min;
    var range = domain.max - domain.min;
    var tolerance = (domain.xtolerance && domain.ytolerance) ?
      Math.min(domain.xtolerance, domain.ytolerance) :
      domain.tolerance;
    var piRange = Math.floor(range/(Math.PI/BuiltInFrame._angleMultiplier));
    var n, m, period;

    function isPeriod(fn, n) {
      var sign = (n % 2 === 0) ? 1 : -1;
      if (!allowAntiperiods && sign === -1) return false;
      var nPI = n*(Math.PI/BuiltInFrame._angleMultiplier);
      var vals = [ min, min + 1, min + 2, min + 3];
      
      for (var i = 0, ilen = vals.length; i < ilen; i++) {
        if (
          isFinite(fn(vals[i])) !== isFinite(fn(vals[i] + nPI)) ||
          Math.abs(fn(vals[i]) - sign*fn(vals[i] + nPI)) > tolerance
        ) {
          return false;
        }
      }
      
      return true;
    }

    for (n = 1; n <= piRange; n++) {
      if (isPeriod(fn, n)) {
        period = n;
        // Check if integer multiples of the period are also periods
        for (m = 2; m*n <= piRange; m++) {
          if (!isPeriod(fn, m*n)) period = undefined;
        }
        if (period) break;
      }
    }
    
    if (!period) return null;
    
    return period*(Math.PI/BuiltInFrame._angleMultiplier);
  },

  mapPolar: function (p) {
    return [ p[1]*Math.cos(p[0]), p[1]*Math.sin(p[0]) ];
  },

  samplePolar: function (fn, domain) {
    // Don't allow line coallescing, since linear segments of a polar
    // equation don't map to lines on the graph paper.
    domain.map = this.mapPolar;
    return this.sampleXY(fn, domain);
  },

  // Helper for calling a function at steps along a range that makes sure we
  // hit start and endpoints exactly.
  //
  // TODO, use this in sampling xy also. Not
  // doing that for now because I don't want to step on Eric's toes with
  // extrema interleaving system that is being concurrently developed.
  eachStep: function (domain, fn) {
    var min = domain.min;
    var max = domain.max;
    var step = domain.step;
    var range = max - min;
    var nsteps = Math.ceil(range/step);
    var newStep = range/nsteps;
    for (var n = 0; n < nsteps; n++) {
      fn(min + n*newStep);
    }
    fn(max);
  },

  sampleParametricRecursive: function(fn, domain){
    if(domain.max < domain.min){ return [] }

    var accumulator = Plotter.Accumulator(domain);
    var xtolerance, ytolerance;
    if (domain) {
      xtolerance = domain.xtolerance || domain.tolerance || 0;
      ytolerance = domain.ytolerance || domain.tolerance || 0;
    } else {
      xtolerance = ytolerance = 0;
    }

    //Sampling parameters
    var subdivision_levels = 10;

    //Initialize for first pass through loop
    var t0 = domain.min;
    var p0 = fn(t0);
    if (isFinite(p0[0]) && isFinite(p0[1])){
      accumulator.addPoint(p0);
    }

    var p1;
    // Note, processes first point twice; but that's okay.
    this.eachStep(domain, function (t1) {
      p1 = fn(t1);
      Plotter.subsampleParametricRecursive(fn, t0, p0, t1, p1, subdivision_levels, accumulator, xtolerance, ytolerance);
      t0 = t1;
      p0 = p1;
    });

    return accumulator.getSegments();
  },

  subsampleParametricRecursive: function(fn, t0, p0, t1, p1, subdivision_levels_left, accumulator, xtolerance, ytolerance){

    if (t1 === t0) return; // Nothing new to add, but don't need to break;

    var t_mid = Distance.mean(t0, t1);
    var p_mid = fn(t_mid, true);

    var p0_valid = isFinite(p0[0]) && isFinite(p0[1]);
    var p1_valid = isFinite(p1[0]) && isFinite(p1[1]);
    var p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);

    if (subdivision_levels_left === 0 || t_mid === t0 || t_mid === t1) {
      accumulator.breakSegment(); //Didn't converge.
      if (p1_valid) accumulator.addPoint(p1);
      return;
    }

    if (!p0_valid && !p1_valid) return; //Don't need to break segment, since p0 should already have been processed.

    if(p0_valid != p1_valid){
      //We're at the edge of where the function is defined.  Subdivide until we find where edge point to machine precision
      var original_t0 = t0;
      var original_t1 = t1;
      var original_p0 = p0;
      var original_p1 = p1;
   
      while (t0 !== t_mid && t_mid !== t1) {

        if(p_mid_valid == p0_valid){
          t0 = t_mid;
          p0 = p_mid;
          p0_valid = p_mid_valid;
        }
        else{
          t1 = t_mid;
          p1 = p_mid;
          p1_valid = p_mid_valid;
        }

        t_mid = t0 + (t1-t0)/2;
        p_mid = fn(t_mid, true);
        p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);
      } //When this loop terminates, t_mid equals either t0 or t1

      if(p0_valid){
        Plotter.subsampleParametricRecursive(fn, original_t0, original_p0, t0, p0, subdivision_levels_left-1, accumulator, xtolerance, ytolerance);
        accumulator.breakSegment();
      }
      else{
        accumulator.breakSegment();
        accumulator.addPoint(p1);
        Plotter.subsampleParametricRecursive(fn, t1, p1, original_t1, original_p1, subdivision_levels_left-1, accumulator, xtolerance, ytolerance);
      }
      return;
    }

    if (p0_valid && p_mid_valid && p1_valid) {
      
      var t = Distance.pointToSegmentParameter(
        p_mid[0],
        p_mid[1],
        p0[0],
        p0[1],
        p1[0],
        p1[1]
      );
      
      // If the new point lies betwen 20 % and 80 % of the way between the
      // outer points, and the distance from the segment to the new point is
      // less than tolerance, add the rightmost point, and stop recursing.
      if (
        t > 0.2 &&
        t < 0.8 &&
        Math.abs(p_mid[0] - (p0[0] + t*(p1[0] - p0[0]))) <= xtolerance &&
        Math.abs(p_mid[1] - (p0[1] + t*(p1[1] - p0[1]))) <= ytolerance
      ) {
        accumulator.addPoint(p1);
        return;
      }
    }

    // If we didn't stop, recurse. Don't recurse between two points that are
    // equal, since this will make us do a lot of work if our point becomes
    // independent of t over some range.
    if (!(p0[0] === p_mid[0] && p0[1] === p_mid[1])) {
      Plotter.subsampleParametricRecursive(fn, t0, p0, t_mid, p_mid, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
    }
    if (!(p1[0] === p_mid[0] && p1[1] === p_mid[1])) {
      Plotter.subsampleParametricRecursive(fn, t_mid, p_mid, t1, p1, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
    }
  },

  validateViewState: function(viewState){
    /*jshint -W018*/ //Suppresses !(a>b) jshint warning.
    if(!viewState) return false;
    var xmin = viewState.viewport.xmin;
    var xmax = viewState.viewport.xmax;
    var ymin = viewState.viewport.ymin;
    var ymax = viewState.viewport.ymax;
    if(!(xmax > xmin)) return false;
    if(!(ymax > ymin)) return false;
    if(!(viewState.screen.width > 0)) return false;
    if(!(viewState.screen.height > 0)) return false;
    return true;
  },

  computeDomain: function(viewState, graph_info, fn){
    var xmin = viewState.viewport.xmin;
    var xmax = viewState.viewport.xmax;
    var ymin = viewState.viewport.ymin;
    var ymax = viewState.viewport.ymax;

    var oversample = viewState.oversample || 4;
    var xtolerance = 1/oversample*(xmax - xmin)/viewState.screen.width;
    var ytolerance = 1/oversample*(ymax - ymin)/viewState.screen.height;
    var isLinear = graph_info.isLinear;

    var domain;
    switch(graph_info.graphMode){
      case GRAPHMODE.X:
        domain = {
          min: ymin,
          max: ymax,
          xtolerance: ytolerance, // Note, switched
          ytolerance: xtolerance,
          step: (isLinear ? ymax - ymin : ytolerance)
        };
        break;
      case GRAPHMODE.Y:
        domain = {
         min: xmin,
         max: xmax,
         xtolerance: xtolerance,
         ytolerance: ytolerance,
         step: (isLinear ? xmax - xmin : xtolerance)
        };
        break;
      case GRAPHMODE.POLAR:
        domain = {
          min :0,
          max: 2*Math.PI/BuiltInFrame._angleMultiplier*6,
          step: (2*Math.PI/BuiltInFrame._angleMultiplier)/1000,
          tolerance: Math.min(xtolerance, ytolerance)
        };
        var period = Plotter.findPiPeriod(fn, domain, graph_info.operator === '=');
        if (period) domain.max = domain.min + period;
        break;
      case GRAPHMODE.PARAMETRIC:
        domain = {
          min: graph_info.domain.min,
          max: graph_info.domain.max,
          step: graph_info.domain.step,
          xtolerance: xtolerance,
          ytolerance: ytolerance
        };
        break;
    }
    return domain;
  },

  classifyBranchConic: function (segments) {
    if (!Config.get('conic')) return;
    var conic, segmentConic;
    if (segments.length === 1 && segments[0].length === 4) return 'line';
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var len = segment.length;
      if (len < 12) return 'unknown';
      try {
        segmentConic = Distance.classifyConic(
          segment[0], segment[1],
          segment[2*Math.floor(1*len/12)], segment[2*Math.floor(1*len/12) + 1],
          segment[2*Math.floor(2*len/12)], segment[2*Math.floor(2*len/12) + 1],
          segment[2*Math.floor(3*len/12)], segment[2*Math.floor(3*len/12) + 1],
          segment[2*Math.floor(4*len/12)], segment[2*Math.floor(4*len/12) + 1],
          segment[len - 2], segment[len - 1]
        );
      } catch (e) {
        // numeric.js's SVD routine can fail to converge and throw an error.
        return 'unknown';
      }
      
      if (segmentConic === 'none') return 'none';
      if (conic && segmentConic !== conic) return 'none';
      conic = segmentConic;
    }
    return conic;
  },

  //Computes domain, decides what function to use, and returns answer
  computeGraphData: function(viewState, graph_info, fn){
    var domain = Plotter.computeDomain(viewState, graph_info, fn);
    if(!domain) return [];
    var segments;
    var tmp;
    switch(graph_info.graphMode){
      case GRAPHMODE.X:
      case GRAPHMODE.Y:
      segments = Plotter.sampleXY(fn, domain);
      break;
      case GRAPHMODE.POLAR:
      segments = Plotter.samplePolar(fn, domain);
      break;
      case GRAPHMODE.PARAMETRIC:
      if(!domain.step) domain.step = (domain.max - domain.min) / 1000;
      segments = Plotter.sampleParametricRecursive(fn, domain);
    }

    var poi = [];
    if(graph_info.graphMode !== GRAPHMODE.PARAMETRIC){
      poi = POI.findPOIs(segments, fn);
      segments = Plotter.interleaveExtrema(segments, poi);
    }

    // Flip POI representation if necessary
    if (graph_info.graphMode === GRAPHMODE.X) {
      for (var type in poi) {
        if (!poi.hasOwnProperty(type)) continue;
        tmp = poi[type].y;
        poi[type].y = poi[type].x;
        poi[type].x = tmp;
      }
    }

    var datum = {
      segments: segments,
      graphMode: graph_info.graphMode,
      color: graph_info.color,
      style: graph_info.style,
      operator: graph_info.operator,
      poi: poi,
      conic: Plotter.classifyBranchConic(segments),
      expr: null //compiled.fn
    };
    return [datum];
  },

  interleaveExtrema: function(segments, poi) {
    var nsegments = segments.length;
    var segment;
    var newSegments = Array(nsegments);
    var newSegment;
    var slen;
    var extrema = poi.extrema;
    var j=0;
    var elen = extrema.x.length;

    for (var n = 0; n < nsegments; n++) {
      segment = segments[n];
      slen = segment.length;
      newSegment = [];
      for (var i=0; i < slen; i = i+2) {
        // push extrema between last point and current point onto
        // accumulator.
        while (j < elen && extrema.x[j] <= segment[i]) {
          // Don't push the same point twice
          if (extrema.x[j] !== segment[i]) {
            newSegment.push(extrema.x[j], extrema.y[j]);
          }
          j++;
        }
        // push current point onto accumulator.
        newSegment.push(segment[i], segment[i+1]);
      }
      newSegments[n] = newSegment;
    }
    return newSegments;
  },

  polygonsFromSegments: function(bottom_segments, top_segments, graphMode){
    var last_x = function(segments){
      var last_segment = segments[segments.length - 1];
      return last_segment[last_segment.length - 2];
    };

    var polygons = [];
    //Until we have pulled the last segment:
      //Continue to pull segments from the top and the bottom until we find two which end at the same point.
      //When that happens, close the polygon, and start another one.
    var i_top = 0;
    var i_bottom = 0;
    var current_bottom = [];
    var current_top = [];
    var top_x = -Infinity;
    var bottom_x = -Infinity;

    while(true){

      if(top_x <= bottom_x){
        if(i_top >= top_segments.length) break;
        current_top.push(top_segments[i_top++]);
      }
      if(bottom_x <= top_x){
        if(i_bottom >= bottom_segments.length) break;
        current_bottom.push(bottom_segments[i_bottom++]);
      }
      top_x = last_x(current_top);
      bottom_x = last_x(current_bottom);

      if(top_x == bottom_x){
        polygons.push(Plotter.polygonFromSegments(current_bottom, current_top, graphMode));
        current_top = [];
        current_bottom = [];
      }
    }
    return polygons;
  },

  polygonFromSegments: function(bottom_segments, top_segments, graphMode){
    //TODO - respect graphMode (by pushing in proper order)
    var i, j, p, segment;
    var polygon = [];
    var map;
    switch(graphMode){
      case GRAPHMODE.POLAR:
        map = this.mapPolar;
        break;
      case GRAPHMODE.X:
        map = function(p){return [p[1], p[0]];};
        break;
    }
    for(i = 0; i < bottom_segments.length; i++){
      segment = bottom_segments[i];
      for(j = 0; j < segment.length; j += 2){
        p = [segment[j], segment[j+1]];
        if(map)
          p = map(p);
        polygon.push(p[0], p[1]);
      }
    }
    for(i = top_segments.length - 1; i>=0; i--){
      segment = top_segments[i];
      for(j = segment.length - 2; j >= 0; j -= 2){
        p = [segment[j], segment[j+1]];
        if(map)
          p = map(p);
        polygon.push(p[0], p[1]);
      }
    }
    return polygon;
  }
};

return Plotter;
});

define('main/fake_i18n',['require','underscore'],function (require) {
  // This file fakes i18n for places where i18n isn't yet working correctly
  // For example: in the webworker when generating error messages
  var _ = require('underscore');

  //example usage:
  //i18n.t("Too many free variables to graph.  Try defining '__variable__.", {variable: free_variables[i]});

  var translate = function (str, options) {
    _.each(options, function(option, key) {
      str = str.split('__' + key + '__').join(option);
    });
    return str;
  };

  var init = function () {};

  return {
    t: translate,
    init: init
  };
});
// Basically temporary shim to support the API of the current formula object and allow integration into the rest of the
// system. API here is just a direct copy, funny naming and all.

define('math/evaluationstate',['require','pjs','graphing/graphmode','math/comparators'],function(require){
  var P = require('pjs');
  var GRAPHMODE = require('graphing/graphmode');
  var Comparators = require('math/comparators');

var EvaluationState = P(function (state) {
  state.init = function (analysis, context, statement) {
    var graphMode;
    

    this.error = analysis.error;
    this.is_graphable = statement && statement.isGraphable();
    
    if (this.is_graphable) graphMode = analysis.graph_info.graphMode;
    this.is_evaluable = statement && statement.isEvaluable();
    if (this.is_evaluable) this.zero_values = statement.getZeroValues();
    this.is_point_list = graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE;
    this.is_parametric = graphMode === GRAPHMODE.PARAMETRIC;
    this.is_shade_between = this.is_graphable && !!statement.shade_between;
    if (this.is_shade_between) this.shade_between_operators = statement.getOperators();
    this.is_double_inequality = this.is_shade_between && statement.getOperators().length == 2;
    if (statement) {
      this.operator = statement.getOperator();
      this.assignment = statement.getAssignedVariable();
      this.variables = statement.getSlidableVariables();
      this.simple_constant = statement.getSliderValue();
      this.is_inequality = this.is_double_inequality || Comparators.table[this.operator].direction !== 0;
    } else {
      this.variables = [];
    }
    //Internally true or undefined, nicer to pass true/false to others
    this.is_slidable = !!analysis.slider;
    this.is_animatable = this.is_slidable && !this.is_graphable;
    if (analysis.moveIds) {
      this.move_ids = analysis.moveIds;
    }
    this.is_tableable = (
      this.is_graphable &&
      !this.is_parametric &&
      !statement.is_solved_equation &&
      this.operator === '=' &&
      !this.is_double_inequality
    );
    if (this.is_tableable) {
      this.table_info = statement.getTableInfo();
      var independent = this.table_info.independent_variable;
      if(independent === 'y' || independent === 'theta') {
        this.is_tableable = false;
        delete(this.table_info);
      }
    }
  };
});
return EvaluationState;
});

define('graphing/columnmode',{
  POINTS: 'POINTS',
  LINES: 'LINES',
  POINTS_AND_LINES: 'POINTS_AND_LINES'
});

define('math/derivative',['require','./parser_util','./evalframe'],function(require){
  var Parser = require('./parser_util');
  var EvalFrame = require('./evalframe');

var DerivativeNode = Parser.DerivativeNode;
var ConstantNode = Parser.ConstantNode;
var NegationNode = Parser.NegationNode;
var ParseNode = Parser.ParseNode;
var BinaryOperatorNode = Parser.BinaryOperatorNode;
var FunctionNode = Parser.FunctionNode;
var FunctionDeclarationNode = Parser.FunctionDeclarationNode;
var FunctionCallExponentNode = Parser.FunctionCallExponentNode;
var IdentifierNode = Parser.IdentifierNode;
var RepeatedOperatorNode = Parser.RepeatedOperatorNode;
var SummationNode = Parser.SummationNode;
var ChainedComparatorNode = Parser.ChainedComparatorNode;
var PiecewiseNode = Parser.PiecewiseNode;
var AssignmentNode = Parser.AssignmentNode;
// TODO derivative not defined for AssignmentNode and ProductNode
// var ProductNode = Parser.ProductNode;

DerivativeNode.open(function (node) {
  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    
    var dtree = this.expression.takeDerivative(
      frame,
      this.derivative_variable
    );

    // If root of the derivative tree is a Derivative node, then we don't know
    // how to symbolically differentiate this tree. Just wrap it in another
    // DerivativeNode.
    if (dtree instanceof DerivativeNode) {
      return Parser.DerivativeNode(variable, dtree);
    }

    return dtree.takeDerivative(frame, variable);
  };
  
  node.freeOf = function (frame, variable) {
    return this.expression.freeOf(frame, variable);
  };
  
  node.substitute = function (frame) {
    var dtree = this.expression.takeDerivative(
      frame,
      this.derivative_variable
    );

    if (dtree instanceof DerivativeNode) {
      if (frame.hasVariable(this.derivative_variable.identifier)) {
        throw "Can't substitute for derivative variable if derivative can't be taken symbolically";
      }

      return DerivativeNode(this.derivative_variable, this.expression);
    }

    return dtree.substitute(frame);
  };
});

ParseNode.open(function (node) {
  // Fallback. If we don't know how to take the derivative of a node
  // symbolically, wrap it in a DerivativeNode, and the evaluator will
  // evaluate the derivative numerically.
  node.takeDerivative = function (frame, variable) {
    return DerivativeNode(variable, this);
  };

  node.freeOf = function (frame, variable) { return false; };
});

var DerivativeHelpers = {};

// Helper for implementing the chain rule. For f(a), tree is f'(a), and
// arg is a. Returns f'(a)*da/dx, but checks whether a is free of x, in which
// case we just return a ConstantNode(0). This is important when f'(a) is
// undefined, since 0*NaN is NaN, but we want the output to be zero.
DerivativeHelpers.chain = function(frame, variable, tree, arg) {
  if (arg.freeOf(frame, variable)) return ConstantNode(0);
  return BinaryOperatorNode.reduce(
    '*',
    tree,
    arg.takeDerivative(frame, variable)
  );
};

// Helper that parses a latex string and returns a function that replaces
// a_{i} identifiers with the trees in an array. e.g.
//
//   substituteFn('a_1*\\sin(a_0)')([Parser.parse('x^2'), Parser.parse('y')])
//
// returns a tree equivalent to
//
//   Parser.parse('y*\\sin(x^2)')
;(function () {

  var tmps = [];
  var argRegExps = [];

  // 9 arguments should be enough for anyone...
  for (var i = 0; i < 9; i++) {
    tmps.push(IdentifierNode('a_{' + i + ParseNode.prototype.tmp() + '}'));
    argRegExps.push(RegExp('a_' + i, 'g'));
  }

  // Do things lexically like this because the latexStrings are known
  // statically, and because we don't yet have all the substitute machinery
  // defined.
  //
  // Note, this code is a little more delicate than it looks. the tmps could
  // almost be straight strings, but I'm making them IdentifierNodes and using
  // .toString and .identifier to finesse the issue that a_{i} parses into an
  // expression with identifier a_i.
  var replaceArgs = function (latexString) {
    for (var i = 0; i < tmps.length; i++) {
      latexString = latexString.replace(argRegExps[i], tmps[i].toString());
    }
    return latexString;
  };

  DerivativeHelpers.substituteFn = function(latexString) {
    var parsed = Parser.parse(replaceArgs(latexString));
    var frame = EvalFrame();
    
    return function (args) {
      var length = args.length;
      for (var i = 0; i < length; i++) {
        frame.setVariable(tmps[i].identifier, args[i]);
      }
      return parsed.substitute(frame);
    };
  };
})();


// Factory method for creating binary operator nodes that folds constants.
// Note, we don't simplify 0*a because a could be NaN or Infinity.
BinaryOperatorNode.reduce = function (operator, arg1, arg2) {
  switch (operator) {
    case '+':
      if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
        return ConstantNode(arg1.value + arg2.value);
      }
      if (arg1 instanceof ConstantNode && arg1.value === 0) {
        return arg2;
      }
      if (arg2 instanceof ConstantNode && arg2.value === 0) {
        return arg1;
      }
      break;
    case '-':
      if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
        return ConstantNode(arg1.value - arg2.value);
      }
      if (arg2 instanceof ConstantNode && arg2.value === 0) {
        return arg1;
      }
      break;
    case '*':
      if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
        return ConstantNode(arg1.value*arg2.value);
      }
      if (arg1 instanceof ConstantNode && arg1.value === 1) {
        return arg2;
      }
      if (arg2 instanceof ConstantNode && arg2.value === 1) {
        return arg1;
      }
      break;
    case '/':
      if (arg2 instanceof ConstantNode && arg2.value === 1 ) {
        return arg1;
      }
      if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
        return ConstantNode(arg1/arg2);
      }
      break;
    case '^':
      if (arg2 instanceof ConstantNode && arg2.value === 1) {
        return arg1;
      }
      break;
  }
  return BinaryOperatorNode(operator, arg1, arg2);
};

NegationNode.reduce = function (expression) {
  if (expression instanceof ConstantNode) {
    return ConstantNode(-expression.value);
  }
  if (expression instanceof NegationNode) return expression.expression;
  return NegationNode(expression);
};

BinaryOperatorNode.open(function (node, _super) {
  
  // substitution functions for taking derivatives of powers:
  // d/dxf(x)^{g(x)} = g(x)*f(x)^{g(x) - 1}*f'(x) + f(x)^{g(x)}*ln(f(x))*g'(x)
  //                =         bprime*f'(x)        +         eprime*g'(x)
  var bprime = DerivativeHelpers.substituteFn('a_1*a_0^{a_1 - 1}');
  var eprime = DerivativeHelpers.substituteFn('a_0^{a_1}*\\ln(a_0)');
  
  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    
    var a0 = this.args[0];
    var a1 = this.args[1];
    switch (this.operator) {
      case '+':
        return BinaryOperatorNode.reduce(
          '+',
          a0.takeDerivative(frame, variable),
          a1.takeDerivative(frame, variable)
        );
      case '-':
        return BinaryOperatorNode.reduce(
          '-',
          a0.takeDerivative(frame, variable),
          a1.takeDerivative(frame, variable)
        );
      case '*':
        return BinaryOperatorNode.reduce(
          '+',
          DerivativeHelpers.chain(frame, variable, a1, a0),
          DerivativeHelpers.chain(frame, variable, a0, a1)
        );
      case '/':
        return BinaryOperatorNode.reduce(
          '/',
          BinaryOperatorNode.reduce(
            '-',
            DerivativeHelpers.chain(frame, variable, a1, a0),
            DerivativeHelpers.chain(frame, variable, a0, a1)
          ),
          BinaryOperatorNode.reduce('^', a1, ConstantNode(2))
        );
      case '^':
        return BinaryOperatorNode.reduce(
          '+',
          DerivativeHelpers.chain(frame, variable, bprime(this.args), a0),
          DerivativeHelpers.chain(frame, variable, eprime(this.args), a1)
        );
      default:
        return _super.takeDerivative.call(this, frame, variable);
    }
  };
  
  node.freeOf = function (frame, variable) {
    return this.args[0].freeOf(frame, variable) &&
      this.args[1].freeOf(frame, variable);
  };

  node.substitute = function (frame) {
    return BinaryOperatorNode.reduce(
      this.operator,
      this.args[0].substitute(frame),
      this.args[1].substitute(frame)
    );
  };
});

ChainedComparatorNode.open(function (node) {
  node.freeOf = function (frame, variable) {
    return this.args.every(function (arg) {
      return arg.freeOf(frame, variable);
    });
  };
  
  node.substitute = function (frame) {
    return ChainedComparatorNode(
      this.comparators,
      this.args.map(function(arg) {
        return arg.substitute(frame);
      })
    );
  };
});

ConstantNode.open(function (node) {
  node.takeDerivative = function () { return ConstantNode(0); };

  node.freeOf = function (frame, variable) { return true; };

  node.substitute = function (frame) { return this; };
});

FunctionNode.open(function (node, _super) {
  var derivativeStrings = {
    exp: [ '\\exp(a_0)' ],
    sqrt: [ '\\frac{1}{2*\\sqrt{a_0}}' ],
    sin: [ '\\angleMultiplier(1)*\\cos(a_0)' ],
    cos: [ '-\\angleMultiplier(1)*\\sin(a_0)' ],
    tan: [ '\\angleMultiplier(1)*(\\sec(a_0))^2' ],
    arcsin: [ '\\frac{1}{\\angleMultiplier(1)*\\sqrt{1 - a_0^2}}' ],
    arccos: [ '\\frac{-1}{\\angleMultiplier(1)*\\sqrt{1 - a_0^2}}' ],
    arctan: [ '\\frac{1}{\\angleMultiplier(1)*(1 + a_0^2)}' ],
    sinh: [ '\\cosh(a_0)' ],
    cosh: [ '\\sinh(a_0)' ],
    tanh: [ '(\\sech(a_0))^2' ],
    arcsinh: [ '\\frac{1}{\\sqrt{a_0^2 + 1}}' ],
    arccosh: [ '\\frac{1}{\\sqrt{a_0^2 - 1}}' ],
    arctanh: [ '\\frac{1}{1 - a_0^2}' ],
    factorial: [ '(a_0)!*\\polyGamma(0, a_0 + 1)' ],
    floor: [ '\\left\\{ \\mod(a_0, 1) > 0: 0 \\right\\}' ],
    ceil: [ '\\left\\{ \\mod(a_0, 1) > 0: 0 \\right\\}' ],
    round: [
      '\\left\\{ \\abs(\\mod(a_0, 1) - 0.5) > 0: 0 \\right\\}'
    ],
    abs: [ '\\left\\{ \\abs(a_0) > 0: \\sign(a_0) \\right\\}' ],
    sign: [ '\\left\\{ \\abs(a_0) > 0: 0 \\right\\}' ],
    angleMultiplier: [ '0' ],
    log: [
      // d/dx ln(x) is actually real for negative x, too, but showing the
      // derivative in places where we don't show the function is confusing,
      // so restrict to x > 0.
      '\\left\\{a_0 > 0: \\frac{1}{a_0*\\ln(a_1)}\\right\\}',
      '\\frac{-\\log_{a_1}(a_0)}{a_1*\\ln(a_1)}'
    ],
    pow: [
      'a_1*a_0^{a_1 - 1}',
      'a_0^{a_1}*\\ln(a_0)'
    ],
    nthroot: [
      'a_0^{1/a_1 - 1}/a_1',
      '-\\frac{a_0^{1/a_1}*\\ln(a_0)}{a_1^2}'
    ],
    polyGamma: [
      '0/0',
      '\\polyGamma(1 + a_0, a_1)'
    ],
    // Taking care to leave the derivative undefined for min(x, c) when x == c
    // Not sure how to make the case of d/dx min(x, x) = 1 work right
    min: [
      '\\left\\{ a_0 < a_1 : 1, a_0 > a_1 : 0 \\right\\}',
      '\\left\\{ a_1 < a_0 : 1, a_1 > a_0 : 0 \\right\\}'
    ],
    max: [
      '\\left\\{ a_0 > a_1 : 1, a_0 < a_1 : 0 \\right\\}',
      '\\left\\{ a_1 > a_0 : 1, a_1 < a_0 : 0 \\right\\}'
    ],
    mod: [
      '\\left\\{ \\abs(\\mod(a_0, a_1)) > 0: 1 \\right\\}',
      // Check whether division results in an integer directly instead
      // of computing mod of the args because division sometimes results
      // in an integer when modulus does not result in 0, e.g.
      //
      // 3.8 % -0.7599999999999999 -> 3.3306690738754696e-16, but
      // 3.8 / -0.7599999999999999 -> -5
      //
      // This can confuse the jump detector, resulting in spurious
      // connections.
      //
      //TODO still have some spurious connections near 0 in d/dx mod(3,x).
      // Why?
      '\\left\\{ \\mod(a_0/a_1, 1) > 0: -\\floor(a_0/a_1) \\right\\}'
    ]
  };
  
  var derivativeTable = {};
  
  // Turn derivativeStrings into substitution functions by mapping
  // substituteFn. Extra scope is to keep 'identifier' from leaking.
  ;(function () {
    var ds = derivativeStrings;
    var dt = derivativeTable;
    var substituteFn = DerivativeHelpers.substituteFn;
    for (var identifier in ds) {
      if (!ds.hasOwnProperty(identifier)) continue;
      dt[identifier] = ds[identifier].map(substituteFn);
    }
  })();

  var registerReciprocalDerivative = function (symbol, reciprocal) {
    derivativeTable[reciprocal] = [function (args) {
      return NegationNode.reduce(BinaryOperatorNode.reduce(
        '/',
        derivativeTable[symbol][0](args),
        BinaryOperatorNode.reduce(
          '^',
          FunctionNode(IdentifierNode(symbol), args),
          ConstantNode(2)
        )
      ));
    }];
  };

  [
    ['sin', 'csc'],
    ['cos', 'sec'],
    ['tan', 'cot'],
    ['sinh', 'csch'],
    ['cosh', 'sech'],
    ['tanh', 'coth']
  ].forEach(function(pair) {
    registerReciprocalDerivative(pair[0], pair[1]);
  });

  var registerInverseReciprocalDerivative = function (symbol, reciprocal) {
    derivativeTable[reciprocal] = [function (args) {
      return NegationNode.reduce(BinaryOperatorNode.reduce(
        '/',
        derivativeTable[symbol][0]([
          BinaryOperatorNode.reduce('/', ConstantNode(1), args[0])
        ]),
        BinaryOperatorNode.reduce('^', args[0], ConstantNode(2))
      ));
    }];
  };

  [
    ['arcsin', 'arccsc'],
    ['arccos', 'arcsec'],
    ['arctan', 'arccot'],
    ['arcsinh', 'arccsch'],
    ['arccosh', 'arcsech'],
    ['arctanh', 'arccoth']
  ].forEach(function(pair) {
    registerInverseReciprocalDerivative(pair[0], pair[1]);
  });

  var undefinedFn = function () { return ConstantNode(NaN); };

  // Assumes arity 2
  var registerUndefinedDerivative = function (symbol) {
    derivativeTable[symbol] = [ undefinedFn, undefinedFn ];
  };

  // We actually round arguments for these functions, so to be consistent,
  // these could be defined as 0 except at integers where they're undefined,
  // but that is not a standard definition.
  //
  // Can also define continuous nCr and nPr using gamma function.
  //
  //TODO useful error messages for these?
  ['lcm', 'gcd', 'nCr', 'nPr', 'mcm', 'mcd'].forEach(registerUndefinedDerivative);

  //These functions are used for solving quadratic functions, but will never be differentiated.
  //This is a bit of an abuse of the frame system, but registering them as builtins is a good way
  //to have them available within compiled functions
  ['quadraticFormula', 'quadraticInequalityRegions'].forEach(registerUndefinedDerivative);

  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    
    var identifier = this.identifier.identifier;

    var args = this.args;
    var partials;
    if (derivativeTable.hasOwnProperty(identifier)) {
      partials = derivativeTable[identifier];
    } else if (frame.hasFunction(identifier)) {
      partials = frame.getFunctionTree(identifier).computePartials(frame);
    } else if (this.args.length === 1 && frame.hasVariable(identifier)) {
      // Treat as implicit multiplication
      return BinaryOperatorNode(
        '*',
        this.identifier,
        this.args[0]
      ).takeDerivative(frame, variable);
    } else {
      return _super.takeDerivative.call(this, frame, variable);
    }

    var nargs = args.length;

    var firstTerm = DerivativeHelpers.chain(
      frame,
      variable,
      partials[nargs - 1](args),
      args[nargs - 1]
    );

    // Implements the chain rule for multi-argument functions. Called
    // recursively to build up a sum using BinaryOperatorNode('+', ...)
    function sumPartials(sumSoFar, n) {
      if (n < 0) return sumSoFar;

      return sumPartials(BinaryOperatorNode.reduce(
        '+',
        sumSoFar,
        DerivativeHelpers.chain(
          frame,
          variable,
          partials[n](args),
          args[n]
        )
      ), n - 1);
    }

    return sumPartials(firstTerm, this.args.length - 2);
  };
  
  node.freeOf = function (frame, variable) {
    return this.args.every(function (arg) {
      return arg.freeOf(frame, variable);
    }) && this.identifier.freeOf(frame, variable);
  };

  node.substitute = function (frame) {
    return FunctionNode(
      this.identifier,
      this.args.map(function (arg) {
        return arg.substitute(frame);
      })
    );
  };
});

FunctionDeclarationNode.open(function (node) {
  node.computePartials = function (frame) {
    var self = this;
    return self.args.map(function (arg) {
      var dtree = self.expression.takeDerivative(frame, arg);
      return function (args) {
        var argFrame = EvalFrame(frame);
        var valFrame = EvalFrame(frame);
        var tmp;
        for (var i = 0; i < self.args.length; i++) {
          tmp = IdentifierNode(self.tmp());
          argFrame.setVariable(self.args[i].identifier, tmp);
          valFrame.setVariable(tmp.identifier, args[i]);
        }
        // Use temporary identifiers to avoid putting self-referencing
        // substitutions in the same frame, i.e. x->2x, since substitute
        // works recursively.
        return dtree.substitute(argFrame).substitute(valFrame);
      };
    });
  };
});

FunctionCallExponentNode.open(function (node) {
  node.takeDerivative = function (frame, variable) {
    return this.getEquivalentNode(frame).takeDerivative(frame, variable);
  };
  
  node.freeOf = function (frame, variable) {
    return this.getEquivalentNode(frame).freeOf(frame, variable);
  };
  
  node.substitute = function (frame) {
    return FunctionCallExponentNode(
      this.identifier.substitute(frame),
      this.arg.substitute(frame),
      this.exponent.substitute(frame)
    );
  };
});

IdentifierNode.open(function (node) {
  node.takeDerivative = function (frame, variable) {
    if (variable.identifier === this.identifier) return ConstantNode(1);
    if (!frame.hasVariable(this.identifier)) return ConstantNode(0);
    return frame.getVariable(this.identifier).takeDerivative(frame, variable);
  };

  node.freeOf = function (frame, variable) {
    if (variable.identifier === this.identifier) return false;
    if (!frame.hasVariable(this.identifier)) return true;
    return frame.getVariable(this.identifier).freeOf(frame, variable);
  };
  
  node.substitute = function (frame) {
    if (!frame.hasVariable(this.identifier)) return this;
    
    return frame.getVariable(this.identifier).substitute(frame);
  };
  
});

NegationNode.open(function (node) {
  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    return NegationNode.reduce(this.expression.takeDerivative(frame, variable));
  };
  
  node.freeOf = function (frame, variable) {
    return this.expression.freeOf(frame, variable);
  };

  node.substitute = function (frame) {
    return NegationNode.reduce(this.expression.substitute(frame));
  };
});

PiecewiseNode.open(function (node) {
  //NOTE doesn't differentiate the condition (expect this to only produce
  // delta functions)
  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    
    var pn = PiecewiseNode(
      this.condition,
      this.if_expr.takeDerivative(frame, variable)
    );

    if (this.else_expr) {
      pn.append_else(this.else_expr.takeDerivative(frame, variable));
    }

    return pn;
  };

  //TODO ignores the condition for now. Only want to traverse nodes that
  // derivative traverses.
  node.freeOf = function (frame, variable) {
    if (!this.else_expr) {
      return (
        this.condition.freeOf(frame, variable) &&
        this.if_expr.freeOf(frame, variable)
      );
    }
    return (
      this.condition.freeOf(frame, variable) &&
      this.if_expr.freeOf(frame, variable) &&
      this.else_expr.freeOf(frame, variable)
    );
  };

  node.substitute = function (frame) {
    var pn = PiecewiseNode(
      this.condition.substitute(frame),
      this.if_expr.substitute(frame)
    );

    if (this.else_expr) pn.append_else(this.else_expr.substitute(frame));

    return pn;
  };
});

RepeatedOperatorNode.open(function (node) {
  node.freeOf = function (frame, variable) {
    return (
      this.index.freeOf(frame, variable) &&
      this.lower_bound.freeOf(frame, variable) &&
      this.upper_bound.freeOf(frame, variable) &&
      this.summand.freeOf(frame, variable)
    );
  };

  node.substitute = function (frame) {
    // If the index is in the substitution map, replace it before substituting
    //TODO is this necessary?
    var index = this.index;
    var newFrame = EvalFrame(frame);
    var newIndex;
    //Always replace index with new tmp variable, to prevent early collapsing
    newIndex = IdentifierNode(this.tmp());
    newFrame.setVariable(index.identifier, newIndex);
    
    // Note, can't call this.constructor(...) directly because it's a pjs
    // corner case. See https://github.com/jayferd/pjs/issues/9
    var constructor = this.constructor;
    return constructor(
      newIndex,
      this.lower_bound.substitute(frame),
      this.upper_bound.substitute(frame),
      this.summand.substitute(newFrame)
    );
  };
});

SummationNode.open(function (node) {
  node.takeDerivative = function (frame, variable) {
    if (this.freeOf(frame, variable)) return ConstantNode(0);
    
    return SummationNode(
      this.index,
      this.lower_bound,
      this.upper_bound,
      this.summand.takeDerivative(frame, variable)
    );
  };
});

//TODO ProductNode not implemented. The easy way to write this involves
// divisions of terms that could be zero
// node.takeDerivative = function (frame, variable)


// Nodes that can be graphed need to be able to return the derivative of
// the expression they graph for extremum finding. For example, if we have
// y = sin(x), the sin(x) part is graphed, so we need to be able to find the
// derivative of it.
//
// Call this 'expressionDerivative' instead of 'takeDerivative' because it
// isn't really the derivative of the whole node.
;(function () {
  var expressionDerivative = function (frame, variable) {
    return this.expression.takeDerivative(frame, variable);
  };
  
  AssignmentNode.open(function (node) {
    node.substitute = function (frame) {
      return AssignmentNode(this.assigns, this.expression.substitute(frame));
    };
    
    node.expressionDerivative = expressionDerivative;
  });

  FunctionDeclarationNode.open(function (node) {
    node.substitute = function (frame) {
      return FunctionDeclarationNode(this.assigns, this.args, this.expression.substitute(frame));
    };
    
    node.expressionDerivative = expressionDerivative;
  });
})();

return; //Just re-opens ParseNodes, doesn't return anything

});

define('math/evaluatorobject',['require','underscore','pjs','main/fake_i18n','./parser_util','./plotter','./comparators','./evalframe','./quadratic','./evaluationstate','graphing/graphmode','graphing/columnmode','./derivative'],function(require){
  /* jshint maxlen: false */
  var _ = require('underscore');
  var P = require('pjs');

  //in the worker, use our fake i18n for now,
  //which just proxies through the english translation
  var i18n = require('main/fake_i18n');

  var Parser = require('./parser_util');
  var Plotter = require('./plotter');
  var Comparators = require('./comparators');
  var EvalFrame = require('./evalframe');
  var Quadratic = require('./quadratic');
  var EvaluationState = require('./evaluationstate');
  var GRAPHMODE = require('graphing/graphmode');
  var COLUMNMODE = require('graphing/columnmode');
  require('./derivative');

  //Status enums
  var ERROR = {name: 'ERROR'};
  var WARNING = {name: 'WARNING'};
  var EVALUABLE = {name: 'EVALUABLE'};
  var GRAPHABLE = {name: 'GRAPHABLE'};
  var SILENT = {name: 'SILENT'};

  //TODO - need to export Nodes from parse_util into namespace
var AnalysisClass = {}; //Map object type to analysis class

var ConstantNode = Parser.ConstantNode;
var IdentifierNode = Parser.IdentifierNode;
var ErrorNode = Parser.ErrorNode;
var BinaryOperatorNode = Parser.BinaryOperatorNode;

function copyDefinedPOIs(points) {
  var xs = [];
  var ys = [];

  var len = points.length;
  for (var i=0; i<len; i++) {
    xs.push(points[i][0]);
    ys.push(points[i][1]);
  }

  return {
    defined: {x: xs, y: ys}
  };
}

var AnalysisObject = P(function(obj){
  obj.init = function(context){
    this._context = context;
    this._analysis = null;
    this.compiler = context.compiler;
  };

  obj.exportDefinitionsTo = function(frame){
  };

  obj.getAllIds = function(){
    return [];
  };

  obj.cleanupId = function(id){
    throw "base analysis object can't cleanup ID";
  };

  obj.invalidate = function(){
    this._analysis = null;
  };

  obj.getAnalysis = function(){
    if(!this._analysis) this._context.updateAnalysis();
    return this._analysis;
  };

  obj.setAnalysis = function(analysis){
    this._analysis = analysis;
  };

  obj.shouldIntersect = function(){
    return false;
  };

  obj.isEvaluable = function(){
    return this.getAnalysis().status == EVALUABLE;
  };

  obj.isGraphable = function(){
    return this.getAnalysis().status == GRAPHABLE;
  };

  obj.isGraphed = function(){
    return this.isGraphable();
  };

  obj.graphModeFromVariables = function(independent, dependent){
    if(dependent === 'x' || independent === 'y') return GRAPHMODE.X;
    if((dependent === 'r' && independent === 'theta') ||
       (dependent === 'r' && independent === undefined) ||
       (dependent === undefined && independent === 'theta')){
          return GRAPHMODE.POLAR;
    }
    return GRAPHMODE.Y;
  };


  obj.setGraphMode = function(mode, independent, dependent){

    if(dependent === 'y' && !independent) independent = 'x';
    if(dependent === 'x' && !independent) independent = 'y';
    if(dependent === 'r' && !independent) independent = 'theta';

    if(!mode){
      mode = this.graphModeFromVariables(independent, dependent);
    }
    this._analysis.graph_info = {
      color: this._statement.color,
      style: this._statement.style,
      graphMode:mode,
      independent:independent,
      dependent:dependent,
      operator: this.getOperator(),
      domain: this._statement.domain //Only defined for parametric.  One day for polar also
    };
    return GRAPHABLE;
  };

  obj.computeGraphData = function(viewport){
  };

  obj.getStatus = function(){
    return this.getAnalysis().status;
  };

  obj.getAssignedVariable = function(){
    return null;//TODO - override for variable definitions and equations
  };

  obj.compile = function(){
    return undefined;
  };

  obj.getSlidableVariables = function(){
    return [];
  };

  obj.getSliderValue = function(){
    return NaN;
  };

  obj.getZeroValues = function(){
    return [];
  };

  obj.addFreeVariables = function(variables){
    for(var i = 0; i < variables.length; i++){
      var variable = variables[i];
      if(this._analysis.free_variables.indexOf(variable) > -1) continue;
      this._analysis.free_variables.push(variable);
    }
  };

});

var StatementAnalysis = P(AnalysisObject, function(obj, _super){
  obj.init = function(context, statement, tree){
    _super.init.call(this, context);
    this._statement = statement;
    this._tree = tree;
    this.id = statement.id;
    //TODO - get rid of these copies.  They're here to make the transition easier
    this.color = statement.color;
    this.style = statement.style;
    this.domain = statement.domain;
  };

  obj.isGraphed = function(){
    return this.isGraphable() && this._statement.shouldGraph;
  };

  obj.getAllIds = function(){
    return [this.id];
  };

  obj.getGraphInfo = function(){
    return this._analysis.graph_info;
  };

  obj.shouldIntersect = function(){
    if(!this.isGraphed()) return false;
    var graphMode = this.getGraphInfo().graphMode;
    return (graphMode === GRAPHMODE.Y || graphMode === GRAPHMODE.X);
  };

  obj.computeGraphData = function(viewState){
    var graphData = {};

    //Compile
    var frame = this._context.getFrame();

    var compiled = this.compile(frame);
    compiled.fn.derivative = this.compileDerivative(frame).fn;

    //Figure out graphMode
    var graph_info = this._analysis.graph_info;
    //Check if it's linear first
    var order =  this._tree.polynomialOrder(frame, graph_info.independent);
    if(order === 1){
      graph_info.isLinear = true;
    }

    //Actually fill out graphData
    graphData[this.id] = Plotter.computeGraphData(viewState, graph_info, compiled.fn);
    graphData[this.id][0].compiled = compiled;
    return graphData;
  };

  obj.getEvaluationState = function(){
    return EvaluationState(this._analysis, this._context, this);
  };

  obj.computeStatus = function(){
    return this.markError(i18n.t("Unimplemented status check"));
  };

  obj.getZeroValues = function(){
    return [{val: this._tree.evaluateOnce(this._context.getFrame()), operator:'='}];
  };

  obj.referencesSymbol = function(symbol){
    return this._tree.references(symbol);
  };

  obj.referencedSymbols = function(symbol){
    return this._tree._referencedSymbols;
  };

  obj.getSlidableVariables = function(){
    var free_variables = this._analysis.free_variables;
    var variables = [];
    for(var i = 0; i < free_variables.length; i++){
      var variable = free_variables[i];
      if(this._context.assignmentForbidden(variable)) continue;
      if (this._analysis.hasOwnProperty('solution')) {
        if (variable == this._analysis.solution.variable) continue;
      }
      variables.push(variable);
    }
    return variables;
  };

  obj.exportedSymbols = function(){
    //assignment or function declaration
    var exported = {};
    if(this._tree.assigns)
      exported[this._tree.assigns.identifier] = this._tree.arity;
    return exported;
  };

  obj.exportDefinitionsTo = function (frame, id) {
    if(!this._tree.assigns) return;
    var symbol = this._tree.assigns.identifier;
    if(this._context.assignmentForbidden(symbol)) return;
    this._tree.exportDefinitionsTo(frame, this.compiler);
    // Used to look up which expression defines an identifier
    frame.setDefinitionId(symbol, id);
  };

  obj.shadowedSymbols = function(){
    return [];
  };

  obj.getDependencies = function(){
    return this._tree.dependencies();
  };

  obj.getType = function(){
    return this._tree.statementType;
  };

  obj.freeVariablesError = function(free_variables){
    for(var i = 0; i < free_variables.length; i++){
      if(this._context.assignmentForbidden(free_variables[i])) continue;
      var msg = i18n.t(
        "Too many free variables to graph.  Try defining '__variable__'",
        {variable: free_variables[i]}
      );
      return this.markError(msg);
    }
    return this.markError(i18n.t("Too many free variables.  I don't know what to do with this"));
  };

  obj.getParseError = function(){
    if(this._tree.valid) return undefined;
    return this._tree.error_msg;
  };

  obj.markError = function(msg){
    this._analysis.error = msg;
    this._analysis.status = ERROR;
    return ERROR;
  };

  obj.evaluateOnce = function(frame){
    return this._tree.evaluateOnce(frame);
  };

  obj.evalStrings = function(frame){
    return this._tree.getEvalStrings(frame);
  };

  obj.compileAllBranches = function(frame){
    return [this.compile(frame)];
  };

  obj.compile = function(frame) {
    var source = this.compile_to_strings(frame, this.independent_variable());
    source.fn = this.compiler.compile(source.args, source.function_string);
    return source;
  };

  obj.compileDerivative = function (frame) {
    var independent_variable = this.independent_variable();
    var identifier = IdentifierNode(independent_variable);
    var derivative_tree;
    if (this._tree.expressionDerivative) {
      derivative_tree = this._tree.expressionDerivative(frame, identifier);
    } else {
      derivative_tree = this._tree.takeDerivative(frame, identifier);
    }
    
    //TODO CLEANUP Making a new object like this is a bit of a hack. Consider
    // changing interface of compile functions so we don't need to pass as
    // much stuff.
    var derivativeObject = StatementAnalysis(
      this._context,
      this._statement,
      derivative_tree
    );
    var source = derivativeObject.compile_to_strings(frame,
      independent_variable);
    source.fn = this.compiler.compile(source.args, source.function_string);
    return source;
  };

  obj.independent_variable = function () {
    if (this._analysis.status === GRAPHABLE) {
      return this._analysis.graph_info.independent;
    } else if (this._analysis.free_variables.length === 1) {
      return this._analysis.free_variables[0];
    }
  };

  obj.compile_to_strings = function(frame, independent_variable) {
    var eval_strings = this._tree.getEvalStrings(frame);

    var function_string = eval_strings.statements + 'return ' + eval_strings.expression;
    return {
      args: [independent_variable],
      function_string: function_string
    };
  };

  obj.getOperator = function(){
    return '=';
  };

  obj.getTableInfo = function(){
    return undefined;
  };

  obj.getTableInfo = function(){
    return {
      independent_variable: this._analysis.graph_info.independent,
      dependent_column: this._tree.getInputString(),
      by_reference: false
    };
  };

});

AnalysisClass[EXPRESSION] = P(StatementAnalysis, function(obj, _super){
  obj.computeStatus = function(frame){
    var free_variables = this._analysis.free_variables;
    if(free_variables.length === 0) return EVALUABLE;
    if(free_variables.length === 1){
      switch(free_variables[0]){
      case 'x':     return this.setGraphMode(GRAPHMODE.Y, 'x');
      case 'y':     return this.markError(i18n.t("Maybe you wanted to plot x as a function of y?"));
      case 'r':     //Fall through to theta
      case 'theta': return this.markError(i18n.t("Maybe you wanted to plot r as a function of θ?"));
      default:      return this.markError(i18n.t("Maybe you wanted to plot x or y as a function of __variable__ ?",{variable:free_variables[0]}));
      }
    }
    return this.freeVariablesError(free_variables);
  };
});

AnalysisClass[FUNCTION_DEFINITION] = P(StatementAnalysis, function(obj, _super){
  obj.init = function(context, statement, tree){
    _super.init.call(this, context, statement, tree);
    this.arity = this._tree.arity;
  };

  obj.shadowedSymbols = function(){
    return this._tree.passed_variables;
  };

  obj.computeStatus = function(frame){
    if(this._tree.arity === 1){
      if(this._tree.assigns.identifier === this._tree.passed_variables[0]){
        return this.markError(i18n.t("You can't use __identifier__ as both the function name and the argument", this._tree.assigns.identifier));
      }
      if(this._analysis.free_variables.length > 0){ //f(x) = a with a undefined shouldn't plot vs. a
        return this.markError(i18n.t("Every variable you use in the function must be defined.  Either define __variable__or pass it in as an argument", {variable:this._analysis.free_variables[0]}));
      }
      return this.setGraphMode(undefined, this._tree.passed_variables[0], this._tree.assigns.identifier);
    }
    if(this._tree.arity > 1) return WARNING; //TODO - need to handle these warnings in the UI
  };

  obj.addFreeVariables = function(variables){
    var passed_variables = this._tree.passedVariables();
    for(var i = 0; i < variables.length; i++){
      var variable = variables[i];
      if(passed_variables.indexOf(variable) > -1) continue;
      if(this._analysis.free_variables.indexOf(variable) > -1) continue;
      this.markError(i18n.t("Every variable you use in the function must be defined.  Either define '__variable__' or pass it in as an argument", {variable: variable}));
      this._analysis.free_variables.push(variable);
    }
  };

  obj.conflictError = function(symbol){
    var msg = i18n.t("'__symbol__' is already defined, so you can\'t reuse it as one of the parameters of this function", {symbol: symbol});
    return this.markError(msg);
  };

  obj.getTableInfo = function(){
    if(this._context.assignmentForbidden(this._tree.assigns.identifier)){
      return {
        independent_variable: this._analysis.graph_info.independent,
        dependent_column: this._tree.expression.getInputString(),
        by_reference: false
      };
    } else {
      return {
        independent_variable: this._analysis.graph_info.independent,
        dependent_column: this._tree.getInputString(),
        by_reference: true
      };
    }
  };

  obj.getSlidableVariables = function(){
    var free_variables = this._analysis.free_variables;
    var variables = [];
    for(var i = 0; i < free_variables.length; i++){
      var variable = free_variables[i];
      if(this._context.assignmentForbidden(variable)) continue;
      variables.push(variable);
    }
    return variables;
  };

});


AnalysisClass[VARIABLE_DEFINITION] = P(StatementAnalysis, function(obj, _super){
  obj.computeStatus = function(frame){
    var variable = this._tree.assigns.identifier;
    var free_variables = this._analysis.free_variables;
    if (variable === 'theta') {
    //TODO - support this
      return this.markError(i18n.t("Sorry - can't graph θ as a function of anything yet"));
    }
    if (free_variables.length === 0) {
      var should_slide = (this._tree.expression instanceof ConstantNode);
      if(should_slide) this._analysis.slider = true;

      if ('xyr'.indexOf(variable) !== -1) return this.setGraphMode(undefined, undefined, variable);
      return should_slide ? SILENT : EVALUABLE;  //Don't display the value next to a slider
    }
    if (free_variables.length === 1) {
      if(free_variables[0] === variable) {
      //TODO - needs better message (at least)
        return this.markError(i18n.t('Cannot define __variable__ in terms of itself.'), {variable: free_variables[0]});
      }
      if (free_variables[0] === 'r') {
        return this.markError(i18n.t('Maybe you wanted to plot r as a function of θ?'));
      }
      return this.setGraphMode(undefined, free_variables[0], variable);
    }
    return this.freeVariablesError(free_variables);
  };

  obj.getAssignedVariable = function(){
    return this._tree.assigns.identifier;
  };

  obj.getSliderValue = function(){
    if(this._tree.expression instanceof ConstantNode){
      return this._tree.evaluateOnce();
    }
    return _super.getSliderValue();
  };

  obj.getTableInfo = function(){
    if(this._context.assignmentForbidden(this._tree.assigns.identifier)){
      return {
        independent_variable: this._analysis.graph_info.independent,
        dependent_column: this._tree.expression.getInputString(),
        by_reference: false
      };
    } else {
      return {
        independent_variable: this._analysis.graph_info.independent,
        dependent_column: this._analysis.graph_info.dependent,
        by_reference: true
      };
    }
  };
});

AnalysisClass[IDENTIFIER]= P(StatementAnalysis, function(obj, _super){
  obj.computeStatus = function(frame){
    var free_variables = this._analysis.free_variables;
    if(free_variables.length === 1 && free_variables[0] === 'x') return this.setGraphMode(GRAPHMODE.Y, 'x');
    if(free_variables.length > 0) return SILENT;
    return EVALUABLE;
  };
});

AnalysisClass[CONSTANT]= P(StatementAnalysis, function(obj, _super){
  obj.computeStatus = function(frame){
    return SILENT;
  };

  obj.getSliderValue = function(){
    return this._tree.evaluateOnce();
  };
});

AnalysisClass[ORDERED_PAIR_LIST]= P(StatementAnalysis, function(obj, _super){

  // A point is movable if one or both of its coordinates is an identifier
  // that has a slider associated with it.
  //
  // With this definition:
  //
  // [ 'a = 1', 'b = 1', '(a, b)' ]     can be dragged in both directions
  //
  // [ 'a = 1', 'b = 1', '(a, b + 1)' ] can be dragged horizontally only
  //
  // [ 'a = 1', '(a, a^2)' ]            updates 'a' when dragged, which moves
  //                                    the point along a parabola
  //
  // [ 'a = 1', '(a + 1, a^2)' ]        can't be dragged at all
  //
  obj.computeMovable = function (frame) {
    var self = this;
    if (self._analysis.status != GRAPHABLE) return; //Filter out errors and depdendency problems
    if (self._analysis.free_variables.length !== 0) return;
    if (self._tree.elements.length !== 1) return;
    var movable;
    var moveIds = [undefined, undefined];
    self._tree.elements[0].children.forEach(function (tree, index) {
      if (!(tree instanceof IdentifierNode)) return;

      var definitionId = frame.getDefinitionId(tree.identifier);
      if (definitionId === undefined) return;
      if (!self._context.statements[definitionId]._analysis.slider) return;
      
      movable = true;
      moveIds[index] = definitionId;
    });

    if (movable) {
      self._analysis.movable = true;
            
      // upgrade a point to a movable point
      if (self._analysis.graph_info.graphMode === GRAPHMODE.XYPOINT) {
        self._analysis.graph_info.graphMode = GRAPHMODE.XYPOINT_MOVABLE;
      }
      
      // Avoid double updating in case of [ 'a = 1', '(a, a)' ]
      if (moveIds[1] === moveIds[0]) moveIds[1] = undefined;
      self._analysis.moveIds = moveIds;
    }
  };

  obj.computeStatus = function(frame){
    var free_variables = this._analysis.free_variables;
    if(free_variables.length === 0){
      return this.setGraphMode(GRAPHMODE.XYPOINT);
    }

    if(free_variables.length === 1){
      if(free_variables[0] === 't' && this._tree.elements.length == 1){
        return this.setGraphMode(GRAPHMODE.PARAMETRIC, 't');
      }
      return this.markError(i18n.t("Define '__variable__' to plot this point, or make each coordinate a function of 't' to plot it as a parametric function", {variable: free_variables[0]}));
    }

    if(free_variables.length > 1){
      return this.freeVariablesError(free_variables);
    }
  };

  obj.getSlidableVariables = function(){
    //Don't offer to create a slider for t
    var variables = _super.getSlidableVariables.call(this);
    var index = variables.indexOf('t');
    if(index > -1){
      variables.splice(index, 1);
    }
    return variables;
  };

  obj.computeGraphData = function(viewState){
    //Figure out graphMode
    var graph_info = this._analysis.graph_info;
    var graphData = {};

    //Test if we're points
    if(graph_info.graphMode === GRAPHMODE.XYPOINT || graph_info.graphMode === GRAPHMODE.XYPOINT_MOVABLE){
      var points = this._tree.evaluateOnce(this._context.getFrame());
      var datum = {
        segments: [points],
        graphMode: graph_info.graphMode,
        color: this._statement.color,
        style: this._statement.style,
        poi: copyDefinedPOIs(points)
      };
      graphData[this.id] = [datum];
      return graphData;
    }

    //Plot parametric
    
    //Compile
    var compiled = this.compile(this._context.getFrame());
    var fn = function(x){return compiled.fn(x)[0]};  //TODO - fix this with compileAllBranches
    graphData[this.id] = Plotter.computeGraphData(viewState, graph_info, fn);
    return graphData;
    //Start intersections going (TODO - make sure starting / stopping these is still correct)
  };

  obj.getTableInfo = function(){
    var values = this._tree.evaluateOnce(this._context.getFrame());
    return {
      independent_variable: 'x',
      dependent_column: 'y',
      by_reference: false,
      values: values
    };
  };

});

AnalysisClass[DOUBLE_INEQUALITY] = P(StatementAnalysis, function(obj, _super){
  obj.init = function(context, statement, tree){
    _super.init.call(this, context, statement, tree);
    this._inequalities = [];
    for(var i = 0; i < 2; i++){
      var subtree = tree.getInequality(i);
      this._inequalities.push(AnalysisClass[COMPARATOR](context, statement, subtree));
    }
  };

  obj.shade_between = true;

  obj.computeStatus = function(frame){
    for(var i = 0; i < 2; i++){
      this._inequalities[i].setAnalysis({free_variables: this._analysis.free_variables});
    }
    var statuses = this._inequalities.map(function (x) {
      x._analysis.status = x.computeStatus(frame);
      return x._analysis.status;
    }); //Compute status for each sub-inequality

    if(statuses[0] === GRAPHABLE && statuses[1] === GRAPHABLE){
      this._analysis.graph_info = this._inequalities[0]._analysis.graph_info;
      if(this._analysis.graph_info.graphMode === GRAPHMODE.POLAR)
        return this.markError(i18n.t('Two-sided inequalities are only supported for x and y.  You can do one-sided polar inequalities.'));
      return GRAPHABLE;
    }
    else{
      return this.markError(i18n.t('One or more sub-inequality had an error')); //TODO - good error messages and detection
    }
  };

  obj.computeGraphData = function(frame){
    var id = this.id;
    var graphData = {};
    graphData[id] = [];

    var updateOperator = function (s) {
      s.operator = Comparators.get(Comparators.table[s.operator].inclusive, 0);
    };

    for ( var i = 0; i < 2; i++ ) {
      var subGraphData = this._inequalities[i].computeGraphData(frame)[id].slice(0, 4);
      subGraphData.forEach(updateOperator);
      graphData[id].push.apply(graphData[id], subGraphData);
    }

    var graphMode = graphData[id][0].graphMode;
    var polygons;

    polygons = Plotter.polygonsFromSegments(graphData[id][4].segments, graphData[id][0].segments, graphMode);

    graphData[id].push(
      {
        graphMode: GRAPHMODE.POLYGONFILL,
        segments: polygons,
        poi:{}
      }
    );
    
    polygons = Plotter.polygonsFromSegments(graphData[id][7].segments, graphData[id][3].segments, graphMode);
    
    graphData[id].push(
      {
        graphMode: GRAPHMODE.POLYGONFILL,
        segments: polygons,
        poi:{}
      }
    );

    return graphData;
  };

  obj.compileAllBranches = function(frame){
    var compiled = [];
    for(var i = 0; i < 2; i++){
      compiled.push.apply(compiled, this._inequalities[i].compileAllBranches(frame));
    }
    return compiled;
  };

  obj.getOperators = function(){
    return [this._inequalities[0].getOperator(),
            this._inequalities[1].getOperator()];
  };

});

AnalysisClass[EQUATION]= P(StatementAnalysis, function(obj, _super){
  obj.init = function(context, statement, tree){
    _super.init.call(this, context, statement, tree);
    this.temp_tree = BinaryOperatorNode('-', this._tree.lhs, this._tree.rhs);
  };

  obj.is_solved_equation = true;

  //Figure out which variables to solve for, save solution in analysis
  obj.computeStatus = function(frame){
    var free_variables = this._analysis.free_variables;
    if(free_variables.length > 2) return this.freeVariablesError(free_variables);
    
    if(free_variables.length === 2){
      //Might be graphable, if variables are X and Y;
      if((free_variables[0] === 'x' && free_variables[1] === 'y') ||
         (free_variables[0] === 'y' && free_variables[1] === 'x')){
        var x_order = this.temp_tree.polynomialOrder(frame, 'x');
        var y_order = this.temp_tree.polynomialOrder(frame, 'y');
        if(y_order <= 2) return this.setGraphMode(GRAPHMODE.Y, 'x', 'y');
        if(x_order <= 2) return this.setGraphMode(GRAPHMODE.X, 'y', 'x');
        return this.markError(i18n.t("Equation is too complicated.  One variable needs to be quadratic."));
      }
      return this.markError(i18n.t('You can only plot implicit equations of x and y'));
    }

    if(free_variables.length === 1){
      //Might be evaluable, let's try
      var solution = this.solveEvaluable(frame);
      if(solution){
        this._analysis.solution = solution;
        return EVALUABLE;
      }
      else{
        return this.markError(i18n.t('Sorry - unable to solve this equation.  Try something like a quadratic?'));
      }
    }

    if(free_variables.length === 0){
      return this.markError(i18n.t("This equation has no variables in it - there's nothing to solve"));
      //TODO - support boolean true/false tests with equals sign
    }
  };

  obj.solveEvaluable = function(frame){
    var coeffs, roots;

    if(this._analysis.free_variables.length != 1) return false;

    var variable = this._analysis.free_variables[0];
    var order = this.temp_tree.polynomialOrder(frame, variable);

    switch(order){
      case 1:
        coeffs = this.temp_tree.quadraticCoefficients(frame, variable);
        roots = [-coeffs[2] / coeffs[1]];
        break;
      case 2:
        coeffs = this.temp_tree.quadraticCoefficients(frame, variable);
        roots = Quadratic.formula(coeffs);
        break;
      default:
        return false;
    }

    return {roots:roots, variable:variable};
  };

  obj.getZeroValues = function(){
    var retval = [];
    var roots = this._analysis.solution.roots;
    for(var i = 0; i < roots.length; i++){
      retval.push({val:roots[i], operator:'='});
    }
    return retval;
  };

  obj.getAssignedVariable = function(){
    switch(this._analysis.status){
      case EVALUABLE:
        return this._analysis.solution.variable;
      case GRAPHABLE:
        return this._analysis.graph_info.dependent;
    }
  };

  obj.computeGraphData = function(viewState){
    var graphData = {};
    var compiled = this.compileAllBranches(this._context.getFrame());
    var graph_info = this._analysis.graph_info;

    graphData[this.id] = [];
    for(var i = 0; i < compiled.length; i++){
      var data = Plotter.computeGraphData(viewState, graph_info, compiled[i].fn)[0];
      data.compiled = compiled[i];
      graphData[this.id].push(data);
    }
    return graphData;
  };

  obj.compileAllBranches = function(frame){
    var compiled = [];
    var independent = this._analysis.graph_info.independent;
    var dependent = this._analysis.graph_info.dependent;
    var coeffEvalStrings = this.temp_tree.polynomialEvalStrings(frame, dependent, independent);

    var evalStrings = Quadratic.formulaEvalStrings(coeffEvalStrings);

    var args = [independent];
    for(var i = 0; i < evalStrings.length; i++){
      compiled.push({fn: this.compiler.compile(args, evalStrings[i]), args:args, function_string:evalStrings[i]});
    }
    return compiled;
  };
});

AnalysisClass[COMPARATOR] = P(StatementAnalysis, function(obj, _super) {
  obj.init = function(context, statement, tree) {
    _super.init.call(this, context, statement, tree);
    var operator = this._tree.operator;
    if (Comparators.table[operator].direction === 1) {
      this.temp_tree = BinaryOperatorNode(
        '-',
        this._tree.args[0],
        this._tree.args[1]
      );
    } else {
      this.temp_tree = BinaryOperatorNode(
        '-',
        this._tree.args[1],
        this._tree.args[0]
      );
    }
  };

  obj.getDependencies = function(){
    var deps = this._tree.dependencies();
    if(_.isEqual(deps, {r:0, theta:0})){
      this.addFreeVariables(['r', 'theta']);
      return [];
    }
    if(_.isEqual(deps, {r:0})){
      this.addFreeVariables(['r']);
      return [];
    }
    return deps;
  };
  
  obj.computeStatus = function(frame){
    var free_variables = this._analysis.free_variables;
    if (free_variables.length === 0) return EVALUABLE;
    
    var singleVariables = { x: true, y: true, r: true };
    
    var fv0 = free_variables[0], fv1 = free_variables[1];
    var order0, x_order, y_order, r_order;
    
    if (free_variables.length === 1) {
      if (!singleVariables.hasOwnProperty(fv0)) {
        return this.markError(i18n.t('We only plot inequalities of x and y, or r and theta'));
      }

      order0 = this.temp_tree.polynomialOrder(frame, fv0);
      if (fv0 === 'r' && order0 > 1) {
        return this.markError(i18n.t('We only plot polar inequalities that are first order in r.'));
      }
      if (order0 > 2) {
        return this.markError(i18n.t('Equation too complicated. One variable needs to be quadratic'));
      }
      
      return this.setGraphMode(undefined, undefined, fv0);
    }
    
    var twoVariables = { x: 'y', y: 'x', r: 'theta', theta: 'r' };
    
    if (free_variables.length === 2) {
      if (twoVariables[fv0] !== fv1) {
        return this.markError(i18n.t('We only plot inequalities of x and y, or r and theta'));
      }
      
      if (fv0 === 'r' || fv1 === 'r') {
        r_order = this.temp_tree.polynomialOrder(frame, 'r');
        if (r_order > 1) {
          return this.markError(i18n.t('We only plot polar inequalities that are first order in r.'));
        }
        return this.setGraphMode(GRAPHMODE.POLAR, 'theta', 'r');
      }
      
      x_order = this.temp_tree.polynomialOrder(frame, 'x');
      y_order = this.temp_tree.polynomialOrder(frame, 'y');
      if (y_order <= 2) return this.setGraphMode(GRAPHMODE.Y, 'x', 'y');
      if (x_order <= 2) return this.setGraphMode(GRAPHMODE.X, 'y', 'x');
      return this.markError(i18n.t("Equation is too complicated.  One variable needs to be quadratic."));
      
    }
    
  };
  
  obj.computeGraphData = function(viewState){
    var graphData = {};
    var compiled = this.compileAllBranches(this._context.getFrame());
    var graph_info = this._analysis.graph_info;
    var operator = this._tree.operator;
    var thisGraphData = graphData[this.id] = [];
    var data;

    //TODO this system doesn't work with polar inequalities yet.
    //Currently, this works for first-order polar inequalities by just pushing
    //the single open-ended inequality, and leaving the rest of the branches empty
    //
    //This would need to be fixed to support second-order polar inequalities

    var polarities = [ -1, 0, 0, 1 ];

    for (var i = 0; i < 4; i++) {
      data = Plotter.computeGraphData(
        viewState,
        graph_info,
        compiled[i].fn
      )[0];
      data.compiled = compiled[i];
      data.operator = Comparators.get(
        Comparators.table[operator].inclusive,
        polarities[i]
      );
      thisGraphData.push(data);
    }

    var polygons;

    polygons = Plotter.polygonsFromSegments(
      thisGraphData[1].segments,
      thisGraphData[2].segments,
      thisGraphData[1].graphMode
    );

    thisGraphData.push({
      graphMode: GRAPHMODE.POLYGONFILL,
      segments: polygons,
      poi:{}
    });

    return graphData;
  };

  obj.compileAllBranches = function(frame){
    var compiled = [];
    var independent = this._analysis.graph_info.independent;
    var dependent = this._analysis.graph_info.dependent;
    var coeffEvalStrings = this.temp_tree.polynomialEvalStrings(frame, dependent, independent);

    var evalStrings = Quadratic.inequalityRegionEvalStrings(coeffEvalStrings);

    var args = [independent];
    for(var i = 0; i < evalStrings.length; i++){
      compiled.push({fn: this.compiler.compile(args, evalStrings[i]), args:args, function_string:evalStrings[i]});
    }
    return compiled;
  };

  obj.getOperator = function(){
    return this._tree.operator;
  };

  obj.getSlidableVariables = function(){
    //Don't offer a slider for r
    return _super.getSlidableVariables.call(this).filter(function(v){
      return (v !== 'r');
    });
  };
});

AnalysisClass[CHAINED_COMPARATOR] = P(StatementAnalysis, function(obj, _super) {
  obj.computeStatus = function (frame) {
    var free_variables = this._analysis.free_variables;
    if (free_variables.length === 0) return EVALUABLE;
    
    return this.markError(i18n.t('We only graph solved double inequalities. Try sin(x) < y < cos(x).'));
  };
  
  
});

var Table = P(AnalysisObject, function(obj, _super){
  obj.init = function(context, table_description){
    _super.init.call(this, context);
    this._description = table_description;
    this.id = table_description.id;
    this.ids_to_clean = [];
    this.columns = [];
    this.cell_tree = [];
    for(var i = 0; i < this._description.columns.length; i++){
      //Not a great solution, but since we're using the same latex parser, this is what makes sense.
      //Might make sense to eventually create a different table-header latex parser which enforces that grammar, so that the parser errors come out properly, but for now I don't think the maintenance overhead is worth it
      if(this._description.columns[i].latex === '' && i > 0){
        this._description.columns[i].latex = '\\emptycolumn_'+i; //Make empty columns behave like scatterplot
      }
      var column_analysis = createAnalysisObject(this._context, this._description.columns[i]);
      this.columns.push(column_analysis);
      this.cell_tree[i] = [];
      var values = this._description.columns[i].values;
      for(var row = 0; row < values.length; row++){
        if(values[row].trim() === ''){
          this.cell_tree[i][row] = ErrorNode('');  //Stay silent for empty cells
          continue;
        }
        this.cell_tree[i][row] = Parser.tryParse(values[row]);
      }
    }
    if(this.columns[0]._tree && this.columns[0]._tree instanceof IdentifierNode){
      this.shadowed_symbols = [this.columns[0]._tree.identifier];
      var symbol = this.shadowed_symbols[0];
      if(symbol === 'y') this.parse_error = i18n.t("Sorry - can't make a table based on y yet.  Try x?");
      if(symbol === 'r') this.parse_error = i18n.t("Sorry - can't make a table based on r yet.  Try x?");
    }
    else{
      this.parse_error = i18n.t('Tables need a single variable for their first independent column');
      this.shadowed_symbols = [];
    }
    //TODO - throw user-facing errors if any of the columns or rows try to export things
  };

  obj.isGraphed = function(){return true;}; //Always graph table, let columns decide

  obj.cleanupId = function(id){
    this.ids_to_clean.push(id);
  };

  obj.getAllIds = function(){
    var ids = [this.id];
    for(var i = 0; i < this.columns.length; i++){
      ids.push(this.columns[i].id);
    }
    return ids;
  };

  obj.exportedSymbols = function(){
    //Tables never export anything
    return [];
  };

  obj.shadowedSymbols = function(){
    return this.shadowed_symbols;
  };

  obj.getDependencies = function(){
    //Record all dependencies of all headers as dependencies
    var dependencies = {};
    var dependency;
    for(var i = 0; i < this.columns.length; i++){
      var column_dependencies = this.columns[i].getDependencies();
      for(dependency in column_dependencies){
        if(!column_dependencies.hasOwnProperty(dependency)) continue;
        //TODO - verify that all dependencies are consistent arity
        dependencies[dependency] = column_dependencies[dependency];
      }

      //Iterate over rows, for independent columns
      for(var row = 0; row < this.cell_tree[i].length; row++){
        var cell_tree = this.cell_tree[i][row];
        var cell_dependencies = cell_tree.dependencies();
        for(dependency in cell_dependencies){
          dependencies[dependency] = cell_dependencies[dependency];
        }
      }
    }
    return dependencies;
  };

  obj.referencesSymbol = function(symbol){
    //Iterate over all headers
    for(var i = 0; i < this.columns.length; i++){
    //If header references symbol, return true
      if(this.columns[i].referencesSymbol(symbol)) return true;
      //If cell references symbol return true
      for(var row = 0; row < this.cell_tree[i].length; row++){
        if(this.cell_tree[i][row].references(symbol)) return true;
      }
    }
    return false;
  };

  obj.getParseError = function(){
    if(this.parse_error) return this.parse_error;
    return this.columns[0].getParseError(); //Only the first column is unrecoverable
  };

  obj.computeStatus = function(frame){
    if(this.getParseError()) return ERROR;
    for(var i = 0; i < this.columns.length; i++){
      //Check for un-defined, variable-like dependencies, and define them as free variables
      this.columns[i]._analysis.free_variables = []; //TODO - don't reach in to private members
      var dependencies = this.columns[i].getDependencies();
      for(var dependency in dependencies){
        if(!dependencies.hasOwnProperty(dependency)) continue;
        var arity = dependencies[dependency];
        if(arity <= 1 && !frame.defines(dependency)){
          this.columns[i].addFreeVariables([dependency]);
        }
        //TODO - if arity > 1, mark column as error.  We depend on an undefined function
      }
      this.columns[i]._analysis.status = this.columns[i].computeStatus(frame);
    }
    return GRAPHABLE;
  };

  obj.invalidate = function(){
    _super.invalidate.call(this);
    this.columns.forEach(function(column){
      column.invalidate();
    });
  };

  obj.setAnalysis = function(analysis){
    _super.setAnalysis.call(this, analysis);
    this.columns.forEach(function(column){
      column.setAnalysis({});
    });
  };

  obj.getEvaluationState = function(){
    var result;
    var num_rows = this._description.columns[0].values.length;
    var columns_data = [];
    var symbol;
    var symbols = [];
    var tmp_frame = EvalFrame(this._context.getFrame()); //Track what has been defined in previous columns
    var independent_frame = EvalFrame(this._context.getFrame());
    var frame = EvalFrame(this._context.getFrame());
    var error;
    var value;
    for(var column = 0; column < this.columns.length; column++){
      var is_independent = false;
      var is_continuous = false; //Can this be graphed at all values of the independent variable, or just graph values
      error = null;

      if(this.columns[column]._tree instanceof IdentifierNode){
        symbol = this.columns[column]._tree.identifier;
        if(!tmp_frame.defines(symbol)) is_independent = true;
        if(column === 0){
          if(!is_independent){
            error = i18n.t("First column must be independent");
          }
          if(symbol === 'y' || symbol == 'theta' || symbol == 'r'){
            error = i18n.t("We don't do the right thing for tables with independent __symbol__ yet", {symbol: symbol});
          }
          if(!error){
            independent_frame.setVariable(symbol, ConstantNode(0));  //Should never be accessed, just used to say "this is defined" based on only the independent variable
          }
        }
        if(!error){
          tmp_frame.setVariable(symbol, ConstantNode(0));  //Should never be accessed, just used to say "this is defined" based on all preceding variables
        }
        symbols[column] = symbol;
      }
      if(!is_independent){
        error = this.columns[column].getParseError();
        if(!error){
          //Check if it's continuous
          try{
            result = this.columns[column].evaluateOnce(independent_frame);
            is_continuous = true;
          }
          catch(e){
            //Unable to evaluate this at all values
            is_continuous = false;
          }
          //Check if it's dependent
          try{
            result = this.columns[column].evaluateOnce(tmp_frame);
            if(typeof result !== 'number') error = result;
          }
          catch(e){
            error = e; //Mark runtime errors that always occur at column-level
          }
        }
      }


      if(this.columns[column].getParseError()){
        this.error = this.columns[column].getParseError();
      }

      var values = [];
      if(!error){
        for(var row = 0; row < num_rows; row++){
          frame = EvalFrame(this._context.getFrame());
          for(var i = 0; i < column; i++){
            if(!columns_data[i].dependent && !columns_data[i].error){
              var independent_value = columns_data[i].values[row];
              if(typeof(independent_value) === 'number')
                frame.setVariable(symbols[i], ConstantNode(independent_value));
            }
          }
          if(is_independent){
            var tree = this.cell_tree[column][row];
            if(tree.hasOwnProperty('error_msg')) value = tree.error_msg;
            else{
              try {value = tree.evaluateOnce(frame)}
              catch(e) {value = e;}
            }
          }
          else{
            try {value = this.columns[column].evaluateOnce(frame);}
            catch(e) {value = '';}
          }
          values.push(value);
        }
      }
      var column_data = {
        dependent: !is_independent,
        discrete: !is_continuous,
        error: error,
        values: values
      };
      columns_data.push(column_data);
    }
    return columns_data;
  };

  obj.computeGraphData = function(viewState){
    
    var id, x, y, row, value;
    var datum;
    var state = this.getEvaluationState(); //TODO - cache this so we don't double-compute
    var graphData = {};
    while(this.ids_to_clean.length){
      graphData[this.ids_to_clean.pop()] = {};
    }
    //Compute points for all columns vs the first column
    for(var column = 1; column < state.length; column++){
      var column_description = this._description.columns[column];
      id = this.columns[column].id;
      if (state[column].error){
        graphData[id] = {};
      }
      graphData[id] = [];
      
      var columnMode = column_description.columnMode;
      var showPoints = columnMode === COLUMNMODE.POINTS || columnMode === COLUMNMODE.POINTS_AND_LINES;
      var showLines = columnMode === COLUMNMODE.LINES || columnMode === COLUMNMODE.POINTS_AND_LINES;
      var hidden = column_description.hidden;
      if(showPoints && !hidden){
        var segments = [];
        for(row = 0; row < state[0].values.length; row++){
          //Push points into datum
          //TODO - error checking
          x = state[0].values[row];
          y = state[column].values[row];
          if(typeof(x) === 'number' && typeof(y) === 'number'){  //Don't make points for errors
            segments.push([x, y]);
          }
        }
        datum = {
        segments: [segments],
        graphMode: GRAPHMODE.XYPOINT,
        poi: copyDefinedPOIs(segments),
        color: column_description.color,
        style: column_description.style
        };
        graphData[id].push(datum);
      }

      //Connect points if discrete
      if(showLines && !hidden && state[column].discrete){
        var accumulator = Plotter.Accumulator();
        for(row = 0; row < state[0].values.length; row++){
          //Push points into datum
          //TODO - error checking
          x = state[0].values[row];
          y = state[column].values[row];
          if(typeof(x) === 'number' && typeof(y) === 'number'){  //Don't make points for errors
            accumulator.addPoint([x, y]);
          }
          else{
            accumulator.breakSegment();
          }
        }
        datum = {
        segments: accumulator.getSegments(),
        graphMode: GRAPHMODE.PARAMETRIC,
        poi: [],
        color: column_description.color,
        style: column_description.style
        };
        graphData[id].push(datum);
      }
      
      //Plot line for non-discrete headers
      if(showLines && !hidden && !state[column].discrete){
        if(this.columns[column].getStatus() === GRAPHABLE){
          var columnGraphData = this.columns[column].computeGraphData(viewState);
          if(columnGraphData[id].length !== 1) throw 'Programming error - graphData for table columns must be singleton';
          graphData[id].push(columnGraphData[id][0]);
        }
        if(this.columns[column].getStatus() === EVALUABLE || this.columns[column].getStatus() === SILENT){
          try{
            //Make and plot temporary constant function
            value = this.columns[column].evaluateOnce(this._context.getFrame());
            var graph_info = {
              graphMode: GRAPHMODE.Y,
              independent: 'x',
              dependent: 'y',
              operator: '='
            };
            var compiled = this.compileConstantFunction(value);
            var constantGraphData = Plotter.computeGraphData(viewState, graph_info, compiled.fn);
            constantGraphData[0].compiled = compiled;

            if(constantGraphData.length !== 1) throw 'Programming error - graphData for table columns must be singleton';
            graphData[id].push(constantGraphData[0]);
          } catch(e) {
            //I'm a bit worried that there may be a case I haven't thought of that will crash the above section.
            //Protecting with a defensive try/catch to make sure it doesn't mess up the rest of the graph if someone manages to come up with it
          }
        }
      }
    }
    return graphData;
  };

  obj.compileConstantFunction = function(value){
    /*jshint evil:true */
    var compiled = {
      args: [],
      function_string: 'return ' + String(value)
    };
    compiled.fn = new Function(compiled.args, compiled.function_string);
    return compiled;
  };

  // For now, tables can only have graphMode Y. Should probably enable
  // per-branch graphModes.
  obj.getGraphInfo = function () { return { graphMode: GRAPHMODE.Y }; };
  
  obj.shouldIntersect = function () { return true; };

  obj.compileAllBranches = function (frame) {
    return this.columns.slice(1).filter(function (column) {
      return column.getStatus() === GRAPHABLE;
    }).map(function (column) {
      return column.compile(frame);
    });
  };

});

var createAnalysisObject = function(context, statement){
  switch(statement.type){
    case 'table':
      return Table(context, statement);
    case 'statement':
    case undefined: //Not a good long-term solution
      var tree = Parser.tryParse(statement.latex);
      var analysisClass = AnalysisClass[tree.statementType];
      return analysisClass(context, statement, tree);
    default:
      throw("Unrecognized statement type " + statement.type);
  }
};

return {
  createAnalysisObject: createAnalysisObject,
  status: {
    ERROR: ERROR,
    WARNING: WARNING,
    EVALUABLE: EVALUABLE,
    GRAPHABLE: GRAPHABLE,
    SILENT: SILENT
  }
};

});

//Compiles from function strings into actual functions
//Allows compiled functions to reference other functions from the same scope
//which is required, since you can't closure into "new Function()" invocations

define('math/functions',['require','underscore','pjs'],function (require) {
  var _ = require('underscore');
  var P = require('pjs');

  var FunctionCompiler = P(function(compiler){
    compiler.init = function(){
      var fn_map = {};

      this.compile = function(args, evalString){
      /*jshint evil:true*/
        var fn = new Function(args, evalString);
        return _.bind(fn, fn_map);
      };

      this.register = function(name, fn){
        fn_map[name] = fn;
      };
    };

    compiler.dehydrateGraphData = function(data){
      for (var i = 0; i < data.length; i++) {
        if (data[i].compiled) {
          delete data[i].compiled.fn;
        }
      }
    };

    compiler.rehydrateGraphData = function(data){
      for (var i = 0; i < data.length; i++) {
        if (data[i].compiled) {
          data[i].compiled.fn = this.compile(
            data[i].compiled.args,
            data[i].compiled.function_string
          );
        }
      }
    };

    compiler.updateFromFunctionMap = function(fnmap){
      for(var name in fnmap){
        if(!fnmap.hasOwnProperty(name)) continue;
        this.register(name, fnmap[name]);
      }
    };

    compiler.updateFromSourceMap = function(sourcemap){
      for(var name in sourcemap){
        if(!sourcemap.hasOwnProperty(name)) continue;
        var source = sourcemap[name];
        this.register(name, this.compile(source.args, source.source));
      }
    };
  });

  return FunctionCompiler;
});

define('math/evaluatorcontext',['require','pjs','underscore','./plotter','./evalframe','./evaluatorobject','./poi','./functions','config','graphing/graphmode','main/fake_i18n'],function(require){
  var P = require('pjs');
  var _ = require('underscore');
  var Plotter = require('./plotter');
  var EvalFrame = require('./evalframe');
  var EvaluatorObject = require('./evaluatorobject');
  var POI = require('./poi');
  var Functions = require('./functions');
  var Config = require('config');
  var GRAPHMODE = require('graphing/graphmode');

  //in the worker, use our fake i18n for now,
  //which just proxies through the english translation
  var i18n = require('main/fake_i18n');

var EvaluatorContext = P(function(context){
  
  // callback noop
  context.triggerGraphComputed = function(){};
  context.triggerStatusChange = function(){};
  context.triggerRemoveGraph = function(){};
  context.triggerRender = function(){};
  context.triggerRenderSlowly = function(){};
  context.triggerDidAddStatement = function(){};
  context.triggerDidRemoveStatement = function(){};
  context.triggerDidSetCompleteState = function(){};
  context.triggerDidSetDegreeMode = function(){};
  context.triggerDidUpdateIntersections = function () {};
  context.triggerDidUpdateFunctionMap = function() {};

  context.init = function(frame){
    if(!frame) frame = EvalFrame();
    this.parent_frame = frame;
    this.statements = {};    //Each statement should be immutable
    this.analysis = null;    //This can be cleaned out at re-derived each round
    this.current_state = {}; //Remember last sent message, so that we only update when necessary
    this.dirty = {}; //dirty[id] = True or undefined
    this.graph_changed = [];
    this.compiler = Functions();
    this.intersectIds = {};

    var fm = frame.functionMap();
    for(var name in fm){
      this.compiler.register(name, fm[name]);
    }
  };

  context.eachStatement = function(fn){
    for(var id in this.statements){
      fn.apply(this, [this.statements[id]]); //Make sure this works from within context.eachStatement blocks
    }
  };
  
  context.processChangeSet = function (changeSet) {
    var ids, triggerRender;
    
    if (changeSet.isCompleteState) {
      this.statements = {};
      this.invalidate();
    }

    // update the viewport
    if (changeSet.viewState) {
      this.setViewState(changeSet.viewState);
    }
      
    // update degree mode
    if (changeSet.hasOwnProperty('degreeMode')) {
      this.setDegreeMode(changeSet.degreeMode);
    }
      
    // change which expressions 'intersectId' attempts to intersect with
    if (changeSet.hasOwnProperty('intersectIds')) {
      this.intersectIds = changeSet.intersectIds;
    }
      
    if (changeSet.statements) {
      for (var id in changeSet.statements) {
        var statement = changeSet.statements[id];
         
        // remove the statement
        if (statement === null) {
          if (!changeSet.isCompleteState && this.statements.hasOwnProperty(id)) {
            ids = this.statements[id].getAllIds();
          }
          
          this.removeStatement(id);
           
          if (!changeSet.isCompleteState && ids) {
            for (var i = 0; i < ids.length; i++) {
              this.triggerRemoveGraph(ids[i]);
            }
            this.triggerDidRemoveStatement(id);
          }
        }
          
        // add the statement
        else {
          this.addStatement(statement);
            
          if (!changeSet.isCompleteState) {
            this.triggerDidAddStatement(statement);
          }
        }
      }
    }

    if (changeSet.hasOwnProperty('intersectId')) this.updateIntersections(changeSet.intersectId);
      
    if (changeSet.isCompleteState) {
      this.triggerDidSetCompleteState(changeSet.statements);

      //Temporarily use slow rendering callback
      triggerRender = this.triggerRender;
      this.triggerRender = this.triggerRenderSlowly;
      this.publishing_paused = false;
    }

    this.publishChanges();

    if (changeSet.isCompleteState) {
      this.triggerRender = triggerRender;
    }
  };

  context.setViewState = function (viewState) {
    if (_.isEqual(viewState, this.viewState)) return;
    this.viewState = viewState;
    this.invalidate();
  };

  context.setDegreeMode = function(use_degrees) {
    this.parent_frame.setDegreeMode(use_degrees);
    this.invalidate();
    this.triggerDidSetDegreeMode(use_degrees);
  };

  context.publishing_paused = false;
  context.changes_pending = false;

  context.pausePublishing = function(){
    //console.log("PAUSING");
    this.publishing_paused = true;
  };

  context.resumePublishing = function(){
    //console.log("RESUMING");
    this.publishing_paused = false;
    if(this.changes_pending){
      this.publishChanges();
    }
  };

  context.publishChanges = function(){
    if(this.publishing_paused){
      this.changes_pending = true;
      return;
    }

    this.changes_pending = false;
   
    this.publishAllStatuses();
    if(Plotter.validateViewState(this.viewState))
      this.graphAllChanged();
  };

  context.publishAllStatuses = function(){
    //Compute new states, but only send them out if they're different from what we sent last time
    var changes = {};
    var last_state = this.current_state;
    this.current_state = {};

    this.eachStatement(function(statement){
      var id = statement.id;
      var newState = this.getEvaluationState(id);
      if(JSON.stringify(newState) !== JSON.stringify(last_state[id])){
        changes[id] = newState;
      }
      this.current_state[id] = newState;
    });
      
    this.triggerStatusChange(changes);
  };

  context.graphAllChanged = function(){
    if (!this.graph_changed.length) return;
    var viewState = this.viewState;
    var id;
    var i;
    for (i = 0; i < this.graph_changed.length; i++) {
      id = this.graph_changed[i];
      if (!this.statements.hasOwnProperty(id)) continue;
      if (this.statements[id].isGraphed()) {
        this.graph(id, viewState);
      } else {
        this.triggerRemoveGraph(id);
      }
    }
    
    var graphChangedSet = {};
    for (i = 0; i < this.graph_changed.length; i++) {
      graphChangedSet[this.graph_changed[i]] = true;
    }
    this.graph_changed = [];
    
    // Recompute all visible intersections for curves that weren't regraphed.
    // Curves that were regraphed already had their intersections updated in
    // the graph routine. Need to do this because we're only keeping track of
    // one partner in an intersection, and the other partner might have
    // changed.
    for (id in this.intersectIds) {
      if (!this.intersectIds.hasOwnProperty(id)) continue;
      if (graphChangedSet.hasOwnProperty(id)) continue;
      this.updateIntersections(id);
    }
    
    this.triggerRender();
  };

  //TODO - delegate to statement objects
  context.graph = function (id, viewState) {
    if(!viewState){
      //console.log("No view state.  Not graphing");
      return;
    }

    var statement = this.statements[id];
    var graphData = statement.computeGraphData(viewState);

    if (
      this.intersectIds.hasOwnProperty(id) &&
      statement.shouldIntersect() &&
      graphData.hasOwnProperty(id) // TODO bails on intersecting tables
    ) {
      var someIntersections = this.findSomeIntersectionsWith(id);
      
      for (var branch = 0; branch < someIntersections.intersections.length; branch++) {
        graphData[id][branch].poi.intersections = someIntersections.intersections[branch];
      }
      // If we ran out of time to compute all the intersections, stream the
      // rest of them back to the grapher as we have time.
      someIntersections.streamRest();
    }
    
    for(var sketch_id in graphData){
      this.triggerGraphComputed(sketch_id, graphData[sketch_id]);
    }
  };

  // Find all intersections between a curve with the given id and other
  // curves.
  context.updateIntersections = function (id) {
    var statement = this.statements[id];

    if (!statement || !statement.shouldIntersect()) {
      this.triggerDidUpdateIntersections(id, []);
      return;
    }

    this.findSomeIntersectionsWith(id).streamRest();

  };

  // context.findSomeIntersectionsWith computes as many intersections with the
  // curve with given id as it can in 20 ms and then returns an object:
  // {
  //   intersections: // Intersections found so far
  //   streamRest: // Function that will stream the rest of the intersections
  //               // back to the grapher.
  // }
  //
  // We run a different timeout for every curve id that is having
  // having intersections computed on it so that we can start computing
  // intersections with a few curves at once without having them cancel
  // eachother. This will happen if you open intersections on a few different
  // curves and then change something that triggers a graphAll.
  //
  // Note that we typically only stick the intersection POI on one of the two
  // curves that is involved in an intersection (the one that was selected
  // when the intersection was computed).
  var streamIntersectionsTimeouts = {};
  context.findSomeIntersectionsWith = function (id1) {
    this.cancelIntersectionStreaming(id1);
    
    var runFor = 20; // ms
    var waitFor = 60; // ms
    var self = this;
    var push = Array.prototype.push;
    var statement1 = self.statements[id1];
    var graph_info = statement1.getGraphInfo();
    var graphMode = graph_info.graphMode;
    var compiled1 = self.statements[id1].compileAllBranches(self.getFrame());
    var domain = Plotter.computeDomain(self.viewState, graph_info, null);
    
    var otherStatements = [];
    for (var id2 in self.statements) {
      if (!self.statements.hasOwnProperty(id2)) continue;
      if (String(id2) === String(id1)) continue;
      otherStatements.push(self.statements[id2]);
    }
    
    // intersections accumulator and iterator i are modified during successive
    // calls to computeSome()
    var intersections = [];
    for (var branch = 0; branch < compiled1.length; branch++) {
      intersections[branch] = { x: [], y: [], intersects: [] };
    }
    var i = otherStatements.length - 1;
    var stream = false;
    var computeSome = function () {
      /*jshint loopfunc: true */
      var now = new Date();
      var updated = false;
      var fn1;
      var fn2;
      var newIntersections;
      var statement2;
      var compiled2;
      var swap;
      var differenceSamples;
      for (i; i >= 0; i--) {
        if (new Date() - now > runFor) {
          if (!stream) return;
          streamIntersectionsTimeouts[id1] = setTimeout(computeSome, waitFor);
          if (!updated) return;
          self.triggerDidUpdateIntersections(id1, intersections);
          return;
        }
        statement2 = otherStatements[i];
        if (!statement2.shouldIntersect()) continue;
        if (statement2.getGraphInfo().graphMode !== graphMode) continue;

        compiled2 = statement2.compileAllBranches(self.getFrame());

        for (var branch1=0; branch1 < compiled1.length; branch1++) {
          fn1 = compiled1[branch1].fn;
          for (var branch2 = 0; branch2 < compiled2.length; branch2++) {
            fn2 = compiled2[branch2].fn;
            differenceSamples = Plotter.sampleXY(function (x) {
              return fn2(x) - fn1(x);
            }, domain);
            newIntersections = POI.findIntersections(
              differenceSamples,
              fn1,
              fn2
            );
            if (newIntersections.x.length) updated = true;
            newIntersections.intersects = Array(newIntersections.x.length);
            for (var j = 0, jlen = newIntersections.x.length; j < jlen; j++) {
              newIntersections.intersects[j] = statement2.id;
            }
            // Need to swap x and y if graphmode is GRAPHMODE.X
            if (graphMode === GRAPHMODE.X) {
              swap = newIntersections.y;
              newIntersections.y = newIntersections.x;
              newIntersections.x = swap;
            }
            push.apply(intersections[branch1].x, newIntersections.x);
            push.apply(intersections[branch1].y, newIntersections.y);
            push.apply(intersections[branch1].intersects, newIntersections.intersects);
          }
        }
      }
      
      if (!stream || !updated) return;
      self.triggerDidUpdateIntersections(id1, intersections);
      self.cancelIntersectionStreaming(id1);
    };

    computeSome();

    return {
      intersections: intersections,
      streamRest: function () {
        // Slightly wasteful, but handy for clearing old intersections early.
        self.triggerDidUpdateIntersections(id1, intersections);
        stream = true;
        computeSome();
      }
    };

  };
  
  context.cancelIntersectionStreaming = function (id) {
    clearTimeout(streamIntersectionsTimeouts[id]);
    delete streamIntersectionsTimeouts[id];
  };

  context.cancelAllIntersectionStreaming = function () {
    for (var id in streamIntersectionsTimeouts[id]) {
      if (!streamIntersectionsTimeouts.hasOwnProperty(id)) continue;
      this.cancelIntersectionStreaming(id);
    }
  };

  //Takes a object representing an "expression" (TODO - rename this concept)
  //Expects expr to have properties:
  // * id (integer)
  // * latex (string)
  // * shouldGraph (boolean)
  // * color (string)
  context.addStatement = function(statement){
    if(!statement) return;
    var id = statement.id;
    this.markDirty(id); // Mark existing dependencies as dirty

    var previous_ids;  //Used to tell tables to ungraph old columns

    if(this.statements.hasOwnProperty(id)){
      previous_ids = this.statements[id].getAllIds();
    }

    this.statements[id] = EvaluatorObject.createAnalysisObject(this, statement);
    
    if(previous_ids){
      for(var i = 0; i< previous_ids.length; i++){
        var previous_id = previous_ids[i];
        if(previous_id != id){
          this.statements[id].cleanupId(previous_id);
        }
      }
    }
    // Need to mark clean before marking dirty again because otherwise we'll
    // hit an early return and fail to mark new dependencies dirty.
    this.markClean(statement.id);
    this.markDirty(statement.id); // Mark any new dependencies as dirty
  };

  context.removeStatement = function(id){
    if(!this.statements.hasOwnProperty(id)) return;
    // Looks like it was already deleted.
    // This happens when a table is deleted, and then each column is deleted.

    this.markDirty(id); //Mark dirty before deletion
    delete this.statements[id];
  };

  context.recompute = function(){
    this.invalidate();
    this.publishChanges();
  };

  context.invalidate = function(){
    this.analysis = null;
    this.current_state = {};
    this.cancelAllIntersectionStreaming();
  };

  context.markDirty = function(id){
    if(this.dirty[id]) return;
    this.dirty[id] = true;
    this.cancelIntersectionStreaming(id);
    //symbols which id exports
    if (!this.statements[id]) return;
    for(var symbol in this.statements[id].exportedSymbols()){
      this.markSymbolDirty(symbol);
    }
  };

  context.markSymbolDirty = function(symbol){
    if(this.assignmentForbidden(symbol)) return;
    this.eachStatement(function(statement){
      if(statement.referencesSymbol(symbol)){
        this.markDirty(statement.id);
      }
    });
  };

  context.markClean = function(id){
    delete(this.dirty[id]);
  };

  context.isDirty = function(id){
    return this.dirty.hasOwnProperty(id);
  };

  context.getFrame = function(){
    //Return frame, updating if necessary.
    return this.getAnalysis().frame;
  };

  context.getAnalysis = function(){
    this.updateAnalysis();
    return this.analysis;
  };

  context.getType = function(id){
    return this.statements[id].getType();
  };

  context.updateAnalysis = function(){
    if(this.hasOwnProperty('partial_analysis')) throw "Programming error - two overlapping call to updateAnalysis";
    
    var dirty_statements = [];
    var id;
    if(this.analysis){
      for(id in this.dirty){
        dirty_statements.push(id);
      }
      //If we already have analysis and nothing is dirty, return
      if(dirty_statements.length === 0) return;
    }
    else{
      for(id in this.statements){
        dirty_statements.push(id);
      }
    }

    //For a first pass, re-run the analysis for everything (since that's cheap), only graph dirty statements
    delete(this.analysis);
    this.partial_analysis = {};
    var a = this.partial_analysis;
    try{

      a.frame = EvalFrame(this.parent_frame);

      this.eachStatement(function(statement){
        var id = statement.id;
        a[id] = {};
        statement.setAnalysis(a[id]);
        var error = statement.getParseError();
        if(error) a[id].error = error;
      });

      a.assignments = this.analyzeAssignments();
      this.markVariableConflicts(a.assignments);

      this.analyzeDependencies(a);

      for (var i = 0; i < a.dependencyOrder.length; i++) {
        id = a.dependencyOrder[i];
        this.statements[id].exportDefinitionsTo(a.frame, id);
      }

      this.graph_changed = dirty_statements;
      this.dirty = {};

      var fm = a.frame.leafFunctionMap(); //Only update new functions, nothing from parent frame
      for(var name in fm){
        this.compiler.register(name, fm[name]);
      }
      //Used to send function definitions from worker to UI thread for tracing
      this.triggerDidUpdateFunctionMap(a.frame);

      this.analyzeStatus(a);

      if (Config.get('dragpoints')) {
        // Need to do this after analyzeStatus because we need to know which
        // variables are slidable in order to know which statements are movable
        this.analyzeMovable(a);
      }
      
      //Mark analysis as done, and make it active
      this.analysis = this.partial_analysis;
    }
    catch(e){
      //Error in analysis - invalidate everything so that we don't persist anything
      this.invalidate();
    }
    finally{
      //No matter what, partial_analysis should dissapear
      delete(this.partial_analysis);
    }
  };

  context.evaluateOnce = function(id){
    if(!this.statements.hasOwnProperty(id)) {throw('Statement ' + id + ' not defined');}
    return this.statements[id].evaluateOnce(this.getFrame());
  };

  context.compile = function(id){
    return this.statements[id].compile(this.getFrame());
  };

  context.evalStrings = function(id){
    return this.statements[id].evalStrings(this.getFrame());
  };

  context.analyzeStatus = function(a){
    this.eachStatement(function(statement){
      var id = statement.id;
      var s = this.partial_analysis[id];
      if(s.error) s.status = EvaluatorObject.status.ERROR;
      if(s.status) return;
      s.status = statement.computeStatus(a.frame);
    });
  };

  context.assignmentForbidden = function(identifier){
    return (identifier === 'x' || identifier === 'y' || identifier === 'theta');
  };

  context.getStatus = function(id){
    if (this.getAnalysis()[id] === undefined)
      return undefined;
    return this.getAnalysis()[id].status;
  };

  //Returns an object that mirrors the API of Formula
  context.getEvaluationState = function(id){
    this.getAnalysis(); // Used for side-effects
    return this.statements[id].getEvaluationState();
  };

//Analyzing dependencies
     //Iterate over all definitions to identify multiple-definitions and mark defined identifiers with type
        //Multiple definitions are OK, as long as they are not referenced
     //Scan all statements, recording dependencies as free variables, or defined functions/variables
        //During this scan, drop out any equations which reference multiply-defined identifiers
        //During this scan, build data-structure for dependency DAG
     //Crawl data-structure, to create evaluation ordering with clean dependencies
     //Identify cycles in remaining statements, and mark those as errors
     //Return clean ordering, to be used in frame generation and compilation

  context.analyzeAssignments = function(){
    var assignments = {};
    this.eachStatement(function(statement){
      var exports = statement.exportedSymbols();
      for(var symbol in exports){
        if(this.assignmentForbidden(symbol)) continue; //Nobody gets to assign x or y globally
        if(this.parent_frame && this.parent_frame.defines(symbol)){
          statement.markError(i18n.t("Cannot redefine __symbol__", {symbol: symbol}));
          continue;
        }
        if(!assignments.hasOwnProperty(symbol)) {assignments[symbol] = []}
        assignments[symbol].push({id:statement.id, arity:exports[symbol]});
      }
    });
    return assignments;
  };

  context.markVariableConflicts = function(assignments){
    this.eachStatement(function(statement){
      var shadowed = statement.shadowedSymbols();
      for(var i = 0; i < shadowed.length; i++){
        var symbol = shadowed[i];
        if(assignments.hasOwnProperty(symbol)){
          // TODO - define this error message
          // '"' + conflicts[0] + '" is already defined, so you can\'t use it as one of the parameters of this function.
          // You could try a different letter, or using a subscript.';
          statement.conflictError(symbol);
        }
      }
    });
  };

  //Returns dependency-ordered sequence of statement ids
  context.analyzeDependencies = function(a){
    var order = [];       //The IDs of the sequence (built up incrementally)
    var ready = [];       //IDs of which statements are ready to add to the sequence
    var block_count = {}; //IDs of blocked statments are keys => number of blockers.
    var blocked_on = {};  //Term string are keys => IDs of blocked statements;

    //Note - for now, the same term can show up as a blocker multiple times for the same statement.
    //This is correct, but could become inefficient.  We might want to make the dependency lists unique.

    //Initialize data structure to be able to query DAG efficiently
    for (var id in this.statements){
      var s = a[id];
      s.free_variables = [];
      if(!this.statements.hasOwnProperty(id)) continue;
      //Track dependencies
      var dependencies = this.statements[id].getDependencies();
      block_count[id] = 0;
      for(var dependency in dependencies){
        if (!dependencies.hasOwnProperty(dependency)){continue;}
        var dependency_arity = dependencies[dependency];

        if(this.parent_frame){
          //If we're looking for a variable and the parent defines it, we're good (arity 1 could be either)
          if((dependency_arity <= 1) && this.parent_frame.hasVariable(dependency)) {
            continue;
          }

          //If we're looking or a function with specific arity and the parent defines it, we're good
          if((dependency_arity >= 1) && this.parent_frame.hasFunctionWithArity(dependency, dependency_arity)){
            continue;
          }
        }

        var assigners = a.assignments[dependency];  //List of IDs for statements which define dependency
        //0 assigners => free variable or error, if it's a function
        if(this.parent_frame && this.parent_frame.defines(dependency)){
          var real_arity = this.parent_frame.arity(dependency);
          if(real_arity === 0){
            s.error = i18n.t("Cannot call constant __dependency__ as a function", {dependency: dependency});
          }
          if(real_arity > 0){
            s.error = i18n.t(
              "__dependency__ is a function that requires __real_arity__ arguments",
              {
                dependency: dependency,
                real_arity: real_arity
              }
            );
          }
          else{
            s.error = i18n.t("Something has gone wrong.  Please report this to desmos.com support");
          }
          continue;
        }
        if(!assigners || assigners.length === 0){
          if (dependency_arity <= 1){
            this.statements[id].addFreeVariables([dependency]);
          }
          else{
            s.error = i18n.t(
              "Function __dependency__ isn't defined. Try defining it in a new expression",
              {
                dependency: dependency
              }
            );
          }
        }

        //1 => possibly healthy dependency
        if(assigners && assigners.length === 1){
          var assignment_arity = assigners[0].arity;

          if (
            // Check if assignment has the same arity as our dependency
            assignment_arity === dependency_arity ||
            // Ambiguous dependency can be resolved with arity 1 function or variable.
            (assignment_arity === 0 && dependency_arity === 1)
          ) {

            if(!blocked_on.hasOwnProperty(dependency)) { blocked_on[dependency] = []; } //create list if empty

            blocked_on[dependency].push(id);
            block_count[id]++;
          }
          else if (assignment_arity === 0) {
            s.error = (i18n.t(
              "'__dependency__' is a variable, so can't be used as a function",
              {dependency: dependency}
            ));

          } else if (assignment_arity == 1) {
            s.error = (
              i18n.t(
                'Function \'__dependency__\' requires an argument. ',
                { dependency: dependency }
              ) + i18n.t(
                'For example, try typing: __dependency__(x)',
                {dependency: dependency}
              )
            );
          } else {
            var args = [];
            //construct an example of using the function
            for (var i = 0 ; i < assignment_arity ; i++) {args[i] = i+1; }
            var recommendation = dependency + "(" + args.join(", ") + ")";

            s.error = (
              i18n.t(
                'Function \'__dependency__\' requires __assignment_arity__ arguments. ',
                {
                  dependency: dependency,
                  assignment_arity: assignment_arity
                }
              ) + i18n.t('For example, try typing: __recommendation__', {recommendation: recommendation})
            );
          }
        }
        //>1 => dependency on an ambiguous term
        if(assigners && assigners.length > 1){
          s.error = (i18n.t(
            "'__dependency__' is defined more than once. Try deleting all but one definition of '__dependency__'",
            {dependency: dependency}
          ));
          //TODO - put errors or warning on all assigners as well
        }
      }
      if (block_count[id] === 0){
        ready.push(id);
      }
    }

    //Keep pulling from ready list until it's empty (either we're done, or we can't finish)
    while(ready.length){
      var next = ready.pop();
      if(a[next].error){
        // TODO Mark dependencies as errors for depending on it - currently just letting them fail the same as circular
        // dependencies
        continue;
      }
      order.push(next);
      var exported = this.statements[next].exportedSymbols();
      for(var symbol in exported){
        var unblocked_list = blocked_on[symbol];
        if(!unblocked_list) continue;  //Doesn't unblock anything else

        while(unblocked_list.length){
          var unblocked = unblocked_list.pop();
          this.statements[unblocked].addFreeVariables(a[next].free_variables);
          block_count[unblocked]--;      //Unblocks everything that depends on whatever next defines
          if (block_count[unblocked] === 0){
            delete block_count[unblocked];
            ready.push(unblocked);
          }
        }
      }
    }

    for(id in block_count){
      if(block_count.hasOwnProperty(id) && block_count[id] !== 0){
        a[id].unresolved = true;
        a[id].error = i18n.t("Circular dependency");
      }
    }

    a.dependencyOrder = order;
  };

  context.analyzeMovable = function (a) {
    this.eachStatement(function (statement) {
      if (statement.computeMovable) statement.computeMovable(a.frame);
    });
  };

});

return EvaluatorContext;

});
define('worker/workercore',['require','math/evaluatorcontext','math/builtinframe','math/derivative'],function(require){
  var EvaluatorContext = require('math/evaluatorcontext');
  var BuiltInFrame = require('math/builtinframe');
  require('math/derivative');

  return function(sendMessage){

    //Initialize environment
    var context = EvaluatorContext(BuiltInFrame);

    //Functions to send data back to main thread
    context.triggerGraphComputed = function(id, data){
      //Can't pass function objects across worker boundary.  Will re-create on other side
      for(var i = 0; i < data.length; i++){
        if(data[i].compiled) delete data[i].compiled.fn;
      }
      sendMessage('graphComputed', {id:id, graphData:data});
    };

    context.triggerDidUpdateIntersections = function(id, intersections) {
      sendMessage('updateIntersections', {id:id, intersections:intersections});
    };

    context.triggerDidUpdateFunctionMap = function(frame){
      sendMessage('updateFunctionMap', frame.leafFunctionSourceMap());
    };

    context.triggerRender = function(){
      sendMessage('render');
    };

    context.triggerRenderSlowly = function(){
      sendMessage('renderSlowly');
    };

    context.triggerRemoveGraph = function(id){
      sendMessage('removeGraph', id);
    };

    context.triggerDidSetDegreeMode = function(use_degrees){
      sendMessage('setDegreeMode', use_degrees);
    };

    context.triggerStatusChange = function(data){
      sendMessage('statusChange', data);
    };
    
    return {
      processChangeSet: function (changeSet) {
        context.processChangeSet(changeSet);
        
        sendMessage('processChangeSet', changeSet);
      }
    };
    
  };

});

define('worker/fakeworker',['require','worker/workercore'],function(require){
  var WorkerCore = require('worker/workercore');

  return function(messageListener){
    var fakeWorker = {};
    var workerCore = WorkerCore(sendMessage);
    
    //Handle message from worker to UI thread
    function sendMessage(type, payload){
      messageListener({data:{type:type, payload:payload}});
    }

    //Handle messages from UI thread to worker
    fakeWorker.postMessage = function(e){
      setTimeout(function(){
        workerCore.processChangeSet(e);
      }, 0);
    };

    return fakeWorker;
  };
});

define('api/cross_origin_worker',['require'],function(require) {
  return function (workerURL, Config) {
    var location = window.location;
    var a = document.createElement('a');
    a.href = workerURL;

    var configString = JSON.stringify(Config.all());

    if (a.protocol === location.protocol && a.host === location.host) {
      return workerURL + '?desmos_config=' + encodeURIComponent(configString);
    }

    var loadConfig =
      'Desmos = {}; Desmos.config = JSON.parse(\'' + configString + '\');'
    ;

    var importString = 'importScripts(\'' + workerURL + '\');';

    var codeString = loadConfig + importString;

    var blob;
    try {
      blob = new Blob([codeString], {type : 'application/javascript'});
    } catch (e) {
      var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
      var blobBuilder = new BlobBuilder();
      blobBuilder.append(codeString);
      blob = blobBuilder.getBlob('application/javascript');
    }

    var URL = window.URL || window.webkitURL;
    return URL.createObjectURL(blob);
  };
});
define('main/evaluator',['require','pjs','math/builtinframe','worker/fakeworker','math/functions','api/cross_origin_worker','config'],function (require) {
  var P = require('pjs');
  var BuiltInFrame = require('math/builtinframe');
  var FakeWorker = require('worker/fakeworker');
  var Functions = require('math/functions');
  var crossOriginWorkerURL = require('api/cross_origin_worker');
  var Config = require('config');

var Evaluator = P(function (evaluator) {
  
  // Overwritten in calc.js
  evaluator.triggerStatusChange = function (changes) {};
  evaluator.triggerRemove = function (id) {};
  evaluator.triggerGraphComputed = function (id, graphData) {};
  evaluator.triggerUpdateIntersections = function (id, intersections) {};
  evaluator.triggerRender = function () {};
  evaluator.triggerRenderSlowly = function () {};

  evaluator.init = function (workerPath) {
    this.functions = Functions();
    this.changeSet = null;
    this.jobsInWorker = 0;
    this.syncId = 1;
    this.processingDisabled = false;

    var useFakeWorker = function () {
      this.worker = FakeWorker(this.processMessage.bind(this));
      this.spawnNewWorker = function () {};
    }.bind(this);

    if (workerPath) {
      try {
        this.workerPath = crossOriginWorkerURL(workerPath, Config);
        this.spawnNewWorker();
      } catch (e) {
        // Fallback when we can't support real workers. Can happen if
        // 1. window.Worker does not exist (IE < 10)
        // 2. We're working cross domain and the browser can't build Blobs.
        //    (for the API; all versions of IE I've been able to test)
        useFakeWorker();
      }
    } else {
      // Used in unit tests when it's inconvenient to specify a worker path.
      useFakeWorker();
    }

    

    this.syncRequests = [];

    this.listeners.setDegreeMode = function (use_degrees) {
      BuiltInFrame.setDegreeMode(use_degrees);
    };

    this.functions.updateFromFunctionMap(BuiltInFrame.functionMap());
  };

  evaluator.spawnNewWorker = function () {
    //Kill current worker if we have one
    if (this.worker) {
      this.worker.terminate();
    }
    this.worker = new Worker(this.workerPath);
    this.worker.addEventListener('message', this.processMessage.bind(this));
    this.worker.onerror = function (evt) {};
    this.jobsInWorker = 0;
  };

  evaluator.processMessage = function (e) {
    //console.log("Recieved " + e.data.type + " message of length " + JSON.stringify(e.data).length);
    this.listeners[e.data.type].call(this, e.data.payload);
  };

  evaluator.listeners = {};
  
  evaluator.listeners.processChangeSet = function (changeSet) {
    var syncId = changeSet.syncId;
    
    // find all waiting sync ids <= syncId and call callback
    while (this.syncRequests.length && this.syncRequests[0].id <= syncId) {
      var syncRequest = this.syncRequests.shift();
      syncRequest.callback();
    }
        
    // try to send another job in
    this.jobsInWorker--;
    this.processChangeSet();
  };

  evaluator.listeners.log = function (msg) {  };

  evaluator.listeners.removeGraph = function (id) {
    this.triggerRemove(id);
  };

  evaluator.listeners.graphComputed = function (payload) {
    this.functions.rehydrateGraphData(payload.graphData);
    this.triggerGraphComputed(payload.id, payload.graphData);
  };

  evaluator.listeners.updateFunctionMap = function (sourceFunctionMap) {
    this.functions.updateFromSourceMap(sourceFunctionMap);
  };

  evaluator.listeners.updateIntersections = function (payload) {
    this.triggerUpdateIntersections(payload.id, payload.intersections);
  };

  evaluator.listeners.statusChange = function (changes) {
    //Updates to status of expression-list items
    this.triggerStatusChange(changes);
  };

  evaluator.listeners.render = function () {
    this.triggerRender();
  };

  evaluator.listeners.renderSlowly = function () {
    this.triggerRenderSlowly();
  };
  
  evaluator._disableProcessing = function () {
    this.processingDisabled = true;
  };
  
  evaluator._enableProcessing = function () {
    this.processingDisabled = false;
    this.processChangeSet();
  };

  // Allows multiple messages to be pushed onto a changeset without
  // intermediate processing.
  evaluator.batch = function (fn) {
    var alreadyDisabled = this.processingDisabled;
    this._disableProcessing();
    try{
      fn();
    }
    finally{
      // Want to make sure that if calls to evaluator.batch are nested, only the
      // outermost call reenables processing.
      if (!alreadyDisabled) this._enableProcessing();
    }
  };

  //Set up outgoing communication to worker
  evaluator.processChangeSet = function(){
    if (!this.changeSet) return;
    if (this.processingDisabled) return;
    if (this.jobsInWorker > 0) return;

    var changeSet = this.changeSet;

    // one more job is in worker; changes have been processed
    this.jobsInWorker++;
    this.changeSet = null;

    this.worker.postMessage(changeSet);
  };

  // Wrap a function in a check that this.changeSet exists before call to
  // this.processChangeSet() after.
  var withChangeSet = function (fn) {
    return function () {
      if (!this.changeSet) this.changeSet = {};
      fn.apply(this, arguments);
      this.processChangeSet();
    };
  };

  evaluator.setViewState = withChangeSet(function (viewState) {
    this.changeSet.viewState = viewState;
  });

  evaluator.setCompleteState = withChangeSet(function (statements) {
    if (this.jobsInWorker > 0) this.spawnNewWorker();
    this.changeSet.isCompleteState = true;
    this.changeSet.statements = statements;
  });

  //Takes a object representing an "expression" (TODO - rename this concept)
  //Expects expr to have properties:
  // * id (integer)
  // * latex (string)
  // * shouldGraph (boolean)
  // * color (string)
  evaluator.addStatement = withChangeSet(function (statement) {
    if (!this.changeSet.statements) this.changeSet.statements = {};
    this.changeSet.statements[statement.id] = statement;
  });
  
  evaluator.addStatements = withChangeSet(function (statements) {
    for (var i=0; i < statements.length; i++) {
      this.addStatement(statements[i]);
    }
  });

  evaluator.removeStatement = withChangeSet(function (id) {
    if (!this.changeSet.statements) this.changeSet.statements = {};
    this.changeSet.statements[id] = null;
  });

  evaluator.removeStatements = withChangeSet(function (ids) {
    for (var i = 0; i < ids.length; i++) {
      this.removeStatement(ids[i]);
    }
  });

  // TODO - rename setIntersectIds and updateIntersections. They trip
  // me up every time.
  evaluator.setIntersectIds = withChangeSet(function (intersectIds) {
    this.changeSet.intersectIds = intersectIds;
  });

  evaluator.updateIntersections = withChangeSet(function (id) {
    this.changeSet.intersectId = id;
  });

  evaluator.setDegreeMode = withChangeSet(function (use_degrees) {
    this.changeSet.degreeMode = use_degrees;
  });

  evaluator.notifyWhenSynced = withChangeSet(function (callback) {
    this.syncId++;
    
    //Put the request in a list
    this.syncRequests.push({id: this.syncId, callback: callback});
    
    // send sync request to worker. when it comes back, we'll call the
    // callback
    this.changeSet.syncId = this.syncId;
  });

});

return Evaluator;
});

define('lib/browser',['require','jquery'],function (require) {
  var $ = require('jquery');

  var Browser = {
    IS_IE8: navigator.userAgent.match(/MSIE 8.0/i) !== null,
    IS_IE9: navigator.userAgent.match(/MSIE 9.0/i) !== null,
    IS_IE: navigator.userAgent.match(/MSIE/i) !== null,
    IS_IPAD: navigator.userAgent.match(/iPad/i) !== null,
    IS_MOBILE: navigator.userAgent.match(/Mobile|Android/i) !== null,
    IS_ANDROID: navigator.userAgent.match(/Android/i) !== null,
    IS_KINDLE: navigator.userAgent.match(/Kindle/i) !== null || navigator.userAgent.match(/Silk/i) !== null,
    IS_IN_IFRAME: window.parent !== window
  };

    // Need to detet opera less than 12 because the implementation of webworkers
    // there breaks.
  Browser.IS_OPERA_LT_12 = (function () {
    if (!navigator.userAgent.match(/OPERA/i)) return false;

    var match = navigator.userAgent.match(/Version\/(\d+)/);
    if (!(match && match[1])) return false;

    var operaVersion = parseInt(match[1], 10);
    return operaVersion < 12;
  })();

  // Returns translate3d if supported, translate otherwise
  // from http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support
  //
  // Needs document.body to be defined before it can run (so that we can put
  // an element into it). In supported browsers, the value will be set to
  // true on $(document).ready();
  Browser.SUPPORTS_TRANSLATE3D = false;
  
  $(document).ready(function() {

    var el = document.createElement('p');
    var has3d;
    var computedStyle;
    var transforms = {
      'webkitTransform':'-webkit-transform',
      'OTransform':'-o-transform',
      'msTransform':'-ms-transform',
      'MozTransform':'-moz-transform',
      'transform':'transform'
    };
    // Add it to the body to get the computed style.
    document.body.insertBefore(el, null);
    for (var t in transforms) {
      if (el.style[t] !== undefined) {
        el.style[t] = "translate3d(1px,1px,1px)";
        computedStyle = window.getComputedStyle(el);
        if (!computedStyle) return;
        has3d = computedStyle.getPropertyValue(transforms[t]);
      }
    }
    document.body.removeChild(el);
    Browser.SUPPORTS_TRANSLATE3D = (
      has3d !== undefined &&
      has3d.length > 0 &&
      has3d !== "none"
    );
  });
  
  //return a generated rule for an x-y translation. use translate3d where supported
  Browser.translateRule = function(x, y) {
    if (Browser.SUPPORTS_TRANSLATE3D) {
      return "translate3d(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ",0)";
    }
    return "translate(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ")";
  };

  Browser.CAPABLE_BROWSER = (function () {
    var is_too_small = false;
    // Our interface doesn't work on phone-size devices.
    if (window.matchMedia) {
    var mq = window.matchMedia("(max-device-width:480px)");
    if (mq && mq.matches) is_too_small = true;
    } else if (Browser.IS_ANDROID) {
    // Assume Android devices without matchMedia are too small.
    is_too_small = true;
    }

    var elem = document.createElement('canvas');
    var supports_canvas = !!(elem.getContext && elem.getContext('2d'));
    
    //we don't support iOS3 (which requires svg for fonts)
    var is_iOS3 = (Browser.IS_IPAD && (navigator.userAgent.match(/OS 3/i) !== null));

    return ((supports_canvas) && !(is_too_small || Browser.IS_KINDLE || is_iOS3));
  })();

  return Browser;
});

define('lib/rounding',['require','math/distance'],function(require){
  var Distance = require('math/distance');

  var digitRound = function (x, places) {
    var pow10 = Math.pow(10, places);
    return (Math.round(x * pow10) / pow10);
  };

  var Rounding = {
    bestRound: function (x, pixel_units, pixel_precision) {
      pixel_precision = pixel_precision || 1;

      //figure out how decimal places we can afford to round to
      var decimal_places = -Math.floor(Math.log(pixel_units) / Math.LN10);

      //round to that many decimal places
      var better_x = digitRound(x, decimal_places);

      //now we also want to check if we're within pixel_precision of one of
      //the *good* roundings
      var test_rounded_x = digitRound(x, decimal_places - 2);
      if (Math.abs(test_rounded_x - x) < pixel_precision * pixel_units) {
        better_x = test_rounded_x;
      }

      //good to go, return it
      return better_x;
    },

    shortestDecimalBetween: function(a, b){
      if(a > b){
        var tmp = b;
        b = a;
        a = tmp;
      }
      if(a === b) return a;
      if(a <= 0 && 0 <= b) return 0;
      var c = Distance.mean(a,b);
      var exponent = -8;
      var best = c;
      while(exponent < 309){ //1e309 is infinity
        var denom = Math.pow(10, -exponent);
        var mantissa = Math.round(c*denom);
        var rounded_c = mantissa/denom;

        var valid = (a <= rounded_c && rounded_c <= b);
        if(!valid) break;
        best = rounded_c;
        exponent += 1;
      }
      return best;
    }
  };

  return Rounding;
});

define('graphing/viewport',['require','lib/rounding'],function (require) {
  var Rounding = require('lib/rounding');

  function Viewport (xmin, xmax, ymin, ymax) {
    this.xmin = xmin !== undefined ? xmin : -10;
    this.xmax = xmax !== undefined ? xmax :  10;
    this.ymin = ymin !== undefined ? ymin : -10;
    this.ymax = ymax !== undefined ? ymax :  10;
  }

  Viewport.prototype.toObject = function () {
    return {
      xmin: this.xmin,
      ymin: this.ymin,
      xmax: this.xmax,
      ymax: this.ymax
    };
  };

  Viewport.fromObject = function (obj) {
    return new Viewport(obj.xmin, obj.xmax, obj.ymin, obj.ymax);
  };

  Viewport.prototype.equals = function (viewport) {
    if (this.xmin !== viewport.xmin) return false;
    if (this.ymin !== viewport.ymin) return false;
    if (this.xmax !== viewport.xmax) return false;
    if (this.ymax !== viewport.ymax) return false;

    return true;
  };

  Viewport.prototype.isXValid = function() {
    return (this.xmax - this.xmin > 0);
  };

  Viewport.prototype.isYValid = function() {
    return (this.ymax - this.ymin > 0);
  };

  Viewport.prototype.isValid = function () {
    return this.isXValid() && this.isYValid();
  };

  Viewport.prototype.isSquare = function (screen) {
    return Math.abs(screen.height - screen.width*this.aspectRatio()) < 1;
  };

  Viewport.prototype.aspectRatio = function () {
    return (this.ymax-this.ymin)/(this.xmax-this.xmin);
  };

  Viewport.prototype.squareXAxis = function (screen) {
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;
    var xcenter = this.xmin + xrange/2;
    var new_xrange = yrange/screen.height * screen.width;

    this.xmin = xcenter - new_xrange/2;
    this.xmax = xcenter + new_xrange/2;
  };

  Viewport.prototype.squareYAxis = function (screen) {
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;
    var ycenter = this.ymin + yrange/2;
    var new_yrange = xrange/screen.width * screen.height;

    this.ymin = ycenter - new_yrange/2;
    this.ymax = ycenter + new_yrange/2;
  };

  Viewport.prototype.squareCrop = function (screen) {
    // Square axes in a way that is guaranteed to reduce the viewport
    if (this.aspectRatio() > screen.height/screen.width) {
      this.squareYAxis(screen);
    } else {
      this.squareXAxis(screen);
    }
  };

  // rounds the viewport so that it's not more precise than a pixel
  Viewport.prototype.round = function (screen) {
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;

    var x_pixel_units = xrange/screen.width;
    var y_pixel_units = yrange/screen.height;

    // Do things this way to try to maintain xrange and yrange when panning.
    this.xmin = Rounding.bestRound(this.xmin, x_pixel_units/10);
    this.xmax = Rounding.bestRound(this.xmin + xrange, x_pixel_units/10);
    this.ymin = Rounding.bestRound(this.ymin, y_pixel_units/10);
    this.ymax = Rounding.bestRound(this.ymin + yrange, y_pixel_units/10);
  };

  Viewport.prototype.clone = function() {
    return new Viewport(this.xmin, this.xmax, this.ymin, this.ymax);
  };

  // calculates a distance from the origin that is guaranteed to reach out past
  // the edge of the viewport for all values of theta. The actual value doesn't
  // matter much. This is used for clipping and the value will get truncated
  // during the clipping routine. In theory could use a really big number but
  // it's possible that we won't pick a big enough number.
  Viewport.prototype.polarDiameter = function() {
     var d1 = Math.abs(this.xmax), d2 = Math.abs(this.xmin);
     var d3 = Math.abs(this.ymax), d4 = Math.abs(this.ymin);

     // Distance can be at most sqrt(2)*magnitude of largest limit.
     // the 1.5 gives a little padding
     return 1.5 * Math.max(d1, d2, d3, d4);
  };

  //the largest visible radius. Note: this should always be strictly smaller than polarDiameter
  Viewport.prototype.largestR = function() {
    //if xmin is positive, then xmax is bigger than abs(xmin)
    //if xmax is negative, then -xmin is bigger than abs(xmax)
    return Math.sqrt(
      Math.pow(Math.max(-this.xmin, this.xmax), 2) +
      Math.pow(Math.max(-this.ymin, this.ymax), 2)
    );
  };

  //the smallest visible radius on the screen
  Viewport.prototype.smallestR = function() {
    //origin is visible
    if (this.xmin <= 0 && this.xmax >= 0 && this.ymin <= 0 && this.ymax >= 0) return 0;
    //y-axis is visible: return wherever on that's smallest
    if (this.xmin <= 0 && this.xmax >= 0) return Math.min(Math.abs(this.ymin), Math.abs(this.ymax));
    //x-axis is visible: return wherever on that's smallest
    if (this.ymin <= 0 && this.ymax >= 0) return Math.min(Math.abs(this.xmin), Math.abs(this.xmax));

    // both x & y axes are offscreen. one of the corners is the min.
    // If both negative, then -xmax is positive and smaller.
    // If both positive, then xmin positive and smaller
    return Math.sqrt(
      Math.pow(Math.max(this.xmin, -this.xmax), 2) +
      Math.pow(Math.max(this.ymin, -this.ymax), 2)
    );
  };

  return Viewport;
});

define('graphing/projection',['require','./viewport'],function (require) {
  var Viewport = require('./viewport');

  // A single object that contains all the information to map from
  // the theoretical space to the canvas space.
  var Projection = function (screen, viewport, settings) {
    this.screen = screen;
    this.viewport = viewport;
    this.settings = settings;
  };
  
  Projection.prototype.calculateViewportForScreen = function (newScreen) {
    var vp = this.viewport;
    var dw = (newScreen.width / this.screen.width - 1) * (vp.xmax - vp.xmin);
    var dh = (newScreen.height / this.screen.height - 1) * (vp.ymax - vp.ymin);
        
    var newViewport = new Viewport(vp.xmin-dw/2, vp.xmax+dw/2, vp.ymin-dh/2, vp.ymax+dh/2);
    newViewport.round(newScreen);
    
    return newViewport;
  };

  Projection.prototype.mapx = function(x) {
      return (x - this.viewport.xmin)*this.screen.width/(this.viewport.xmax - this.viewport.xmin);
  };
  
  Projection.prototype.mapy = function(y) {
      return this.screen.height - (y - this.viewport.ymin)*this.screen.height/(this.viewport.ymax - this.viewport.ymin);
  };

  Projection.prototype.map_pt = function(pt) {
      return {x: this.mapx(pt.x), y: this.mapy(pt.y)};
  };

  Projection.prototype.reverse_mapx = function (mapped_x) {
    return mapped_x * (this.viewport.xmax - this.viewport.xmin)/this.screen.width + this.viewport.xmin;
  };

  Projection.prototype.reverse_mapy = function (mapped_y) {
    return (
      -(mapped_y - this.screen.height)*(this.viewport.ymax - this.viewport.ymin)/this.screen.height + this.viewport.ymin
    );
  };

  Projection.prototype.reverse_map_pt = function (mapped_pt) {
    return {x: this.reverse_mapx(mapped_pt.x), y: this.reverse_mapy(mapped_pt.y)};
  };

  return Projection;
});

define('graphing/viewporttransformation',['require','pjs','./viewport','./projection'],function(require){
  var P = require('pjs');
  var Viewport = require('./viewport');
  var Projection = require('./projection');

  var ViewportTransformation = P(function (proto) {
    // Constructor can take 2 arguments for a translation only, 3 arguments
    // for a uniform scaling, or 4 arguments for different scalings along x
    // and y.
    proto.init = function (xOffset, yOffset, xScale, yScale) {
      this.xOffset = xOffset !== undefined ? xOffset : 0;
      this.yOffset = yOffset !== undefined ? yOffset : 0;
      this.xScale = xScale !== undefined ? xScale : 1;
      this.yScale = yScale !== undefined ? yScale : this.xScale;
    };

    proto.compose = function (transformation) {
      return new ViewportTransformation(
        transformation.xScale*this.xOffset + transformation.xOffset,
        transformation.yScale*this.yOffset + transformation.yOffset,
        transformation.xScale*this.xScale,
        transformation.yScale*this.yScale
      );
    };

    proto.lerp = function (transformation, ratio) {
      return new ViewportTransformation(
        (1 - ratio)*this.xOffset + ratio*transformation.xOffset,
        (1 - ratio)*this.yOffset + ratio*transformation.yOffset,
        (1 - ratio)*this.xScale + ratio*transformation.xScale,
        (1 - ratio)*this.yScale + ratio*transformation.yScale
      );
    };

    proto.transformProjection = function (projection) {
      var viewport = projection.viewport;
      var screen = projection.screen;

      var vmidx = (viewport.xmin + viewport.xmax)/2;
      var vmidy = (viewport.ymin + viewport.ymax)/2;
      var vminx = vmidx + (viewport.xmin - vmidx)/this.xScale;
      var vmaxx = vmidx + (viewport.xmax - vmidx)/this.xScale;
      var vminy = vmidy + (viewport.ymin - vmidy)/this.yScale;
      var vmaxy = vmidy + (viewport.ymax - vmidy)/this.yScale;

      // Pixel coord vs cartesian coord flip means that voffset_y needs to be flipped.
      var vox = this.xOffset * (vmaxx-vminx) / screen.width;
      var voy = -this.yOffset * (vmaxy-vminy) / screen.height;

      return new Projection(
        projection.screen,
        new Viewport(vminx-vox, vmaxx-vox, vminy-voy, vmaxy-voy),
        projection.settings
      );
    };
  });

  return ViewportTransformation;
});

define('graphing/screen',['require'],function(require) {
  function Screen(width, height) {
      this.width = width;
      this.height = height;

      return this;
  }

  return Screen;
});

/**
 * @license RequireJS text 2.0.7 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    

    var text, fs, Cc, Ci,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.7',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                errback(e);
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes,
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');

        text.get = function (url, callback) {
            var inStream, convertStream,
                readData = {},
                fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('loadcss',['text'], function(text){
  var buildMap = {};
  
  function inject_css_file(href) {
    var head = document.getElementsByTagName('head')[0];
    var link = document.createElement('link');
    link.href = href;
    link.rel = 'stylesheet';
    link.type = 'text/css';
    head.appendChild(link);
  }

  return {
    load: function(name, req, onLoad, config){
      var filename = req.toUrl(name) + ".css";
      
      // it's a build, so we grab the source directly
      if (config.isBuild) {
        text.get(filename, function(css_source){
          buildMap[name] = css_source;
          onLoad();
        });
      }
      
      // not a build, so add a <link> element to load the css file
      else {
        inject_css_file(filename);
        onLoad();
      }
    },
    
    onLayerEnd: function (write, data) {
      var complete_css = '';
      for (var moduleName in buildMap) {
        complete_css += buildMap[moduleName];
      }

      // save a css file in the same folder as the .js that will be saved. Could possibly
      // integrate this better with optimize.js in order to have more control over where the css
      // file goes. For now, it's fine within the generated/js/ dir.   
      var fs = require.nodeRequire('fs');
      var css_file = data.path.replace(/\.js/g, '.required.css');
      fs.writeFileSync(css_file, complete_css, 'utf8');
    },

    write: function(pluginName, moduleName, write){
      if(moduleName in buildMap){
        write("define('" + pluginName + '!' + moduleName + "', function(){});");
      } else{
      }
    }
  };
});
define('loadcss!css/poi', function(){});
// Disable text selection

/* global jQuery */
;(function($){

  $.fn.disableTextSelection = function( removeFocus ) {

    if (removeFocus) {
      this.each(function(){
        $(this).bind("mousedown touchstart", function(){
          $(document.activeElement).focusout();
        });
      });
    }

    return this.each(function() {
    $(this).attr('unselectable', 'on').css({
                   '-moz-user-select':'none',
                   '-webkit-user-select':'none',
                   'user-select':'none'
               })
               .each(function() {
                   this.onselectstart = function() { return false; };
               });
    });
  };

})(jQuery);


define("lib/jquery.disabletextselection", function(){});

define('graphing/canvaslayer',['require','jquery','pjs','lib/browser','lib/jquery.disabletextselection'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var Browser = require('lib/browser');
  require('lib/jquery.disabletextselection');

  var CanvasLayer = P(function (layer) {

    layer.init = function (width, height) {
      this.$ = $("<div class='graph-outer'></div>")
      .css('position', 'absolute')
      .css('overflow', 'hidden')
      .disableTextSelection(Browser.IS_IE);

      this.canvas_node = $("<canvas class='graph-inner'></canvas>")
      .css('position', 'relative')
      .css('display', 'block')
      .disableTextSelection(Browser.IS_IE);

      this.devicePixelRatio = (window.devicePixelRatio || 1);
      this.ctx = this.canvas_node[0].getContext('2d');

      this.resize(width, height);

      // Canvas used to hold an image of the graph when we're panning/scaling.
      this.unscaledCanvas = document.createElement('canvas');
      this.unscaledCanvas.width = width;
      this.unscaledCanvas.height = height;

      // Flag for whether we're in the middle of a pan/scale
      this.transforming = false;

      this.$.append(this.canvas_node);
    };

    layer.resize = function (width, height) {
      // concession to retina iPads, where there is a horrendous performance
      // drop between 1023 pixels, and its full width, 1024 pixels. This
      // problem also occurs on desktop Safari as of version 6, so full screen
      // safari on a retina laptop will still be a bad experience.
      //
      // see minimal examlpe at http://jsbin.com/ulobuh/4
      if (width === 1024 && this.devicePixelRatio === 2) width = 1023;

      // early trap if not changing size
      if (width === this.width && height === this.height) return;

      this.width = width;
      this.height = height;

      this.$.css('width', width + "px")
      .css('height', height + "px");

      this.canvas_node.css('width', width + "px")
      .css('height', height + "px")
      .attr('width', width*this.devicePixelRatio)
      .attr('height', height*this.devicePixelRatio);

      if (this.unscaledCanvas) {
        this.unscaledCanvas.width = width;
        this.unscaledCanvas.height = height;
      }

      this.ctx.scale(this.devicePixelRatio, this.devicePixelRatio);
    };

    // should get overridden by subclass
    layer.redraw = function () {};

    layer.saveUnscaledCanvas = function (projection) {

      // if we've already saved it, don't want to overwrite it. You must release
      // it if you want to resave it.
      if (this.transforming) return;
      this.transforming = true;

      var ctx = this.unscaledCanvas.getContext('2d');
      var width = this.unscaledCanvas.width;
      var height = this.unscaledCanvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(this.canvas_node[0], 0, 0, width, height);
    };

    layer.releaseUnscaledCanvas = function () {
      this.transforming = false;
    };

    layer.paintScaledCanvas = function (transformation) {
      // can't do this if we don't have an unscaledCanvas to scale
      if (!this.unscaledCanvas) return;

      var t = transformation;

      var width = this.ctx.canvas.width;
      var height = this.ctx.canvas.height;

      this.ctx.save();
      this.ctx.clearRect(0, 0, width, height);

      this.ctx.setTransform(
        t.xScale, 0,
        0, t.yScale,
        t.xOffset*this.devicePixelRatio - 0.5*(t.xScale - 1)*width,
        t.yOffset*this.devicePixelRatio - 0.5*(t.yScale - 1)*height
      );
      this.ctx.drawImage(this.unscaledCanvas, 0, 0, width, height);
      this.ctx.restore();
    };
  });

  return CanvasLayer;
});

define('graphing/clipping',[], function(){

var Clipping = {
  
  TOP: 1,
  BOTTOM: 2,
  LEFT: 4,
  RIGHT: 8,
  ALL: 15,
  X: 12,
  Y: 3,
  
  POLAR_RADIAN_EQUALITY: 1,
  POLAR_RADIAN_INEQUALITY: 2,
  POLAR_DEGREE_EQUALITY: 3,
  POLAR_DEGREE_INEQUALITY: 4,
  Y_EQUALS: 5,
  X_EQUALS: 6,
  
  mapSegmentToCanvas: function (segment, viewport, screen, graphType) {
    var output = [];
    var xmin = viewport.xmin;
    var ymin = viewport.ymin;
    var xrange = viewport.xmax-viewport.xmin;
    var yrange = viewport.ymax-viewport.ymin;
    var width = screen.width;
    var height = screen.height;
    var xscale = width/xrange;
    var yscale = -height/yrange;
    var len = segment.length;
    var i,x,y,theta,r;
        
    if (graphType === Clipping.Y_EQUALS) {
      
      for (i=0; i < len; i+=2) {
        x = (segment[i]-xmin)*xscale - 0.5;
        y = (segment[i+1]-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }
      
    } else if (graphType === Clipping.X_EQUALS) {
      
      for (i=0; i < len; i+=2) {
        x = (segment[i+1]-xmin)*xscale - 0.5;
        y = (segment[i]-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }
      
    } else if (graphType === Clipping.POLAR_RADIAN_EQUALITY) {
      
      for (i=0; i<segment.length; i+=2) {
        theta = segment[i];
        r = segment[i+1];
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }
        
    } else if (graphType === Clipping.POLAR_RADIAN_INEQUALITY) {
      
      for (i=0; i<segment.length; i+=2) {
        theta = segment[i];
        r = segment[i+1];
        if (r < 0) r = 0;
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }
      
    } else if (graphType === Clipping.POLAR_DEGREE_EQUALITY) {
      
      for (i=0; i<segment.length; i+=2) {
        theta = segment[i]*Math.PI/180;
        r = segment[i+1];
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }
      
    } else if (graphType === Clipping.POLAR_DEGREE_INEQUALITY) {
       
      for (i=0; i<segment.length; i+=2) {
        theta = segment[i]*Math.PI/180;
        r = segment[i+1];
        if (r < 0) r = 0;
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    }
    
    return output;
  },
  
  clipStrokeEdges: function (segment, viewport) {
    return Clipping.clipFillEdges(segment, viewport, Clipping.ALL, true);
  },

  clipFillEdge: function (input, inside_test, exit_point, is_open) {
    var output = [];
    var push = [].push;
    var start_index;

    if(is_open){  //stroke
      x = input[0];
      y = input[1];
      start_index = 2;
      inside = inside_test(x, y);
      if(inside) output.push(x, y);
    } else {      //fill
      x = input[input.length - 2];
      y = input[input.length - 1];
      start_index = 0;
      inside = inside_test(x, y);
    }

    for (var i = start_index; i < input.length; i+=2) {
      var x_prev = x;
      var y_prev = y;
      var inside_prev = inside;
    
      var x = input[i];
      var y = input[i+1];
      var inside = inside_test(x, y);

      if(!inside && !inside_prev){
        continue;
      }
      if(inside && inside_prev){
        output.push(x, y);
      }
      if(inside && !inside_prev){
        push.apply(output, exit_point(x, y, x_prev, y_prev));
        output.push(x, y);
      }
      if(!inside && inside_prev){
        push.apply(output, exit_point(x_prev, y_prev, x, y));
      }
    }
    return output;
  },

  clipFillEdges: function (input, viewport, edges, is_open) {
    /* jshint bitwise: false */
    var xmin = viewport.xmin;
    var xmax = viewport.xmax;
    var ymin = viewport.ymin;
    var ymax = viewport.ymax;

    var test_xmin = function (x, y) {
      return x >= xmin;
    };
    var test_xmax = function (x, y) {
      return x <= xmax;
    };
    var test_ymin = function (x, y) {
      return y >= ymin;
    };
    var test_ymax = function (x, y) {
      return y <= ymax;
    };

    var entry_xmin = function (x, y, x2, y2) {
      var dy = y2-y;
      return [xmin, y+dy*(xmin-x)/(x2-x)];
    };
    var entry_xmax = function (x, y, x2, y2) {
      var dy = y2-y;
      return [xmax, y+dy*(xmax-x)/(x2-x)];
    };
    var entry_ymin = function (x, y, x2, y2) {
      var dx = x2-x;
      return [x+dx*(ymin-y)/(y2-y), ymin];
    };
    var entry_ymax = function (x, y, x2, y2) {
      var dx = x2-x;
      return [x+dx*(ymax-y)/(y2-y), ymax];
    };
    
    var output = input;
    
    if (edges & Clipping.LEFT) {
      output = Clipping.clipFillEdge(input, test_xmin, entry_xmin, is_open);
    }
    
    if (edges & Clipping.BOTTOM) {
      output = Clipping.clipFillEdge(output, test_ymin, entry_ymin, is_open);
    }
    
    if (edges & Clipping.RIGHT) {
      output = Clipping.clipFillEdge(output, test_xmax, entry_xmax, is_open);
    }

    if (edges & Clipping.TOP) {
      output = Clipping.clipFillEdge(output, test_ymax, entry_ymax, is_open);
    }
    
    return output;
  },

  clipAllFillEdges: function (input, viewport) {
   return Clipping.clipFillEdges(input, viewport, Clipping.ALL, false);
  },
  
  computePolarFill: function(segment, fillTowards, polarInterval) {
    
    var all_segments = [];
   
    var theta;
    var start_theta = segment[0];
    var end_theta = start_theta+polarInterval;
    var limited_segment = [];
    all_segments.push(limited_segment);

    // detect 2pi intervals and split into separate segments
    for (var i=0; i<segment.length; i+=2) {
      theta = segment[i];
      var r = segment[i+1];
      if (r<0) r = 0;
        
      if (theta>=end_theta) {
        
        limited_segment = [];
        all_segments.push(limited_segment);
        start_theta = segment[i-2]; //previous theta
        end_theta = start_theta;
        // Make sure that end_theta always increases. Adding polarInterval
        // only once isn't enough because theta might change by more than
        // polarInterval between two samples.
        while(theta >= end_theta) end_theta += polarInterval;
        i -= 4; //go back 1 theta (for loop will +2)
        
      } else {
        limited_segment.push(theta,r);
      }

    }
      
    if (fillTowards === 0) {
      // just fill towards the origin
      for (i=0; i<all_segments.length; i++) {
        all_segments[i].push(0,0);
      }
      
    } else {
      
      // shade toward outside. trace around counter clockwise, jump to the
      // outside, and trace around clockwise again at pi/8 intervals. Then
      // go to the starting theta with very large radius.
      var clockwise_step = polarInterval/16;
      var radius = fillTowards;
      for (i=0; i<all_segments.length; i++) {
        var seg = all_segments[i];
        start_theta = seg[0];
        end_theta = seg[seg.length-2];
        for (theta = end_theta; theta > start_theta; theta -= clockwise_step) {
          seg.push( theta, radius);
        }
        seg.push( start_theta, radius);
      }
      
    }

    return all_segments;
  },

  computeCartesianFill: function(segment, fillTowards) {
    // copy the incoming segment and push it to the list
    segment = segment.slice();

    // add a couple points that decide which direction we fill
    segment.push(segment[segment.length-2], fillTowards);
    segment.push(segment[0], fillTowards);

    return [segment];
  }
};

return Clipping;
});

define('graphing/constants',[],function () {
  return {
    ANIMATE_ZOOM_DURATION: 500,
    DOUBLETAP_ZOOM: 2.0,
    ZOOM_FACTOR: 1.125,

    MAX_DOTTED_SEGMENTS: 1000,
    STROKE_ALPHA: 0.7,
    HIGHLIGHTED_STROKE_ALPHA: 1,
    FILL_ALPHA: 0.4,
    POINT_ALPHA: 0.9,
    HIGHLIGHTED_POINT_ALPHA: 0.6,
    POLAR_ALPHA: 0.2,
    POI_ALPHA: 0.01
  };
});

//TODO - something is slow about this when zoomed way out.
//       could be subpixel rendering.
define('graphing/dasheddrawer',['require','./constants','math/distance'],function(require){
  var constants = require('./constants');
  var Distance = require('math/distance');

function DashedDrawer(ctx, seglen) {
    this.pattern = [11,7];
    this.replen = this.pattern[0] + this.pattern[1];
     
  if (seglen !== null && seglen/this.replen > constants.MAX_DOTTED_SEGMENTS) {
        this.pattern[0] = seglen*this.pattern[0]/this.replen/constants.MAX_DOTTED_SEGMENTS;
        this.pattern[1] = seglen*this.pattern[1]/this.replen/constants.MAX_DOTTED_SEGMENTS;
    }
     
    this.pstate = 0; // 0 being "draw a line"
    this.dstaccum = 0.0;
    this.px = null;
    this.py = null;
    this.ctx = ctx;
     
    return this;
}
  
DashedDrawer.getTotalSegmentLength = function(segment) {
  if (segment.length < 4) return 0;

  var len = 0;
  var x = segment[0];
  var y = segment[1];
  
  for (var i = 2; i < segment.length; i+=2) {
    var nx = segment[i];
    var ny = segment[i+1];
  
    len += Distance.hypot(nx-x,ny-y);
  
    x = nx;
    y = ny;
  }

  return len;
};

DashedDrawer.prototype.start = function(x,y) {
    if(!this.ctx.desmos_batching) this.ctx.beginPath();
    this.px = x;
    this.py = y;
};
  
DashedDrawer.prototype.next = function(x,y) {
    var dstlimit = this.pattern[this.pstate];
    var dstincr = Math.sqrt(Math.pow(x-this.px,2) + Math.pow(y-this.py,2));
     
  if (dstincr > 0.00001) {
    while (dstincr + this.dstaccum >= dstlimit) {
            // Draw up to the phase change, change phase.
            // compute actual line-to point
            var incrx = x - this.px;
            var incry = y - this.py;

            // Scaling factor
            var linedst = dstlimit - this.dstaccum;
            incrx *= linedst/dstincr;
            incry *= linedst/dstincr;
             
            // Draw if in the draw state
      if (this.pstate === 0) {
                this.ctx.moveTo(this.px, this.py);
                this.ctx.lineTo(this.px+incrx, this.py+incry);
            }
             
            // Reset the accumulator
            this.dstaccum = 0.0;
            this.px += incrx;
            this.py += incry;
            // Flip the pattern state
            this.pstate = 1-this.pstate;
            dstlimit = this.pattern[this.pstate];
            dstincr -= linedst;
        }
         
    // Draw up to the target point.
    if (this.pstate === 0) {
            this.ctx.moveTo(this.px, this.py);
            this.ctx.lineTo(x, y);
        }
    }
    this.px = x;
    this.py = y;
    this.dstaccum += dstincr;
};

DashedDrawer.prototype.skip = function(x,y) {
  this.px = x;
  this.py = y;
};
  
DashedDrawer.prototype.close = function() {
    if(!this.ctx.desmos_batching) this.ctx.stroke();

    this.pstate = 0; // 0 being "draw a line"
    this.dstaccum = 0.0;
    this.px = null;
    this.py = null;
};

return DashedDrawer;
});

define('graphing/graphslayer',['require','pjs','underscore','./canvaslayer','./clipping','./dasheddrawer','./constants','./viewport','graphing/graphmode'],function (require) {
  var P = require('pjs');
  var _ = require('underscore');
  var CanvasLayer = require('./canvaslayer');
  var Clipping = require('./clipping');
  var DashedDrawer = require('./dasheddrawer');
  var constants = require('./constants');
  var Viewport = require('./viewport');
  var GRAPHMODE = require('graphing/graphmode');

  var screenToClippingViewport = function (screen) {
    return new Viewport(-3, screen.width + 3, -3, screen.height + 3);
  };

  var GraphsLayer = P(CanvasLayer, function (layer) {

      layer.redraw = function (projection, graphSketches, drawOrder) {
        var screen = projection.screen;

        // make sure that this is the correct size
        this.resize(screen.width, screen.height);
        // Clear out the drawing area
        this.ctx.clearRect(0, 0, screen.width, screen.height);
        this.redrawToCtx(this.ctx, projection, graphSketches, drawOrder);

      };

      layer.redrawToCtx = function (ctx, projection, graphSketches, drawOrder) {
        // Do the drawing of the segments
        if (drawOrder === undefined || drawOrder.length < _.size(graphSketches)) {
          // If we don't have a drawOrder, or it doesn't include all of our graphSketches then make a new order.
          drawOrder = _.keys(graphSketches);
        }
        drawOrder.forEach(function (id) {
          var sketch = graphSketches[id];
          if (sketch !== undefined) {
            if (sketch.visible) {
              GraphsLayer.drawSketchToCtx(graphSketches[id], ctx, projection);
            }
          }
        });
      };

  });

  GraphsLayer.eachSegment = function (sketch, fn) {
    for (var i = 0; i < sketch.branches.length; i++) {
      var branch = sketch.branches[i];
      for (var j = 0; j < branch.segments.length; j++) {
        var segment = branch.segments[j];
        fn(branch, segment);
      }
    }
  };

  GraphsLayer.drawSketchToCtx = function (sketch, ctx, projection) {
      if (!sketch.branches || !sketch.branches.length) return;
      ctx.lineWidth = projection.settings.graphLineWidth;
      ctx.strokeStyle = sketch.color;
      ctx.fillStyle = sketch.color;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      //If we're drawing points, draw points and return
      var allowMovable = !!projection.settings.takingScreenshot;
      ctx.desmos_batching = true;
      ctx.beginPath();
      ctx.save();
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT ||
            (branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE && allowMovable)) {
          GraphsLayer.drawPointsToCtx(ctx, projection, segment, branch.style);
        }
      });

      ctx.globalAlpha = constants.POINT_ALPHA;
      ctx.stroke();
      ctx.restore();
      ctx.desmos_batching = false;

      //If we're filling, fill.  No batching, because we want polar to shade deeper in overlaps
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
        var graphMode = GRAPHMODE.Y;
        if (branch.flip) graphMode = GRAPHMODE.X;
        if (branch.graphMode) graphMode = branch.graphMode;

        if (graphMode === GRAPHMODE.POLYGONFILL) {
          GraphsLayer.fillPolygonToCtx(ctx, projection, segment);
        } else {
          var op = branch.operator;
          var fill = (
            op == "<" || op == ">" || op == "<=" || op == ">=" ||
            op == "\\leq" || op == "\\le" || op == "\\geq" || op == "\\ge"
          );
          var fill_d = (op == "<=" || op == "<" || op == "\\leq" || op == "\\le");

          if (fill) GraphsLayer.fillGraphStrokeToCtx(ctx, projection, segment, fill_d, graphMode);
        }
      });

      //If we're drawing segments, draw them
      ctx.desmos_batching = true;
      ctx.beginPath();
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
        var graphMode = GRAPHMODE.Y;
        if (branch.flip) graphMode = GRAPHMODE.X;
        if (branch.graphMode) graphMode = branch.graphMode;

        var op = branch.operator;
        // != is used for shade-between lines which should be dashed but not filled
        var dotted = (op == "<" || op == ">" || op == '!=' || sketch.style === 'dashed');

        GraphsLayer.drawGraphStrokeToCtx(ctx, projection, segment, dotted, graphMode, op);
      });
      ctx.globalAlpha = constants.STROKE_ALPHA;
      ctx.stroke();
      ctx.globalAlpha = 1.0;
      ctx.desmos_batching = false;
  };

  GraphsLayer.drawGraphStrokeToCtx = function (ctx, projection, segment, dotted, graphMode, op) {
    ctx.globalAlpha = projection.settings.highlight ?
      constants.HIGHLIGHTED_STROKE_ALPHA : constants.STROKE_ALPHA
    ;

    // takes the raw array of numbers and maps it to the canvas. Then it clips.
    var graphType = GraphsLayer.getClippingGraphType(graphMode, op !== "=", projection.settings);
    var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, graphType);
    var clipped = Clipping.clipStrokeEdges(scaled, screenToClippingViewport(projection.screen));
    var i;

    // draws the clipped segment as a solid curve
    if (!dotted) {

      if (!ctx.desmos_batching) ctx.beginPath();
      ctx.moveTo(clipped[0],clipped[1]);
      for (i=0; i<clipped.length; i+=2) {
        ctx.lineTo(clipped[i], clipped[i+1]);
      }
      if (!ctx.desmos_batching) ctx.stroke();

    // draws the clipped segment as a dashed curve
    } else {

      var buf = new DashedDrawer(ctx, DashedDrawer.getTotalSegmentLength(clipped) );
      buf.start(clipped[0], clipped[1]);
      for (i=2; i < clipped.length; i+=2) {
        buf.next(clipped[i], clipped[i+1]);
      }
      buf.close();

    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.mapPointToScreen = function (projection, x, y) {
    // if the point is more than 20px off the screen in any direction, we just
    // don't draw it.
    var padding = 20;
    var mx = projection.mapx(x)-0.5;
    if (mx < -padding || mx > projection.screen.width+padding) return null;

    var my = projection.mapy(y)-0.5;
    if (my < -padding || my > projection.screen.height+padding) return null;

    return {x: mx, y: my};
  };

  GraphsLayer.drawPointToCtx = function (ctx, projection, x, y, alpha, style) {

    var pt = GraphsLayer.mapPointToScreen(projection, x, y);
    var size;
    if (!pt) return false;

    ctx.globalAlpha = projection.settings.highlight ?
      constants.HIGHLIGHTED_POINT_ALPHA : constants.POINT_ALPHA
    ;
    if (alpha) ctx.globalAlpha = alpha;
    ctx.globalAlpha = constants.POINT_ALPHA;
    if (!ctx.desmos_batching) ctx.beginPath();
    // For some reason we need a full polygon, but a small one.

    if (style === 'cross') {
      // The values for this and the open style are largely eyeballed so they
      // seem cohesize when mixed. They may change based on other peoples eyeballs
      size = projection.settings.pointLineWidth * 0.4;
      ctx.moveTo(pt.x-size, pt.y-size);
      ctx.lineTo(pt.x+size, pt.y+size);
      ctx.moveTo(pt.x+size, pt.y-size);
      ctx.lineTo(pt.x-size, pt.y+size);
      ctx.lineWidth = projection.settings.pointLineWidth * 0.3;
    } else if (style === 'open') {
      size = projection.settings.pointLineWidth * 0.5;
      ctx.arc(pt.x, pt.y, size, 0, Math.PI*2, true);
      ctx.closePath();
      ctx.fillStyle = "white";
      ctx.lineWidth = projection.settings.pointLineWidth * 0.25;
      ctx.fill();
    } else {
      ctx.moveTo(pt.x-0.1, pt.y-0.1);
      ctx.lineTo(pt.x-0.1, pt.y+0.1);
      ctx.lineTo(pt.x+0.1, pt.y+0.1);
      ctx.lineTo(pt.x+0.1, pt.y-0.1);
    }
    if (!ctx.desmos_batching) ctx.stroke();

    ctx.globalAlpha = 1.0;

    return true;
  };

  GraphsLayer.drawPointsToCtx = function (ctx, projection, segment, style) {
      ctx.lineWidth = projection.settings.pointLineWidth;
      for (var i=0; i < segment.length; i++) {
        GraphsLayer.drawPointToCtx(ctx, projection, segment[i][0], segment[i][1], false, style);
      }
  };

  GraphsLayer.fillGraphStrokeToCtx = function (ctx, projection, segment, fillDown, graphMode) {
    ctx.globalAlpha = (graphMode === GRAPHMODE.POLAR) ? constants.POLAR_ALPHA : constants.FILL_ALPHA;

    var fill_paths = null;
    var clipped_edges = null;
    var fillTowards;

    if (graphMode === GRAPHMODE.POLAR) {

      clipped_edges = Clipping.ALL;
      var radius = fillDown ? 0 : projection.viewport.polarDiameter();
      var interval = projection.settings.degreeMode ? 180.0 : 2*Math.PI;
      fill_paths = Clipping.computePolarFill(segment, radius, interval);

    } else if (graphMode === GRAPHMODE.Y) {

      clipped_edges = Clipping.Y;
      fillTowards = fillDown ? projection.viewport.ymin : projection.viewport.ymax;
      fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

    } else if (graphMode === GRAPHMODE.X) {

      clipped_edges = Clipping.X;
      fillTowards = fillDown ? projection.viewport.xmin : projection.viewport.xmax;
      fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

    }

    // scale, clip, and then draw each fill path
    var clipped_viewport = screenToClippingViewport(projection.screen);
    for (var i=0; i<fill_paths.length; i++) {

      // scale the segment
      var map_graphType = GraphsLayer.getClippingGraphType(graphMode, true, projection.settings);
      var scaled = Clipping.mapSegmentToCanvas(fill_paths[i], projection.viewport, projection.screen, map_graphType);

      // clip the segment
      var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, clipped_edges);

      // draw the segment
      if (clipped.length >= 6) {
        ctx.beginPath();

        ctx.moveTo(clipped[0],clipped[1]);
        for (var j=2; j<clipped.length; j+=2) {
          ctx.lineTo(clipped[j],clipped[j+1]);
        }

        ctx.closePath();
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.fillPolygonToCtx = function (ctx, projection, segment) {
    ctx.globalAlpha = constants.FILL_ALPHA;

    var clipped_viewport = screenToClippingViewport(projection.screen);

    var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, Clipping.Y_EQUALS);

    // clip the segment
    var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, Clipping.ALL);

    // draw the segment
    if (clipped.length >= 6) {
      ctx.beginPath();

      ctx.moveTo(clipped[0],clipped[1]);
      for (var j=2; j<clipped.length; j+=2) {
        ctx.lineTo(clipped[j],clipped[j+1]);
      }

      ctx.closePath();
      ctx.fill();
    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.getClippingGraphType = function (graphMode, isInequality, settings) {
    switch (graphMode) {

      case GRAPHMODE.X:
        return Clipping.X_EQUALS;

      case GRAPHMODE.PARAMETRIC:
      case GRAPHMODE.Y:
        return Clipping.Y_EQUALS;

      case GRAPHMODE.POLAR:
        if (settings.degreeMode) {
          return isInequality ? Clipping.POLAR_DEGREE_INEQUALITY : Clipping.POLAR_DEGREE_EQUALITY;
        } else {
          return isInequality ? Clipping.POLAR_RADIAN_INEQUALITY : Clipping.POLAR_RADIAN_EQUALITY;
        }

    }
  };

  return GraphsLayer;
});

define('graphing/poidotslayer',['require','loadcss!css/poi','pjs','./graphslayer','./canvaslayer','math/poi','./constants'],function(require) {
  
  // TODO - we have both a poidots layer and poilabels layer. This is including the css for both layers. Either
  // split the css into two separate files or combine the two layers into a single file
  require('loadcss!css/poi');

  var P = require('pjs');
  var GraphsLayer = require('./graphslayer');
  var CanvasLayer = require('./canvaslayer');
  var POITYPE = require('math/poi');
  var constants = require('./constants');

// TODO - rename from 'POIDotsLayer to something like SketchStyleLayer.
var POIDotsLayer = P(CanvasLayer, function(layer, _super){
  
    layer.init = function () {
      _super.init.apply(this, arguments);
      this.$.addClass('poi-dots-layer');
    };

    layer.redraw = function (projection, graphSketches) {
    
      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);
      
      // Clear out the drawing area
      this.ctx.clearRect(0, 0, projection.screen.width, projection.screen.height);
      
      // Iterate through each graphSketch, find the ones that should showPOI
      // and draw the poi dots. Also, we save the dots we drew.
      var savedPOI = [];
      for (var id in graphSketches) {
        var sketch = graphSketches[id];
        
        if (sketch.visible) {
          
          if (sketch.showHighlight) {
            POIDotsLayer.drawSketchHighlight(sketch, this.ctx, projection);
          }
          
          var pois = sketch.getPOI();
          if (
            sketch.showPOI ||
            // Always run this routine on defined POI. They aren't drawn to the screen, but they
            // need to be available to be opened. This is easier in the current system
            // than ensuring that showPOI is always set to true for these sketches.
            (pois.length && pois[0].type === POITYPE.DEFINITION)
          ) {
            savedPOI.push.apply(savedPOI,POIDotsLayer.drawPOIs(pois, this.ctx, "#AAAAAA", projection));
          }
        }
      }
      this.savedPOI = savedPOI;
    };
    
    layer.getDrawnPOI = function () {
      return this.savedPOI || [];
    };
});

POIDotsLayer.drawSketchHighlight = function (sketch, ctx, projection) {
  projection.settings.setProperty('highlight', true);
  GraphsLayer.drawSketchToCtx(sketch, ctx, projection);
  projection.settings.setProperty('highlight', false);
};

POIDotsLayer.drawPOIs = function (pois, ctx, color, projection) {

  ctx.lineWidth = projection.settings.pointLineWidth;
  ctx.strokeStyle = color || "#AAAAAA";
  ctx.fillStyle = color || "#AAAAAA";
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  var oldGlobalAlpha = ctx.globalAlpha;
  ctx.globalAlpha = constants.POI_ALPHA;
  
  var poiOnScreen = [];

  var i, plen = pois.length;
  var poi;
  
  // we don't draw dots for POI that are defined. There is already a dot
  // for the point on the screen. But, we want there to be a POI registered
  // still, so we add it to the list of poiOnScreen
  if (plen && pois[0].type === POITYPE.DEFINITION) {
    for (i=0; i<plen; i++) {
      poi = pois[i];
      if (GraphsLayer.mapPointToScreen(projection, poi.x, poi.y)) {
        poiOnScreen.push(poi);
      }
    }
  }
  
  // actually draw them on screen
  else {
    for (i=0; i<plen; i++) {
      poi = pois[i];
      if (GraphsLayer.drawPointToCtx(ctx, projection, poi.x, poi.y, constants.POI_ALPHA)) {
        poiOnScreen.push(poi);
      }
    }
  }

  ctx.globalAlpha = oldGlobalAlpha;
  return poiOnScreen;
};

return POIDotsLayer;
});

define('graphing/domlayer',['require','pjs','jquery','lib/browser','lib/jquery.disabletextselection'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var Browser = require('lib/browser');
  require('lib/jquery.disabletextselection');

var DOMLayer = P(function(layer){
  
  layer.init = function (width, height) {
    this.$ = $("<div class='graph-outer'></div>")
           .css('position', 'absolute')
           .css('overflow', 'hidden')
           .disableTextSelection(  Browser.IS_IE  );
      
    this.dom_node = $("<div></div>")
                     .css('position', 'relative')
                     .css('display', 'block')
                     .disableTextSelection(  Browser.IS_IE  );
     
    this.resize(width, height);
           
    this.$.append(this.dom_node);
  };
  
  layer.resize = function (width, height) {
    
    // early trap if not changing size
    if (width === this.width && height === this.height) return;
    
    this.width = width;
    this.height = height;
    
    this.$.css('width', width + "px")
          .css('height', height + "px");
  
    this.dom_node.css('width', width + "px")
                 .css('height', height + "px");
  };
  
  // should get overridden by subclass
  layer.redraw = function() {};
});

return DOMLayer;
});

define('graphing/label',['math/builtin'], function (BuiltIn) {
// Returns a label for a point with an appropriate number of decimals for the
// given scale. Scale is typically chosen to be the range of numbers displayed
// in the current viewport. Rounds to pi fractions when the denominator is 24
// or less, according to a tolerance that depends on x and scale.
//
// Label is returned as on object with the string representation given by
// label.string, and represented value label.value, which is equal to x when
// the string is a decimal representation, and equal to n*Math.PI/d for pi
// fractions. This is used for checking if a labeled value is actually a hole
// in the function.
function value(x, scale) {

  if (isNaN(x)) return { string: 'undefined', value: x };

  if (x === 0) return { string: '0', value: x };

  if (!scale) scale = x;

  var piFraction = BuiltIn.toFraction(x/Math.PI, 24);
  var nString;
  var dString;

  if (
    fewDigits(scale) &&
    BuiltIn.approx(piFraction.n/piFraction.d*Math.PI, x, 3)
  ) {
    if (piFraction.n === 0) {
      nString = "0";
    } else if (piFraction.n === 1) {
      nString = "π";
    } else if (piFraction.n === -1) {
      nString = "-π";
    } else {
      nString = piFraction.n.toString() + "π";
    }

    if (piFraction.d === 1) {
      dString = "";
    } else {
      dString = "/" + piFraction.d.toString();
    }

    return {
      string: nString + dString,
      value: piFraction.n/piFraction.d*Math.PI
    };
  }

  var mantissa, superscript, string;
  if (fewDigits(scale)) {
    string = stripZeros(x.toFixed(decimalsFromScale(scale)));
    superscript = null;
    mantissa = null;
    
  } else {
    var parts = stripExponentialZeros(x.toExponential(decimalsFromScale(scale/x))).split('e');
    mantissa = parts[0] + '\u00d7' + '10';
    superscript = parts[1].replace('+', '');
    string = stripExponentialZeros(x.toExponential(decimalsFromScale(scale/x))).replace('+', '');
  }

  return { string: string, mantissa: mantissa, superscript: superscript, value: x };
}

// x and f(value(x).value), returning the results as two strings. Useful
// because the function may have a hole at value(x).value.
function point(x, xscale, yscale, fn) {
  var xlabel = value(x, xscale);
  var ylabel = value(fn(xlabel.value), yscale);
  return [xlabel, ylabel];
}

// Strip trailing zeros from a string representation of a decimal.
var trailingZerosRegex = /\.?0+$/;
function stripZeros(string) {
  if (string.indexOf('.') === -1) return string;
  return string.replace(trailingZerosRegex, '');
}

var exponentialTrailingZerosRegex = /\.?0+e/;
function stripExponentialZeros(string) {
  return string.replace(exponentialTrailingZerosRegex, 'e');
}

function fewDigits(x) {
  x = Math.abs(x);
  return 1e-4 < x && x < 1e7;
}

// Returns integer number of decimals to show given scale of numbers to be
// represented.
function decimalsFromScale(scale) {
  scale = Math.abs(scale);
  scale = Math.max(scale, 1e-16);
  return Math.max(0, Math.floor(4.5 - Math.log(scale)/Math.LN10));
}

return {
  value: value,
  point: point
};

});

define('graphing/poilabelslayer',['require','pjs','jquery','./domlayer','./label','graphing/graphmode','math/poi'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var DOMLayer = require('./domlayer');
  var Label = require('./label');
  var GRAPHMODE = require('graphing/graphmode');
  var POITYPE = require('math/poi');

var POILabelsLayer = P(DOMLayer, function(layer, _super){
   
    // can't use jquery addClass and removeClass because they are slow on ipad.
    // the problem appears to be that jquery implementation keeps setting the
    // className property of the element even if nothing has changed. In turn,
    // ios appears to rerender everything since .className was set. So we only
    // add/remove the class if it'll change the className of the body.
    var body = $('body');
    function addGlobalClass (className) {
      if (!body.hasClass(className)) {
        body.addClass(className);
      }
    }
    function removeGlobalClass (className) {
     if (body.hasClass(className)) {
       body.removeClass(className);
     }
    }
    
    layer.init = function () {
      _super.init.call(this, arguments);
      this.$.addClass('poi-labels-layer');
    };

    layer.redraw = function (projection, graphSketches) {
    
      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);
      
      // Clear out the drawing area
      this.dom_node.find('.poi').remove();

      // check if an old hoveredPOI was set and clear it out if so
      var hoveredPOI = this.hoveredPOI;
      var hoveredSketch = hoveredPOI ? hoveredPOI.sketch : null;
      var foundHoveredSketch = false;
      
      // Iterate through each graphSketch, find the opened poi and draw them
      // also saves which ones were drawn.
      var savedPOI = [];
      for (var id in graphSketches) {
        var sketch = graphSketches[id];
        if (sketch === hoveredSketch) foundHoveredSketch = true;
        if (!sketch.visible) continue;
        
        var pois = POILabelsLayer.drawOpenPOI(sketch, this.dom_node, projection);
        if (pois.length) {
          savedPOI.push.apply(savedPOI,pois);
        }
      }
      
      // we had a hoveredPOI set but the sketch isn't there any more. clear out
      // the hoverdPOI property.
      if (!foundHoveredSketch) {
        hoveredPOI = this.hoveredPOI = null;
      }
      
      if (hoveredPOI && hoveredPOI.sketch.visible) {
        
        if (!hoveredPOI.isOpen()) {
          POILabelsLayer.drawHoveredPOI(this.dom_node, hoveredPOI, projection);
          addGlobalClass('mouse-over-closed-poi');
        } else {
          addGlobalClass('mouse-over-opened-poi');
        }
        
      } else {
       
         removeGlobalClass('mouse-over-closed-poi');
         removeGlobalClass('mouse-over-opened-poi');
        
      }

      this.savedPOI = savedPOI;
    };
    
    layer.getDrawnPOI = function () {
      return this.savedPOI || [];
    };
    
});

POILabelsLayer.getPointLabel = function(poi_in, viewport) {
  var xscale = viewport.xmax - viewport.xmin;
  var yscale = viewport.ymax - viewport.ymin;
  var labels;
  var graphMode = poi_in.getGraphMode();
  
  if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {
    
    labels = [
      Label.value(poi_in.x, xscale),
      Label.value(poi_in.y, yscale)
    ];
    
  } else {

    var flip = graphMode === GRAPHMODE.X;
    var independent = (flip) ? poi_in.y : poi_in.x;
    var fn = poi_in.getCompiledFunction();
    labels = Label.point(independent, xscale, yscale, fn);

    if (flip) {
      var tmp = labels[0];
      labels[0] = labels[1];
      labels[1] = tmp;
    }
    
  }
  var x_label = (
    labels[0].superscript ? labels[0].mantissa + '<sup>' + labels[0].superscript + '</sup>' : labels[0].string
  );
  var y_label = (
    labels[1].superscript ? labels[1].mantissa + '<sup>' + labels[1].superscript + '</sup>' : labels[1].string
  );
  return {
    x: labels[0].value,
    x_label: x_label,
    y: labels[1].value,
    y_label: y_label,
    is_hole: !isFinite(labels[1].value)
  };
};

// TODO - cleanup. Copied and modified from main/grapher.js
POILabelsLayer.createSinglePOI = function(poi_in, viewport) {
  
  var pt = POILabelsLayer.getPointLabel(poi_in, viewport);
  var hole = pt.is_hole ? ' hole' : '';
  var real = poi_in.type === POITYPE.DEFINITION ? ' real' : '';
  
  var x_label = pt.x_label.replace("π", "<span class='pi'>π</span>");
  var y_label = pt.y_label.replace("π", "<span class='pi'>π</span>");
  
  return $(
    '<div class="tracept poi' + hole + real +'">' +
    '  <div class="pt"></div>' +
    '  <div class="label">'+ x_label + ', ' + y_label + '</div>' +
    '  <div class="arrow""></div>' +
    '</div>'
  );
};

POILabelsLayer.drawHoveredPOI = function (dom, poi, projection) {
  var screen_x = projection.mapx(poi.x);
  var screen_y = projection.mapy(poi.y);

  // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
  if (
    screen_x > -20 && screen_y > -20 &&
    screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
  ) {
    var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
    dom_poi.css({
      left: screen_x + "px",
      top: screen_y + "px"
    });
    dom_poi.addClass('mouseover');
    dom.append(dom_poi);
  }
  
};

POILabelsLayer.drawOpenPOI = function (sketch, dom, projection) {
  
  var pois = sketch.openPOI;
  if (!pois.length) return [];
  
  var poiOnScreen = [];
  for (var i=0; i<pois.length; i++) {
    var poi = pois[i];
    var screen_x = projection.mapx(poi.x);
    var screen_y = projection.mapy(poi.y);

    // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
    if (
      screen_x > -20 && screen_y > -20 &&
      screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
    ) {
      var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
      dom_poi.css({
        left: screen_x + "px",
        top: screen_y + "px"
      });
      dom_poi.addClass('opened');
      
      dom.append(dom_poi);
      poiOnScreen.push(poi);
    }
  }
  
  return poiOnScreen;
};

return POILabelsLayer;
});

define('graphing/gridlayer',['jquery', 'pjs', './canvaslayer', './label'], function($, P, CanvasLayer, Label){

var GridLayer = P(CanvasLayer, function(layer){

  layer.redraw = function (projection, scaleAxis) {
    var screen = projection.screen;
    // make sure that this is the correct size
    this.resize(screen.width, screen.height);
    // Clear out the drawing area
    this.ctx.clearRect(0, 0, screen.width, screen.height);
    this.redrawToCtx(this.ctx, projection, scaleAxis);
  };

  layer.redrawToCtx = function (ctx, projection, scaleAxis) {
    if (projection.settings.showGrid) {
      if (projection.settings.polarMode) {
        this.drawPolarGrid(ctx, projection);
       } else {
        this.drawCartesianGrid(ctx, projection);
      }
    }

    if (projection.settings.showAxes) {
      this.drawAxes(ctx, projection, scaleAxis);
    }

    if (projection.settings.showLabels) {
      if (projection.settings.polarMode) {
        this.drawPolarLabels(ctx, projection);
       } else {
        this.drawCartesianLabels(ctx, projection);
      }
    }
  };

  var eachStep = function (min, max, step, func) {
    var nmin = Math.ceil(min/step);
    var nmax = Math.floor(max/step);
    var invstep = 1/step;
    if (nmin > nmax) return;
    // If step===0, this would loop forever. This is designed for drawing
    // gridlines to a screen, so it shouldn't need to use more steps than
    // there are pixels.
    if (nmax - nmin > 10000) return;
    for (var n = nmin; n <= nmax; n++) func(n/invstep);
  };

  var clamp = function (value, min, max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
  };
  
  layer.drawPolarGrid = function (ctx, projection) {
    
    var info = bestStepSizes(projection);
    var minorOpacity = projection.settings.minorAxisOpacity;
    var majorOpacity = projection.settings.majorAxisOpacity;
    var adjustedMajorOpacity = 1 - (1 - majorOpacity)/(1 - minorOpacity);

    var x = projection.mapx(0);
    var y = projection.mapy(0);
    var rh = projection.screen.height/(projection.viewport.ymax-projection.viewport.ymin);
    var rw = projection.screen.width/(projection.viewport.xmax-projection.viewport.xmin);
    var scale = rh/rw;
    var y_scaled = y/scale;
    var rmin = projection.viewport.smallestR();
    var rmax = projection.viewport.largestR();

    // we don't want to draw from info.minorStepX if the origin is way off
    // the screen. We figure out the first multiples of minorStepX and
    // majorStepX that are visible (or nearly visible).
    var firstMinorStepX = info.minorStepX * Math.max(1, Math.floor(rmin/info.minorStepX));
    var firstMajorStepX = info.majorStepX * Math.max(1, Math.floor(rmin/info.majorStepX));
    
    // minor circles
    ctx.save();
    ctx.scale(1, scale);
    ctx.beginPath();
    eachStep(firstMinorStepX, rmax, info.minorStepX, function (value) {
      var r = projection.mapx(value) - x;
      ctx.moveTo(x+r, y_scaled);
      ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
    });
    ctx.restore();
    ctx.lineWidth=1;
    ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";
    ctx.stroke();
    
    // minor radial lines
    ctx.beginPath();
    //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
    var rInterval = (rmin > 0 ? 5 : 15);
    eachStep(0, 359, rInterval, function (degrees) {
      ctx.moveTo(x,y);
      var x_px = projection.mapx(rmax * Math.cos(degrees*Math.PI/180));
      var y_px = projection.mapy(rmax * Math.sin(degrees*Math.PI/180));
      ctx.lineTo(x_px, y_px);
    });
    ctx.stroke();

    // major circles
    ctx.save();
    ctx.scale(1, scale);
    ctx.beginPath();
    eachStep(firstMajorStepX, rmax, info.majorStepX, function (value) {
      var r = projection.mapx(value) - x;
      ctx.moveTo(x+r, y_scaled);
      ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
    });
    ctx.restore();
    ctx.lineWidth=1;
    ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";
    ctx.stroke();
    
    // major radial lines
    ctx.beginPath();
    eachStep(0, 360-15, 90, function (degrees) {
      ctx.moveTo(x,y);
      var x_px = projection.mapx(rmax * Math.cos(degrees*Math.PI/180));
      var y_px = projection.mapy(rmax * Math.sin(degrees*Math.PI/180));
      ctx.lineTo(x_px, y_px);
    });
    ctx.stroke();

  };

  layer.drawCartesianGrid = function (ctx, projection) {

    var xmin = projection.viewport.xmin, ymin = projection.viewport.ymin;
    var xmax = projection.viewport.xmax, ymax = projection.viewport.ymax;

    var info = bestStepSizes(projection);

    var width = projection.screen.width;
    var height = projection.screen.height;

    var minorOpacity = projection.settings.minorAxisOpacity;
    var majorOpacity = projection.settings.majorAxisOpacity;

    ctx.lineWidth = 1;

    // Minor gridlines
    
    ctx.beginPath();

    ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";

    eachStep(xmin, xmax, info.minorStepX, function (value) {
      var pixelValue = Math.round(projection.mapx(value));
      if (pixelValue === width) return;
      ctx.moveTo(pixelValue - 0.5, 0);
      ctx.lineTo(pixelValue - 0.5, height);
    });
    
    eachStep(ymin, ymax, info.minorStepY, function (value) {
      var pixelValue = Math.round(projection.mapy(value));
      if (pixelValue === height) return;
      ctx.moveTo(0, pixelValue - 0.5);
      ctx.lineTo(width, pixelValue - 0.5);
    });

    ctx.stroke();

    // Major gridlines

    ctx.beginPath();
    // Compensate for double stroking major gridlines. Strokes opacities
    // compose as o3 = 1 - (1 - o1)(1 - o2). We know what we've stroked so
    // far (o1), and what final stroke we'd like (o3), so solve for o2:
    // o2 = 1 - (1 - o3)/(1 - o1).
    var adjustedMajorOpacity = 1 - (1 - majorOpacity)/(1 - minorOpacity);
    ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";

    eachStep(xmin, xmax, info.majorStepX, function (value) {
      var pixelValue = Math.round(projection.mapx(value));
      if (pixelValue === width) return;
      ctx.moveTo(pixelValue - 0.5, 0);
      ctx.lineTo(pixelValue - 0.5, height);
    });
    
    eachStep(ymin, ymax, info.majorStepY, function (value) {
      var pixelValue = Math.round(projection.mapy(value));
      if (pixelValue === height) return;
      ctx.moveTo(0, pixelValue - 0.5);
      ctx.lineTo(width, pixelValue - 0.5);
    });

    ctx.stroke();

  };

  layer.drawAxes = function(ctx, projection, scaleAxis) {
    var lineOffset = projection.settings.axisLineOffset;
    var axisOpacity = projection.settings.axisOpacity.toString();

    var scaleAxisStyle = "rgba(127,205,230," + axisOpacity + ")";
    var normalAxisStyle = "rgba(0,0,0," + axisOpacity + ")";
    
    var scaleAxisMultiplier = 3;
    
    var pixelX = Math.round(projection.mapx(0)) - lineOffset;
    var pixelY = Math.round(projection.mapy(0)) - lineOffset;
    var height = projection.screen.height;
    var width = projection.screen.width;
    
    ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'y' ? scaleAxisMultiplier : 1);
    ctx.strokeStyle = scaleAxis === 'y' ? scaleAxisStyle : normalAxisStyle;
    ctx.beginPath();
    ctx.moveTo(pixelX, 0);
    ctx.lineTo(pixelX, height);
    ctx.stroke();
    
    ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'x' ? scaleAxisMultiplier : 1);
    ctx.strokeStyle = scaleAxis === 'x' ? scaleAxisStyle : normalAxisStyle;
    ctx.beginPath();
    ctx.moveTo(0, pixelY);
    ctx.lineTo(width, pixelY);
    ctx.stroke();
  };
  
  layer.drawPolarLabels = function (ctx, projection) {

    var info = bestStepSizes(projection);
    var rmax = projection.viewport.largestR();
    var rmin = projection.viewport.smallestR();
    var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
    var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
    var width = projection.screen.width;
    var height = projection.screen.height;

    var hangingColor = projection.settings.labelHangingColor;
    var normalColor = projection.settings.labelNormalColor;

    var fontSize = projection.settings.labelSize;
    var textHeight = fontSize;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = fontSize.toString() + "px Arial";
    
    function intersectX (r, bounds, labels) {
      var y = Math.sqrt(r*r-bounds*bounds);
      if (ymin <= y && y <= ymax) {
        labels.push([projection.mapx(bounds), projection.mapy(y)]);
      }
      if (ymin <= -y && -y <= ymax) {
        labels.push([projection.mapx(bounds), projection.mapy(-y)]);
      }
    }

    function intersectY (r, bounds, labels) {
      var x = Math.sqrt(r*r-bounds*bounds);
      if (xmin <= x && x <= xmax) {
        labels.push([projection.mapx(x), projection.mapy(bounds)]);
      }
      if (xmin <= -x && -x <= xmax) {
        labels.push([projection.mapx(-x), projection.mapy(bounds)]);
      }
    }
    
    var xAxis = projection.mapx(0);
    var yAxis = projection.mapy(0);
    
    // if the axis is on screen add labels for it
    var addXLabels = ymin <= 0 && 0 <= ymax;
    var addYLabels = xmin <= 0 && 0 <= xmax;
    var addEdgeLabels = '';

    // neither axis is on the screen
    if (!addXLabels && !addYLabels) {
      
      // figure out which edge is closest to an axis
      var leftDistance = Math.abs(xAxis);
      var rightDistance = Math.abs(xAxis-width);
      var topDistance = Math.abs(yAxis);
      var bottomDistance = Math.abs(yAxis-height);

      var leftRightWinner, topBottomWinner, leftRightDis, topBottomDis;
      
      if (leftDistance <= rightDistance) {
        leftRightWinner = 'left';
        leftRightDis = leftDistance;
      } else {
        leftRightWinner = 'right';
        leftRightDis = rightDistance;
      }
      
      if (topDistance <= bottomDistance) {
        topBottomWinner = 'top';
        topBottomDis = topDistance;
      } else {
        topBottomWinner = 'bottom';
        topBottomDis = bottomDistance;
      }
      
      addEdgeLabels = leftRightDis <= topBottomDis ? leftRightWinner : topBottomWinner;
    }
    
    // label each circle where it crosses the x axis, the y axis, and
    // whenever it leaves or enters the viewport.
    eachStep(info.majorStepX, rmax, info.majorStepX, function (r) {
      var labels = [];
      var label = Label.value(r, rmax);

      var textWidth = _measureWidth(ctx, fontSize, label);

      // check if circle intersects positive y axis
      if (addYLabels && ymin <= r && r <= ymax) {
        labels.push([xAxis - textWidth.main - textWidth.superscript - 5, projection.mapy(r)]);
      }
  
      // check if circle intersects negative y axis
      if (addYLabels && ymin <= -r && -r <= ymax) {
        labels.push([xAxis - textWidth.main - textWidth.superscript - 5, projection.mapy(-r)]);
      }
      
      // check if circle intersects positive x axis
      if (addXLabels && xmin <= r && r <= xmax) {
        labels.push([projection.mapx(r), yAxis + textHeight*0.6 + 3]);
      }
            
      // check if circle intersects negative x axis
      if (addXLabels && xmin <= -r && -r <= xmax) {
        labels.push([projection.mapx(-r), yAxis + textHeight*0.6 + 3]);
      }
      
      // if we're supposed to add labels to an edge, do it
      switch (addEdgeLabels) {
        case "top":
          intersectY(r, ymax, labels);
          break;
          
        case "bottom":
          intersectY(r, ymin, labels);
          break;
          
        case "left":
          intersectX(r, xmin, labels);
          break;
          
        case "right":
          intersectX(r, xmax, labels);
          break;
      }
      
      // draw each label for this circle
      for (var i=0; i<labels.length; i++) {
        var clampedPixelX = clamp(labels[i][0], 3 + textWidth.main, width - 3 - textWidth - textWidth.superscript);
        var clampedPixelY = clamp(labels[i][1], 3 + textHeight, height - 3 - textHeight);
        ctx.fillStyle = normalColor;
        _renderScientificLabel(ctx, fontSize, label, clampedPixelX, clampedPixelY, textWidth);
      }
    });
    
    // figure out which circle to label radial lines along.
    // Rule here: halfway between the largest and smallest r (rmin and rmax).
    // not scientific. Round up. Let's see how it feels
    
    // 0 => 0th circle. 1 => first circle, etc;
    var minRadNum = Math.ceil(rmin / info.majorStepX);
    var maxRadNum = Math.floor(rmax / info.majorStepX);
    var radiusNum = Math.ceil((minRadNum + maxRadNum)/2);
    var radial_label_radius = radiusNum * info.majorStepX;
    

    //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
    var rInterval = (rmin > 0 ? 15 : 30);

    // label radial lines

    eachStep(0, 359, rInterval, function (degrees) {
      var string;
      if (projection.settings.degreeMode) {
        string = degrees.toString() + "°";
      } else {
        string = Label.value(degrees*Math.PI/180, 2*Math.PI).string;
      }
      
      var textHalfWidth = ctx.measureText(string).width/2;
      var r = radial_label_radius / 1.05;
      
      var x = r * Math.cos(degrees*Math.PI/180);
      var y = r * Math.sin(degrees*Math.PI/180);

      // only draw labels that are on the screen
      if (x < xmin || x > xmax|| y < ymin || y > ymax) return;
      
      var pixelX = projection.mapx(x);
      var pixelY = projection.mapy(y);
      
      // some adjustments to the labels along the axes
      if (degrees === 0 || degrees === 180) {
        pixelY -= textHeight;
      } else if (degrees === 90 || degrees === 270) {
        pixelX += textHalfWidth+3;
      }
            
      var clampedPixelX = clamp(pixelX, 3 + textHalfWidth, width - 3 - textHalfWidth);
      var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);
      
      ctx.fillStyle = hangingColor;
      ctx.font = fontSize.toString() + "px Arial";
      ctx.fillText(string, clampedPixelX, clampedPixelY);
    });
  };

  var _measureWidth = function(ctx, fontSize, label) {
    var superscriptWidth = 0, mainHalfWidth;
    if (label.superscript && label.string !== '0') {
      ctx.font = fontSize.toString() + "px Arial";
      mainHalfWidth = ctx.measureText(label.mantissa).width/2;
      ctx.font = (Math.round(0.8 * fontSize)).toString() + "px Arial";
      superscriptWidth = ctx.measureText(label.superscript).width;
    } else {
      ctx.font = fontSize.toString() + "px Arial";
      mainHalfWidth = ctx.measureText(label.string).width/2;
    }
    return {main: mainHalfWidth, superscript: superscriptWidth};
  };
  
  var _renderScientificLabel = function(ctx, fontSize, label, x, y, textWidth) {
    if (label.superscript) {
      ctx.font = fontSize.toString() + "px Arial";
      ctx.fillText(label.mantissa, x, y+Math.round(fontSize / 5));
      ctx.font = (Math.round(0.8 * fontSize)).toString() + "px Arial";
      ctx.fillText(label.superscript, x + textWidth.main + textWidth.superscript/2, y - Math.round(fontSize / 4));
    } else {
      ctx.font = fontSize.toString() + "px Arial";
      ctx.fillText(label.string, x, y);
    }
  };

  layer.drawCartesianLabels = function(ctx, projection) {
    
    var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
    var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
    var info = bestStepSizes(projection);
    var width = projection.screen.width;
    var height = projection.screen.height;

    var hangingColor = projection.settings.labelHangingColor;
    var normalColor = projection.settings.labelNormalColor;

    var xAxis = projection.mapx(0);
    var yAxis = projection.mapy(0);

    var fontSize = projection.settings.labelSize;
    var textHeight = fontSize;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = fontSize.toString() + "px Arial";

    var minusHalfWidth = (
      (ctx.measureText("-1").width - ctx.measureText("1").width)/2
    );

    eachStep(xmin, xmax, info.majorStepX, function (value) {
      var label = Label.value(value, xmax - xmin);
      
      var textWidth = _measureWidth(ctx, fontSize, label);
      var pixelX = projection.mapx(value);
      var pixelY = yAxis + textHeight*0.6 + 3;

      // Bump negative x values to the left so that the number without the
      // minus sign is centered on the grid line.
      if (value < 0) pixelX -= minusHalfWidth;

      var clampedPixelX = clamp(pixelX, 3 + textWidth.main, width - 3 - textWidth.main - textWidth.superscript);
      var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

      ctx.fillStyle = (pixelY === clampedPixelY) ? normalColor : hangingColor;

      if (label.string === "0") {
        ctx.fillStyle = normalColor;
        ctx.fillText("0", xAxis - 5 - textWidth.main, pixelY);
        return;
      }

      _renderScientificLabel(ctx, fontSize, label, clampedPixelX, clampedPixelY, textWidth);
    });

    eachStep(ymin, ymax, info.majorStepY, function (value) {
      var label = Label.value(value, ymax - ymin);

      var textWidth = _measureWidth(ctx, fontSize, label);

      var pixelY = projection.mapy(value);
      var pixelX = xAxis - 3 - textWidth.main - textWidth.superscript;

      var clampedPixelX = clamp(pixelX, 3 + textWidth.main, width - 3 - textWidth.main - textWidth.superscript);
      var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

      ctx.fillStyle = (pixelX === clampedPixelX) ? normalColor : hangingColor;

      if (label.string === "0") return;

      _renderScientificLabel(ctx, fontSize, label, clampedPixelX, clampedPixelY, textWidth);
    });
  };

  var RATIONAL_STEPS = {
    base: 10,
    major: [ 1, 2, 5 ],
    minor: [ 4, 4, 5 ]
  };
  
  var PI_STEPS = {
    base: 10,
    major: [ Math.PI, 2*Math.PI, 5*Math.PI ],
    minor: [ 4, 4, 5 ]
  };
  
  var PI_FRAC_STEPS = {
    base: 2,
    major: [ Math.PI/3 ],
    minor: [ 3 ]
  };

  // Helper for bestStepSizes
  var _bestStep = function (exact, steps) {
    
    // JM: What does this mean...
    
    /* 1 + xrange/bestMultiple <= expectedX
    * xrange/(expectedX-1) <= bestMultiple
    * xrange/(expectedX-1) <= mult*base^exp
    * (xrange/expectedX-1) / mult <= base^exp
    * ceil(log((range/expectedX-1)/mult)/log(base)) = exp
    */
    var major, bestMajor = Infinity, bestMinor, exp, num;
    for (var i=0; i < steps.major.length; i++) {
      major = steps.major[i];
      exp = Math.ceil(Math.log(exact/major)/Math.log(steps.base));
      num = major*Math.pow(steps.base, exp);

      if (num < bestMajor) {
        bestMajor = num;
        bestMinor = bestMajor/steps.minor[i];
      }
    }

    return { major: bestMajor, minor: bestMinor };
  };

  var bestStepSizes = function (projection) {

    var width = projection.screen.width;
    var height = projection.screen.height;
    var expectedX = width/projection.settings.pixelsPerLabel + 1;
    var expectedY = height/projection.settings.pixelsPerLabel + 1;
    var xRange = projection.viewport.xmax - projection.viewport.xmin;
    var yRange = projection.viewport.ymax - projection.viewport.ymin;
    var exactX = xRange/(expectedX-1);
    var exactY = yRange/(expectedY-1);

    var stepModeX, stepModeY;

    if (!projection.settings.xAxisPiLabels || projection.settings.polarMode) {
      stepModeX = RATIONAL_STEPS;
    } else if (exactX >= 1) {
      stepModeX = PI_STEPS;
    } else {
      stepModeX = PI_FRAC_STEPS;
    }
    
    var bestX = _bestStep(exactX, stepModeX);

    if (!projection.settings.yAxisPiLabels || projection.settings.polarMode) {
      stepModeY = RATIONAL_STEPS;
    } else if (exactY >= 1) {
      stepModeY = PI_STEPS;
    } else {
      stepModeY = PI_FRAC_STEPS;
    }
    
    var bestY = _bestStep(exactY, stepModeY);

    // If the axes have similar extents, prefer to choose the same steps for
    // x and y.
    if (stepModeX === stepModeY) {
      var maxRatio = projection.settings.polarMode ? Infinity : 2;
      var pixel_scale_ratio = (width/xRange) / (height/yRange);
      if (pixel_scale_ratio >= 1 && pixel_scale_ratio <= maxRatio) {
        bestX = bestY;
      } else if( pixel_scale_ratio <= 1 && pixel_scale_ratio >= 1/maxRatio ) {
        bestY = bestX;
      }
    }

    return {
      majorStepX: bestX.major,
      minorStepX: bestX.minor,
      majorStepY: bestY.major,
      minorStepY: bestY.minor
    };
  };

});

return GridLayer;
});

define('graphing/poi',[], function(){

// This is a very coupled class. It should be used along side GraphSketch.
function POI(x, y, type, sketch, branch) {
  this.x = x;
  this.y = y;
  this.type = type;
  this.sketch = sketch;
  this.branch = branch;
}

POI.prototype.getGraphMode = function () {
  return this.sketch.branches[this.branch].graphMode;
};

POI.prototype.getCompiledFunction = function () {
  return this.sketch.branches[this.branch].compiled.fn;
};

POI.prototype.isOpen = function () {
  return this.sketch.openPOI.indexOf(this) >= 0;
};

POI.prototype.close = function () {
  var index = this.sketch.openPOI.indexOf(this);
  if (index === -1) return false;
  
  this.sketch.openPOI.splice(index,1);
  return true;
};

POI.prototype.open = function () {
  if (this.isOpen()) return false;

  this.sketch.openPOI.push(this);
  return true;
};

return POI;
});

define('graphing/graphsketch',['require','math/poi','./poi','math/distance','graphing/graphmode'],function(require){
  var POITYPE = require('math/poi');
  var POI = require('./poi');
  var Distance = require('math/distance');
  var GRAPHMODE = require('graphing/graphmode');

function GraphSketch (id, branches) {
  // mutable properties
  this.color = '#000000';
  this.style = 'normal';
  this.visible = true;
  this.showPOI = false;
  this.showHighlight = false;
  this.openPOI = []; // the points that are opened and visible
  this.hiddenOpenPOI = []; // the points that were opened previously,
                           // but not mapped to screen any longer.
  // immutable properties
  this.id = id;
  this.branches = branches !== undefined ? branches : [];
}

// looks inside the branches and finds POI. Only needs to do this
// once because branches are immutable. This caches the results. Also
// note that this implementation postpones the conversion from one
// large array of numbers to array of objects until someone actually
// cares about this graphsketch's poi.
GraphSketch.prototype.getPOI = function () {
  
  if (this.__cachedPOI) return this.__cachedPOI;
  
  var branch, graphMode;
  this.__cachedPOI = [];
  for (var i=0; i<this.branches.length; i++) {
    branch = this.branches[i];
    graphMode = branch.graphMode;
    
    var pois = branch.poi;
    if (graphMode === GRAPHMODE.X || graphMode === GRAPHMODE.Y) {
      this._pushPOI(pois.zeros, i, POITYPE.ZERO);
      this._pushPOI(pois.intercept, i, POITYPE.INTERCEPT);
      this._pushPOI(pois.extrema, i, POITYPE.EXTREMUM);
      this._pushPOI(pois.intersections, i, POITYPE.INTERSECTION);
    } else if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {
      this._pushPOI(pois.defined, i, POITYPE.DEFINITION);
    }
  }

  return this.__cachedPOI;
};

GraphSketch.prototype._pushPOI = function (pois, i, type) {
  if (!pois) return;
  
  for (var j=0, plen = pois.x.length; j < plen; j++) {
    
    var poi = new POI();
    poi.type = type;
    poi.x = pois.x[j];
    poi.y = pois.y[j];
    poi.branch = i;
    poi.sketch = this;
    if (pois.intersects) poi.intersects = pois.intersects[j];
    
    this.__cachedPOI.push(poi);
  }
};

GraphSketch.prototype.updateIntersections = function (intersections) {
  for (var i = 0, ilen = this.branches.length; i < ilen; i++) {
    this.branches[i].poi.intersections = intersections[i];
  }
  this.__cachedPOI = undefined;
  this.getPOI();
  this.reopenPOIFrom(this);
};

GraphSketch.prototype.updateFrom = function (sketch) {
  if (!sketch) return;

  this.visible = true;

  if (sketch.openPOI.length || sketch.hiddenOpenPOI.length) {
    this.reopenPOIFrom(sketch);
  }

  this.showPOI = sketch.showPOI;
  this.showHighlight = sketch.showHighlight;
};

// TODO - change all the cryptic variable names to meaningful names
GraphSketch.prototype.reopenPOIFrom = function (sketch) {
  var openPOI = [];
  var hiddenOpenPOI = [];
  var pois, n_pts, min, n_j, o_pt, n_pt;
  var t_poi, poi, poi_type;
  var i, j;

  var newPoints = {};
  var oldPoints = {};

  // categorize all new poi
  pois = this.getPOI();

  for (i=0; i<pois.length; i++) {
    poi = pois[i];
    poi_type = poi.type;

    if (!newPoints[poi_type]) {
      newPoints[poi_type] = [poi];
    } else {
      newPoints[poi_type].push(poi);
    }
    
  }
  
  // categorize all old poi
  pois = sketch.openPOI.concat(sketch.hiddenOpenPOI);
  for (i=0; i<pois.length; i++) {
    poi = pois[i];
    poi_type = poi.type;

    if (!oldPoints[poi_type]) {
      oldPoints[poi_type] = [poi];
    } else {
      oldPoints[poi_type].push(poi);
    }

  }
  
  // reopen the new points that were closest to the old opened points
  for (var type in oldPoints) {
    t_poi = oldPoints[type];
    n_pts = newPoints[type] || [];

    for (i = t_poi.length-1; i >= 0; i--) {
      o_pt = t_poi[i];
      min = Infinity;
      n_j = -1;

      for (j = n_pts.length-1; j>=0; j--) {
        n_pt = n_pts[j];
        if (!n_pt) continue;
        // Don't allow intersections to jump between functions.
        if (n_pt.intersects !== o_pt.intersects) continue;

        var dis = Distance.hypot(o_pt.x-n_pt.x, o_pt.y-n_pt.y);
        if (dis < min) {
          n_j = j;
          min = dis;
        }
      }

      if (n_j != -1) {
        openPOI.push(n_pts[n_j]); // open the poi again
        n_pts[n_j] = null;
      } else {
        hiddenOpenPOI.push(o_pt); // mark point as opened but not mapped to screen
      }
    }
  }
  
  this.openPOI = openPOI;
  this.hiddenOpenPOI = hiddenOpenPOI;
};

return GraphSketch;
});

define('graphing/tracelayer',['require','pjs','./domlayer','./poi','./poilabelslayer'],function (require) {
  var P = require('pjs');
  var DOMLayer = require('./domlayer');
  var POI = require('./poi');
  var POILabelsLayer = require('./poilabelslayer');

  var TraceLayer = P(DOMLayer, function(layer, _super) {
    layer.init = function () {
      _super.init.apply(this, arguments);
      this.$.addClass('trace-layer');
    };

    layer.redraw = function (projection) {

      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);

      // Clear out the drawing area
      this.dom_node.find('.tracept').remove();

      var poi = this.traceInfo ? this.traceInfo.pt : null;
      if (!poi) return;

      var screen_x = projection.mapx(poi.x);
      var screen_y = projection.mapy(poi.y);

      // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
      if (
        screen_x > -20 && screen_y > -20 &&
        screen_x < projection.screen.width+20 && screen_y < projection.screen.height+20
      ) {

        // TODO - this is nasty. the createSinglePOI assumes that we pass in an
        //        instance of the POI class. traceInfo.pt is not a POI. Putting
        //        this here just to test tracing for now.
        var real_poi = new POI(poi.x,
                               poi.y,
                               POI.ZERO,
                               this.traceInfo.branchInfo.sketch,
                               this.traceInfo.branchInfo.branch);

        var dom_poi = POILabelsLayer.createSinglePOI(real_poi, projection.viewport);
        dom_poi.css({
          left: screen_x + "px",
          top: screen_y + "px"
        });
        dom_poi.addClass('temp');
        dom_poi.removeClass('poi');
        dom_poi.find('.pt').css('background-color', real_poi.sketch.color);
        dom_poi.find('.pt').css('border-color', real_poi.sketch.color);
        this.dom_node.append(dom_poi);

      }
    };
  });

  return TraceLayer;
});

define('graphing/movablepointslayer',['require','pjs','jquery','./domlayer','graphing/graphmode'],function (require) {
  var P = require('pjs');
  var $ = require('jquery');
  var DOMLayer = require('./domlayer');
  var GRAPHMODE = require('graphing/graphmode');

  //collection of movablePoints that are rendered to the DOM
  // $ is a handle to the jquery element
  // shouldGarbageCollect is a flag
  var renderedMovablePoints = {};

  var MovablePointsLayer = P(DOMLayer, function(layer, _super){
   
    // can't use jquery addClass and removeClass because they are slow on ipad.
    // the problem appears to be that jquery implementation keeps setting the
    // className property of the element even if nothing has changed. In turn,
    // ios appears to rerender everything since .className was set. So we only
    // add/remove the class if it'll change the className of the body.
    var body = $('body');
    
    function addGlobalClass (className) {
      if (!body.hasClass(className)) {
        body.addClass(className);
      }
    }
    function removeGlobalClass (className) {
     if (body.hasClass(className)) {
       body.removeClass(className);
     }
    }
   
    layer.redraw = function (projection, graphSketches) {

      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);
      
      // clear out hoveredSketchId if the sketch is gone
      var hoveredSketch = graphSketches[this.hoveredSketchId];
      if (!hoveredSketch) {
        this.hoveredSketchId = null;
      }
      
      // clear out pressedSketchId if the sketch is gone
      var pressedSketch = graphSketches[this.pressedSketchId];
      if (!pressedSketch) {
        this.pressedSketchId = null;
      }
      
      // Iterate through each graphSketch, find the opened poi and draw them
      // also saves which ones were drawn.
      var savedPOI = [];
      
      for (var id in renderedMovablePoints) {
        renderedMovablePoints[id].shouldGarbageCollect = true;
      }

      for (id in graphSketches) {
        var sketch = graphSketches[id];
        if (!sketch.visible) continue;
        
        var styles = {
          hovered: sketch === hoveredSketch,
          pressed: sketch === pressedSketch
        };
        
        var point = drawMovablePoint(sketch, this.dom_node, projection, styles);
        if (point) {
          savedPOI.push(point);
        }
      }
      
      
      for (id in renderedMovablePoints) {
        if (renderedMovablePoints[id].shouldGarbageCollect) {
          renderedMovablePoints[id].$.remove();
          delete(renderedMovablePoints[id]);
        }
      }
      
      if (hoveredSketch && hoveredSketch.visible) {
         addGlobalClass('mouse-over-movable-point');
      } else {
         removeGlobalClass('mouse-over-movable-point');
      }
      
      if (pressedSketch && pressedSketch.visible) {
         addGlobalClass('dragging-movable-point');
      } else {
         removeGlobalClass('dragging-movable-point');
      }
           
      this.savedPOI = savedPOI;
    };
    
    layer.getDrawnPOI = function () {
      return this.savedPOI;
    };
    
  });

  var drawMovablePoint = function (sketch, dom, projection, styles) {
    
    if (!sketch.branches ||
         sketch.branches.length !== 1 ||
         sketch.branches[0].graphMode !== GRAPHMODE.XYPOINT_MOVABLE) {
           return;
    }

    var poi = sketch.getPOI()[0];
    var screen_x = projection.mapx(poi.x);
    var screen_y = projection.mapy(poi.y);
    
    if (!(sketch.id in renderedMovablePoints)) {
      var $el = $("<div class='movable-point'><div class='background'></div><div class='dot'></div></div>");
      dom.append($el);
      renderedMovablePoints[sketch.id] = {
        $: $el,
        shouldGarbageCollect: true
      };
    }

    var dom_poi = renderedMovablePoints[sketch.id].$;

    // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
    if (
      screen_x > -20 && screen_y > -20 &&
      screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
    ) {
      dom_poi.css({
        left: screen_x + "px",
        top: screen_y + "px",
        backgroundColor: sketch.color
      });

      dom_poi.toggleClass('highlight', !!sketch.showHighlight);
      dom_poi.toggleClass('simulate-hovered', !!styles.hovered);
      dom_poi.toggleClass('simulate-active', !!styles.pressed);
      
      //don't garbage collect this point
      renderedMovablePoints[sketch.id].shouldGarbageCollect = false;
    }

    return poi;
  };

return MovablePointsLayer;
});
define('graphing/grapher',['require','jquery','lib/browser','./viewport','./viewporttransformation','./screen','./poidotslayer','./poilabelslayer','./gridlayer','./graphsketch','./canvaslayer','./graphslayer','./projection','./tracelayer','./movablepointslayer','math/poi'],function(require){
  var $ = require('jquery');
  var Browser = require('lib/browser');
  var Viewport = require('./viewport');
  var ViewportTransformation = require('./viewporttransformation');
  var Screen = require('./screen');
  var POIDotsLayer = require('./poidotslayer');
  var POILabelsLayer = require('./poilabelslayer');
  var GridLayer = require('./gridlayer');
  var GraphSketch = require('./graphsketch');
  var CanvasLayer = require('./canvaslayer');
  var GraphsLayer = require('./graphslayer');
  var Projection = require('./projection');
  var TraceLayer = require('./tracelayer');
  var MovablePointsLayer = require('./movablepointslayer');
  var POI = require('math/poi');

// This is the guy you talk to in order to allocate/deallocate graph layers.
// container is the <div> element that holds the graph area. Grapher handles resize automatically.
// onRecompute is the handler that should be called when a recompute is requested.
// onRecompute(viewport as Viewport, screen as Screen)
function Grapher(container, settings) {
    this.container = container;
    this.$ = $(container);

    this.viewport = new Viewport();
    this.screen = new Screen(this.$.width(), this.$.height());

    // a reference to an UnderscoreModel that we can ask for settings values
    this.settings = settings;

    this.$.css('overflow', 'hidden');
    // gridlines
    this.gridLayer = GridLayer(this.screen.width, this.screen.height);
    this.$.append( this.gridLayer.$ );

    // poi dots
    this.poiDotsLayer = POIDotsLayer(this.screen.width, this.screen.height);
    this.$.append( this.poiDotsLayer.$ );
    
    // graphs
    this.graphsLayer = GraphsLayer(this.screen.width, this.screen.height);
    this.$.append( this.graphsLayer.$ );

    // screenshot layer
    this.$.append('<div class="screenshot"></div>');

    this.movablePointsLayer = MovablePointsLayer(this.screen.width, this.screen.height);
    this.movablePointsLayer.$.css('z-index', '0');
    this.$.append( this.movablePointsLayer.$ );

    // poi labels (and opened dots)
    this.poiLabelsLayer = POILabelsLayer(this.screen.width, this.screen.height);
    // some weird interaction with overflow:hidden requires a z-index to be
    // set for openpoi to not flicker.
    this.poiLabelsLayer.$.css('z-index', '0');
    this.$.append( this.poiLabelsLayer.$ );
    
    // trace layer
    this.traceLayer = TraceLayer(this.screen.width, this.screen.height);
    // some weird interaction with overflow:hidden requires a z-index to be
    // set for the tracing label to not flicker.
    this.traceLayer.$.css('z-index', '0');
    this.$.append( this.traceLayer.$ );
     
    // needed to tell IE9 that the layer should steal mouse events.
    if (Browser.IS_IE9) {
      this.traceLayer.$.addClass('transparent-bg');
    }
    
    this.transformation = new ViewportTransformation();

    // Which axes are currently being scaled. Managed by GraphController.
    // 'x', 'y', 'both', or undefined
    this.scaleAxis = undefined;

    this.__transient = false;
    this.graphSketches = {};
    this.__sketchOrder = [];
    this.selectedId = null;
    return this;
}

Grapher.prototype.setSketchOrder = function (drawOrder) {
  this.__sketchOrder = drawOrder;
  this.redrawGraphsLayer();
};

Grapher.prototype.clear = function () {
  this.graphSketches = {};
};

Grapher.prototype.getGraphSketch = function(graphId) {
  if (graphId in this.graphSketches) {
    return this.graphSketches[graphId];
  } else {
    return null;
  }
};
  
Grapher.prototype.addGraphSketch = function(sketch) {
  this.graphSketches[sketch.id] = sketch;
};

Grapher.prototype.removeGraphSketch = function(graphId) {
  delete this.graphSketches[graphId];
};
 
Grapher.prototype.createProjection = function () {
  var projection = new Projection(this.screen, this.viewport, this.settings);
  
  if (this.isInTransientState()) {
    return this.transformation.transformProjection(projection);
  } else {
    return projection;
  }
};

Grapher.prototype.computeDefaultViewport = function () {
  var viewport = new Viewport(-10, 10, -10, 10);
  viewport.squareYAxis(this.screen);
  viewport.round(this.screen);
  
  return viewport;
};

// Updates the screen sizes of all of the layers and requests a redraw, viewport stays the same.
Grapher.prototype.updateScreenSize = function(w, h) {
    if (w<=0 || h<=0) return;
    if (this.screen.width === w && this.screen.height === h) return false;
    this.$.width(w);
    this.$.height(h);

    this.screen.width = w;
    this.screen.height = h;
    return true;
};
 
Grapher.prototype.beginTransientState = function() {
  if (this.isInTransientState()) return;

  var projection = this.createProjection();
  this.graphsLayer.saveUnscaledCanvas(projection);

  this.__transient = true;
};

Grapher.prototype.endTransientState = function() {
  if (!this.isInTransientState()) return;
  var projection = this.createProjection();
  this.viewport = projection.viewport;
  this.viewport.round(projection.screen);
  this.settings.setProperty(
    'squareAxes',
    this.viewport.isSquare(projection.screen)
  );
  this.transformation = new ViewportTransformation();
  this.graphsLayer.releaseUnscaledCanvas();
  this.__transient = false;
};

Grapher.prototype.isInTransientState = function () {
  return this.__transient;
};

Grapher.prototype.hide = function (id) {
  var sketch = this.getGraphSketch(id);
  if (sketch) sketch.visible = false;
};

Grapher.prototype.select = function (id) {
  var currentSketch = this.getGraphSketch(this.selectedId);
  if (currentSketch) currentSketch.showPOI = currentSketch.showHighlight = false;
  var newSketch = this.getGraphSketch(id);
  if (newSketch) newSketch.showPOI = newSketch.showHighlight = true;
  this.selectedId = id;
};

Grapher.prototype.updateSketch = function (id, graphData) {
  //Pause updates while zooming, to stay in sync with cached canvas
  if(this.isInTransientState()) return;
  var currentSketch = this.getGraphSketch(id);
  
  //TODO When does this happen?
  if (!graphData.length) return this.hide(id);
  
  var newSketch = new GraphSketch(id, graphData);
  //TODO - handle differently-colored branches
  newSketch.color = graphData[0].color;
  newSketch.style = graphData[0].style;
  newSketch.updateFrom(currentSketch);
  newSketch.showPOI = newSketch.showHighlight = (String(id) === String(this.selectedId));
  this.addGraphSketch(newSketch);
};

Grapher.prototype.updateIntersections = function (id, intersections) {
  var sketch = this.getGraphSketch(id);
  if (sketch) sketch.updateIntersections(intersections);
};

Grapher.prototype.redrawAllLayers = function() {
  this.cancelRedrawSlowly();
  this.redrawGridLayer();
  this.redrawContentLayers();
};

Grapher.prototype.redrawContentLayers = function(){
  this.cancelRedrawSlowly();
  this.redrawGraphsLayer();
  this.redrawPOILayer();
  this.redrawTraceLayer();
  this.redrawMovablePointsLayer();
};

Grapher.prototype.cancelRedrawSlowly = function(){
  clearTimeout(this.redraw_slowly_timeout);
  this.redraw_slowly_timeout = null;
};

Grapher.prototype.redrawSlowly = function(delay, step, n){
  //This is an intentional slow-down used on initial graph loads to give a line-by-line drawing effect.
  //It draws only the first n graphs, and calls itself repeatedly on a timeout until all layers are drawn
  //Every delay ms, it draws step more graphs
  if(typeof(delay) === 'undefined'){
    delay = 30;
  }
  if(typeof(step) === 'undefined'){
    step = 1;
  }
  if(typeof(n) === 'undefined'){
    this.cancelRedrawSlowly();
    n = 0;
  }

  this.redrawGridLayer(); //Always draw grid first
  var sketches_to_draw = {};
  var stopped_early = false;
  var i = 0;
  for(var id in this.graphSketches){
    if(i++ > n){
      stopped_early = true;
      break;
    }
    sketches_to_draw[id] = this.graphSketches[id];
  }
  this.graphsLayer.redraw(this.createProjection(), sketches_to_draw, this.__sketchOrder);

  if(stopped_early){
    var self = this;
    //Store timeout so that this can be interrupted
    this.redraw_slowly_timeout = setTimeout(function(){self.redrawSlowly(delay, step, n+step)}, delay);
  }
  else{
    //Only draw trace and POI if this was our last iteration
    this.redrawPOILayer();
    this.redrawTraceLayer();
    this.redrawMovablePointsLayer();

    this.redraw_slowly_timeout = null;
  }
};

Grapher.prototype.redrawGridLayer = function () {
  if (!this.screen.height || !this.screen.width) return;
  this.gridLayer.redraw(this.createProjection(), this.scaleAxis);
};

Grapher.prototype.redrawGraphsLayer = function () {
  if (!this.screen.height || !this.screen.width) return;
  if (!this.isInTransientState()) {
    this.graphsLayer.redraw(this.createProjection(), this.graphSketches, this.__sketchOrder);
  } else {
    this.graphsLayer.paintScaledCanvas(this.transformation);
  }
};

Grapher.prototype.redrawMovablePointsLayer = function () {
  if (!this.screen.height || !this.screen.width) return;
  this.movablePointsLayer.redraw(this.createProjection(), this.graphSketches);
};

Grapher.prototype.redrawPOILayer = function () {
  if (!this.screen.height || !this.screen.width) return;
  this.poiDotsLayer.redraw(this.createProjection(), this.graphSketches);
  this.poiLabelsLayer.redraw(this.createProjection(), this.graphSketches);
};

Grapher.prototype.redrawTraceLayer = function () {
  if (!this.screen.height || !this.screen.width) return;
  this.traceLayer.redraw(this.createProjection());
};

Grapher.prototype.screenshot = function () {
  
  var screen = this.screen;
  var printLayer = CanvasLayer(screen.width, screen.height);
  var ctx = printLayer.ctx;
  var projection = this.createProjection();

  // Make a white background, since transparent backgrounds are funny in some
  // environments.
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, screen.width, screen.height);
  
  this.settings.takingScreenshot = true;
  this.gridLayer.redrawToCtx(ctx, projection);
  this.graphsLayer.redrawToCtx(ctx, projection, this.graphSketches);
  this.settings.takingScreenshot = false;
  
  return printLayer.canvas_node.get(0).toDataURL("image/png");
};

Grapher.prototype.thumbnail = function (width, height) {
  var screen = new Screen(width, height);
  
  var printLayer = CanvasLayer(width, height);
  var ctx = printLayer.ctx;
  
  var settings = this.settings.clone();
  settings.setProperty('showLabels', false);
  var viewport = this.viewport.clone();
  
  if (viewport.isSquare(this.screen)) viewport.squareCrop(screen);
  
  var projection = new Projection(screen, viewport, settings);
  
  // Make a white background, since transparent backgrounds are funny in some
  // environments.
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, screen.width, screen.height);
  
  this.settings.takingScreenshot = true;
  this.gridLayer.redrawToCtx(ctx, projection);
  this.graphsLayer.redrawToCtx(ctx, projection, this.graphSketches);
  this.settings.takingScreenshot = false;
  
  return printLayer.canvas_node.get(0).toDataURL("image/png");
};

Grapher.prototype.getOpenIntersectionIds = function () {
  var openPOI;
  var hiddenOpenPOI;
  var i;

  var intersectIds = {};

  for (var id in this.graphSketches) {
    if (!this.graphSketches.hasOwnProperty(id)) continue;
    openPOI = this.graphSketches[id].openPOI;
    for (i = openPOI.length - 1; i >= 0; i--) {
      if (openPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
    }
    hiddenOpenPOI = this.graphSketches[id].hiddenOpenPOI;
    for (i = hiddenOpenPOI.length - 1; i >= 0; i--) {
      if (hiddenOpenPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
    }
  }

  return intersectIds;
};

return Grapher;
});

define('graphing/poicontroller',['require','jquery','math/distance','lib/rounding','graphing/graphmode'],function(require){
  var $ = require('jquery');
  var Distance = require('math/distance');
  var Rounding = require('lib/rounding');
  var GRAPHMODE = require('graphing/graphmode');

function POIController (grapher) {
  this.manager = grapher;
  this.$ = this.manager.$;
  
  this.triggerMovePoint = function (changes) {};
  this.triggerStartTracingBranch = function () {};
  this.triggerEmptyTouchStart = function () {};
  this.triggerStartMovingPoint = function () {};
  this.triggerStopMovingPoint = function () {};
  this.triggerPointSelected = function () {};

  this.addTouchEventHandlers();
  this.addHoverEventHandler();
}

POIController.prototype.getToleranceByDevice = function (device) {
  return device === 'touch' ? 20 : 10;
};

POIController.prototype.addHoverEventHandler = function () {
  
  $(document).on('tapmove', function(evt){
    
    // only want this handler to proceed on mouse-based interactions
    if (evt.device === 'touch') return;
    
    var screen_pt = this.getMouseRelativeToGrapher(evt);
    var tolerance = this.getToleranceByDevice(evt.device);
    
    var realPointInfo = this.getPointUnderPoint(screen_pt, tolerance);
    var poi = null;
    var movableSketchId = null;
    
    // if there is a real point under the mouse, then don't show a POI hover
    if (realPointInfo) {
      var movable = realPointInfo.sketch.branches[realPointInfo.branch].graphMode === GRAPHMODE.XYPOINT_MOVABLE;
      movableSketchId = movable ? realPointInfo.sketch.id : null;
    } else {
      poi = this.getPOIUnderPoint(screen_pt, tolerance);
    }
    
    if (poi != this.manager.poiLabelsLayer.hoveredPOI) {
      this.manager.poiLabelsLayer.hoveredPOI = poi;
      this.manager.redrawPOILayer();
    }
    
    if (movableSketchId != this.manager.movablePointsLayer.hoveredSketchId) {
      this.manager.movablePointsLayer.hoveredSketchId = movableSketchId;
      this.manager.redrawMovablePointsLayer();
    }
       
  }.bind(this));
  
};

POIController.prototype.addTouchEventHandlers = function () {

  // hack to prevent dblclick zoom from working when on poi. Ideally, this
  // would happen more naturally. Maybe we wouldn't listen for dblclick within
  // the graphcontroller. Only way that could happen is if we move these events
  // to click based instead of mousedown based.
  this.$.on('dblclick', function (evt){
      var screen_pt = this.getMouseRelativeToGrapher(evt);
      var tolerance = this.getToleranceByDevice(evt.device);
      if (this.getPointUnderPoint(screen_pt, tolerance) ||
          this.getPOIUnderPoint(screen_pt, tolerance) ||
          this.getBranchInfoUnderPoint(screen_pt, tolerance)) {
            
        evt.preventDefault();
        evt.handle();
      }
  }.bind(this));

  this.$.on('tapstart', function (evt) {
      var screen_pt = this.getMouseRelativeToGrapher(evt);
      var tolerance = this.getToleranceByDevice(evt.device);
      
      $(document.activeElement).blur();

      // check if we're on a point list
      var pointInfoUnderMouse = this.getPointUnderPoint(screen_pt, tolerance);
      if (pointInfoUnderMouse) {
        
        this.triggerStartMovingPoint(pointInfoUnderMouse.id);
        this.startMovingPoint(pointInfoUnderMouse);
        
        evt.handle(); //prevents panning/zooming
        return;
      }
      
      // check if we're on a POI. If so, either open or close the POI under
      // the mouse.
      if (this.togglePOIUnderPoint(screen_pt, tolerance)) {
        evt.handle(); //prevents panning/zooming
        return;
      }
            
      // check if we're on a curve
      var branchInfoUnderMouse = this.getBranchInfoUnderPoint(screen_pt, tolerance);
      if (branchInfoUnderMouse) {
        
        // selects expression
        this.triggerStartTracingBranch(branchInfoUnderMouse.id);
        this.startTracingBranch(branchInfoUnderMouse, screen_pt);
        
        evt.handle(); //prevents panning/zooming
        return;
      }

      this.triggerEmptyTouchStart();
  }.bind(this));
};

POIController.prototype.getMouseRelativeToGrapher = function (evt) {
  var pageOffset = this.$.offset();
  var pt = evt.touches ? evt.touches[0] : evt;
  
  return {x: pt.pageX - pageOffset.left, y: pt.pageY - pageOffset.top};
};

//modified to give precedence to a MOVABLE POINT
POIController.prototype.getPointUnderPoint = function (screen_pt, tolerance) {
  var minDistance = tolerance;
  var pointInfo = null;
  var foundMovablePoint = false;
  var sketches = this.manager.graphSketches;
  var projection = this.manager.createProjection();
  for (var id in sketches) {
    var sketch = sketches[id];
    if(!sketch || !sketch.visible) continue;

    var branches = sketch.branches;
    if (!branches || !branches.length) continue;
    
    for (var i=0; i<branches.length; i++) {
      var isMovable = (branches[i].graphMode === GRAPHMODE.XYPOINT_MOVABLE);
      if (
        isMovable ||
        // only search non-movable branches if we haven't alread found a movable point
        (!foundMovablePoint && branches[i].graphMode === GRAPHMODE.XYPOINT)
      ) {
        var list = branches[i].segments[0];

        for (var j = 0; j < list.length; j++) {
          var pt = list[j];
          var mapped = projection.map_pt({x: pt[0], y: pt[1]});
          var dis = Distance.hypot(mapped.x - screen_pt.x, mapped.y - screen_pt.y);
            
          if (
            dis < minDistance ||
            !foundMovablePoint && isMovable && dis < tolerance
          ) {
            minDistance = dis;
            pointInfo = { id: id, branch: i, sketch: sketch, x: pt[0], y: pt[1]};
          }
        }
      }
    }
  }
  
  return pointInfo;
};

POIController.prototype.getPOIUnderPoint = function (screen_pt, tolerance) {
  var projection = this.manager.createProjection();
  var poi = this.manager.poiLabelsLayer.getDrawnPOI();
      poi = poi.concat(this.manager.poiDotsLayer.getDrawnPOI());

      
  if (!poi.length) return null;

  var test_poi = poi[0];
  var mapped_poi = projection.map_pt(test_poi);
  var closest_distance = tolerance;
  var closest_poi = null;
    
  var test_distance = Distance.hypot(mapped_poi.x-screen_pt.x, mapped_poi.y-screen_pt.y);
  if (test_distance < closest_distance) {
    closest_poi = test_poi;
    closest_distance = test_distance;
  }
      
  for (var i=1; i<poi.length; i++) {
    test_poi = poi[i];
    mapped_poi = projection.map_pt(test_poi);
    
    test_distance = Distance.hypot(mapped_poi.x-screen_pt.x, mapped_poi.y-screen_pt.y);
    if (test_distance < closest_distance) {
      closest_distance = test_distance;
      closest_poi = test_poi;
    }
  }
  
  return closest_poi;
};

// because a POI can be in both the poiLabelsLayer and in
// the poiDotsLayer, it's possible that this function returns
// an array with duplicate elements. But, opened points will
// be returned at the start. Could possibly clean this up,
// but not too important because this really has only 1 purpose.
// That purpose is to allow us to open all POI at the exact same
// location as another one. The functions that use this don't care
// if a specific POI is contained within the returned array more
// than once.
POIController.prototype.getAllPOIAtSameLocation = function (pt) {
  if (!pt) return [];
  
  var same_poi = [];
  var openedPOI = this.manager.poiLabelsLayer.getDrawnPOI();
  var unopenedPOI = this.manager.poiDotsLayer.getDrawnPOI();
  var all_poi = openedPOI.concat(unopenedPOI);

  if (!all_poi.length) return [];

  for (var i=0; i<all_poi.length; i++) {
    var poi = all_poi[i];
    
    // doesn't handle the case where x or y is NaN, but in that
    // case I don't think we'd be able to assume the POI are at
    // the same location. NaN means hole and there's no guarantee
    // that the hole is in the same spot. At this point, we don't
    // have information about if this is a discontinuity or not and
    // if it's a discontinuity, we definitely don't know where it is.
    if (poi.x === pt.x && poi.y === pt.y) {
      same_poi.push(poi);
    }
  }
  
  return same_poi;
};

POIController.prototype.togglePOIUnderPoint = function (screen_pt, tolerance) {
  var poiUnderMouse = this.getPOIUnderPoint(screen_pt, tolerance);
  var allPOIUnderMouse = this.getAllPOIAtSameLocation(poiUnderMouse);

  if (allPOIUnderMouse.length) {
        
    // want to set all poi under mouse to open or all to closed
    var isOpen = allPOIUnderMouse[0].isOpen();
        
    for (var i=0; i<allPOIUnderMouse.length; i++) {
      if (isOpen) {
        allPOIUnderMouse[i].close();
            
        // hide hovered poi
        this.manager.poiLabelsLayer.hoveredPOI = null;
      } else {
        allPOIUnderMouse[i].open();
      }
    }

    this.manager.redrawPOILayer();
    return true;
  } else {
    return false;
  }
};

// TODO - cleanup
// returns an object containing the id, sketch, and the branch
POIController.prototype.getBranchInfoUnderPoint = function (screen_pt, tolerance) {

  var graphInfo = null;
  var minDis = tolerance;
  var projection = this.manager.createProjection();
  var pt = projection.reverse_map_pt(screen_pt);
  
  for (var id in this.manager.graphSketches) {
    var sketch = this.manager.graphSketches[id];
    if(!sketch || !sketch.visible) continue;

    var branches = sketch.branches;
    if (!branches || !branches.length) continue;
    
    for (var i=0; i<branches.length; i++) {
      var distance = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
      if (distance < minDis) {
        minDis = distance;
        graphInfo = { id: id, branch: i, sketch: sketch };
      }
    }
  }

  return graphInfo;
};

POIController.calculateDistanceFromBranch = function(branch, pt, projection) {

  var tmp_pt = POIController.getBranchesClosestPoint(branch, pt, projection);
  if(!tmp_pt || isNaN(tmp_pt.x) || isNaN(tmp_pt.y)) return Infinity;

  var xscale = projection.screen.width/(projection.viewport.xmax - projection.viewport.xmin);
  var yscale = projection.screen.height/(projection.viewport.ymax - projection.viewport.ymin);
  return Distance.hypot((pt.x - tmp_pt.x)*xscale, (pt.y - tmp_pt.y)*yscale);
};

POIController.getBranchesClosestPoint = function(branch, pt, projection) {

  // tables lack this, so we shouldn't don't try to see how close we are
  if (!branch || !branch.compiled || !branch.compiled.fn) return;
    
  var xscale = projection.screen.width/(projection.viewport.xmax - projection.viewport.xmin);
  var yscale = projection.screen.height/(projection.viewport.ymax - projection.viewport.ymin);
  
  var x = pt.x;
  var y = pt.y;
  
  switch(branch.graphMode) {
    case GRAPHMODE.Y:
    break;

    case GRAPHMODE.X:
    var tmp_swap = x;
    x = y;
    y = tmp_swap;
    tmp_swap = xscale;
    xscale = yscale;
    yscale = tmp_swap;
    break;

    default:
    return null;
  }
 
  var fn = branch.compiled.fn;
  var x0 = x;
  var x1 = x0 - 3 / xscale;
  var x2 = x0 + 3 / xscale;

  var y0 = y;

  var y1 = fn(x1);
  var y2 = fn(x2);
  var x_best;
  var p;

  if (isNaN(y1) || isNaN(y2)) {
    x_best = x0;
  } else {
    p = Distance.closestPointOnSegment(x, y, x1, y1, x2, y2);
    x_best = p[0];
  }

  var y_best = POIController.fillHole(fn, x_best, xscale, yscale, x0, y0);

  var smooth_start = 10;
  var smooth_end = 20;

  // this sequence of code creates a smooth transition between the guessed x and the mouse x
  var dis = Distance.hypot((x_best - x0)*xscale, (y_best - y0)*yscale);

  if (dis > smooth_start) {
    dis -= smooth_start;
    var perc = Math.min(1, dis/(smooth_end - smooth_start));
    x_best = (x0*perc + x_best*(1 - perc));
  }
  x_best = Rounding.shortestDecimalBetween(x_best - 1/(2*xscale), x_best + 1/(2*xscale));

  y_best = POIController.fillHole(fn, x_best, xscale, yscale, x0, y0);
  
  switch(branch.graphMode) {
    case GRAPHMODE.Y:
    return { x: x_best, y: y_best };
    
    case GRAPHMODE.X:
    return { y: x_best, x: y_best };
  }
};

POIController.prototype.startMovingPoint = function (branchInfo) {
  var move_occured = false;
  var pt = {
    x: branchInfo.x,
    y: branchInfo.y
  };
  var id = branchInfo.id;
  
  this.manager.movablePointsLayer.pressedSketchId = branchInfo.sketch.id;
  this.manager.redrawMovablePointsLayer();
  
  $(document).on('tapmove.movepoint', function (evt) {
    move_occured = true;
    
    var projection = this.manager.createProjection();
    var screen_pt = this.getMouseRelativeToGrapher(evt);
    
    // we are going to search within the square pixel around our mouse to
    // find the shortest decimal for x and for y. We get the topLeft and
    // bottomRight (in viewport units, not pixels) of that square pixel here.
    var tl = projection.reverse_map_pt({
      x: screen_pt.x - 0.5,
      y: screen_pt.y - 0.5
    });

    var br = projection.reverse_map_pt({
      x: screen_pt.x + 0.5,
      y: screen_pt.y + 0.5
    });
    
    this.triggerMovePoint(id, [
      Rounding.shortestDecimalBetween(tl.x, br.x),
      Rounding.shortestDecimalBetween(tl.y, br.y)
    ]);
  }.bind(this));
  
  $(document).on('tapend.movepoint tapcancel.movepoint', function (evt) {
    $(document).off('.movepoint');
    
    this.manager.movablePointsLayer.pressedSketchId = null;
    this.manager.redrawMovablePointsLayer();
    
    this.triggerStopMovingPoint(id);
    
    // if this was just a tap, then open a label for the point
    if (!move_occured) {
      var projection = this.manager.createProjection();
      var tolerance = this.getToleranceByDevice(evt.device);
      
      // figure out the exact location of the point on the screen
      var screen_pt = projection.map_pt({x: pt.x, y: pt.y});
      
      var sketch = this.manager.getGraphSketch(id);

      // save how many poi are open for this id
      var oldPOICount = sketch.openPOI.length;
      // toggle the poi
      this.togglePOIUnderPoint(screen_pt, tolerance);
      // check how many poi are open for this particular id now
      var newPOICount = sketch.openPOI.length;

      // notify that the point was clicked. If it was deselected, send null.
      if (newPOICount > oldPOICount) this.triggerPointSelected(id);
    }
  }.bind(this));
};

// TODO - duplicating some code here
POIController.prototype.startTracingBranch = function (branchInfo, screen_pt) {
  this.last_screen_pt = screen_pt;
  var projection = this.manager.createProjection();
  var pt = projection.reverse_map_pt(screen_pt);

  var sketch = branchInfo.sketch;
  var branch = sketch.branches[branchInfo.branch];
  var tracePt = POIController.getBranchesClosestPoint(branch, pt, projection);

  this.manager.traceLayer.traceInfo = {pt: tracePt, branchInfo: branchInfo};
  this.manager.redrawTraceLayer();

  $(document).on('tapmove.tracing', this.handleTraceUpdate.bind(this));
  $(document).on('tapend.tracing tapcancel.tracing', this.stopTracingBranch.bind(this));
};

POIController.prototype.stopTracingBranch = function (evt) {

  // if we're over an unopened hovered poi, open it
  var hoveredPOI = this.manager.poiLabelsLayer.hoveredPOI;
  if (hoveredPOI && !hoveredPOI.isOpen()) {
    hoveredPOI.open();
    this.manager.redrawPOILayer();
  }

  this.manager.traceLayer.traceInfo = null;
  this.manager.redrawTraceLayer();
  
  $(document).off('.tracing');
};

POIController.prototype.handleTraceUpdate = function(evt) {
  if(!this.manager.traceLayer.traceInfo) return;
  var projection = this.manager.createProjection();
  var screen_pt;
  if(evt){
    screen_pt = this.getMouseRelativeToGrapher(evt);
    this.last_screen_pt = screen_pt;
  } else {
    screen_pt = this.last_screen_pt;
  }
  var pt = projection.reverse_map_pt(screen_pt);
  var minDis = Infinity;
  var bestBranch = -1;
  
  var traceInfo = this.manager.traceLayer.traceInfo;
  var traceSketch = this.manager.graphSketches[traceInfo.branchInfo.sketch.id];
  traceInfo.branchInfo.sketch = traceSketch;
  var branches = traceInfo.branchInfo.sketch.branches;
  //Look up new branch each time

  // Loop through branches to find which we're closest too
  for(var i=0; i<branches.length; i++) {
    var branchDis = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
    if(branchDis < minDis) {
      bestBranch = i;
      minDis = branchDis;
    }
  }

  var branch = branches[bestBranch];
  var tracePt = branch ? POIController.getBranchesClosestPoint(branch, pt, projection) : null;
  
  this.manager.traceLayer.traceInfo.pt = tracePt;
  this.manager.redrawTraceLayer();
};

// TODO - might not belong here.. might be more appropriate in the math/poi.js
// TODO - probably better to be smarter about 'tiny offset'. should use a
//        dynmaic offset rather than always using 0.00000000001
POIController.fillHole = function(fn, x_val, xscale, yscale, x, y) {
  var y_val = fn(x_val);
  if (isFinite(y_val)) return y_val;
  
  var x_left =  x_val - 0.00000000001;
  var x_right = x_val + 0.00000000001;
  var y_left =  fn(x_left);
  var y_right = fn(x_right);

  if (isNaN(y_left) && isNaN(y_right)) return NaN;
  if (isNaN(y_left)) return y_right;
  if (isNaN(y_right)) return y_left;
  
  var dx_left = (x - x_left) * xscale;
  var dx_right = (x - x_right) * xscale;
  var dy_left = (y - y_left) * yscale;
  var dy_right = (y - y_right) * yscale;
  
  if (Distance.hypot(dx_left, dy_left) < Distance.hypot(dx_right, dy_right)) {
    return y_left;
  } else {
    return y_right;
  }
  
};

return POIController;
});

define('loadcss!vendor_css/tipsy/tipsy', function(){});
// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license
//
// Modified by Mike Haverstock to work with touchtracking.js to decide when
// to show tooltips and when not to. Problem is that this library doesn't 
// allow you to manually hide/show tooltips that are set with the 'live'
// option. That's because the 'live' option postpones tipsy instantiation for
// a specific node until an event bubbles up for that node. So, when you call
// .tipsy('show') for a live node, it sees that there is no .data('tipsy') set
// for the node and ignores the request. The solution is to not listen for
// mouseenter and mouseleave. Instead of those, you listen for 'tipsyshow' and
// 'tipsyhide'. Then, you manually hide/show tooltips by triggering 'tipsyshow'
// and 'tipsyhide' on that node. Then, the live code works perfectly fine. Now
// the only way to trigger tipsy is by manually triggering those events.
define('tipsy',['require','loadcss!vendor_css/tipsy/tipsy','jquery'],function(require) {
  require('loadcss!vendor_css/tipsy/tipsy');
  var $ = require('jquery');
  
  var openSticky = null;
  var ignoreStickyOpen = false;
    
  $(document).on('tap', '.tipsy-sticky', function (evnt) {
    
    // don't do anything. let the code that hides stickies close it.
    if (ignoreStickyOpen) {
      ignoreStickyOpen = false;
      return;
    }
      
    var opener = evnt.currentTarget;
    var $target = $(opener);
      
    // if the target doesn't have a tooltip, check if a child does
    if (!$target.attr('tooltip')) {
      $target = $target.find('[tooltip]').filter(':not([tooltip=""])');
    }

    // there should be exactly 1 tooltip to show
    if ($target.length !== 1) return;

    // ensure that the target is not display:none and no parent is display:none
    if ($target.css('display') === 'none') return;
    if ($target.parents().filter(function(){return $(this).css('display') === 'none'}).length) return;
      
    var options = $.extend({}, $.fn.tipsy.defaults);
    options.title = 'tooltip';
    options.gravity = 'nw';
      
    openSticky = new Tipsy($target[0], options);
    openSticky.show();
    openSticky.opener = opener;
  });

  $(document).on('tapstart keydown', function (evnt) {
    if (openSticky) {
      openSticky.hide();
        
      var opener = openSticky.opener;
      if (evnt.type === 'tapstart' && $(evnt.target).closest(opener).length ) {
        $(document).one('tapend', function (evnt2) {
          if ($(evnt2.target).closest(opener).length) {
            ignoreStickyOpen = true;
          }
        });
      }

      openSticky=null;
    }
  });
    
  function maybeCall(thing, ctx) {
    return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
  }
    
  function Tipsy(element, options) {
    this.$element = $(element);
    this.options = options;
    this.fixTitle();
  }

  Tipsy.prototype = {
    show: function() {
      var title = this.getTitle();
      if (title && !isTipsyDisabled()) {
        var $tip = this.tip();
               
        $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
        $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
        $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);
                
        var pos = $.extend({}, this.$element.offset(), {
          width: this.$element[0].offsetWidth,
          height: this.$element[0].offsetHeight
        });
                
        var tp, actualWidth = $tip[0].offsetWidth,
            actualHeight = $tip[0].offsetHeight,
            gravity = maybeCall(this.options.gravity, this.$element[0]);

        switch (gravity.charAt(0)) {
          case 'n':
            tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
            break;
          case 's':
            tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
            break;
          case 'e':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
            break;
          case 'w':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
            break;
        }
                
        if (gravity.length == 2) {
          if (gravity.charAt(1) == 'w') {
            tp.left = pos.left + pos.width / 2 - 15;
          } else {
            tp.left = pos.left + pos.width / 2 - actualWidth + 15;
          }
        }
                
        $tip.css(tp).addClass('tipsy-' + gravity);
        $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
        if (this.options.className) {
          $tip.addClass(maybeCall(this.options.className, this.$element[0]));
        }
                
        if (this.options.fadeIn) {
          $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'})
                     .animate({opacity: this.options.opacity}, this.options.fadeIn);
        } else {
          $tip.css({visibility: 'visible', opacity: this.options.opacity});
        }
                
        if (this.options.sticky) {
          $tip.addClass('sticky');
        }
                
        var self = this;
        var validateLoop = function () {
          self.validate();
          self.validateTimeout = setTimeout(validateLoop, 100);
        };
        validateLoop();
      }
    },
        
    hide: function() {
      clearTimeout(this.validateTimeout);
           
      if (this.options.fadeOut) {
        this.tip().stop().fadeOut(this.options.fadeOut, function() { $(this).remove(); });
      } else {
        this.tip().remove();
      }
    },
        
    fixTitle: function() {
      var $e = this.$element;
      if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
        $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
      }
    },
        
    getTitle: function() {
      var title, $e = this.$element, o = this.options;
      this.fixTitle();
      o = this.options;
      if (typeof o.title == 'string') {
        title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
      } else if (typeof o.title == 'function') {
        title = o.title.call($e[0]);
      }

      if (title) title = ('' + title).replace(/(^\s*|\s*$)/, "");
      return title || o.fallback;
    },
        
    tip: function() {
      if (!this.$tip) {
        this.$tip = $('<div class="tipsy"><div class="tipsy-arrow"></div><div class="tipsy-inner"></div></div>');
      }
      return this.$tip;
    },
        
    validate: function() {
      var hasTitle = !!this.getTitle();
      var inDom = false;

      if (hasTitle) {
        try {
          var node = this.$element[0];
               
          while (node) {
            if (node === document) {
              inDom = true;
              break;
            } else {
              node = node.parentNode;
            }
          }
        } catch (e) {}
      }
                        
      if (!inDom) {
        this.hide();
      }
    }
  };
    
  $.fn.tipsy = function(options) {
        
    if (options === true) {
      return this.data('tipsy');
    } else if (typeof options == 'string') {
      var tipsy = this.data('tipsy');
      if (tipsy) tipsy[options]();
      return this;
    }
        
    options = $.extend({}, $.fn.tipsy.defaults, options);
       
    options.fadeIn = options.fadeIn || options.fade;
    options.fadeOut = options.fadeOut || options.fade;
        
    function get(ele) {
      var tipsy = $.data(ele, 'tipsy');
      if (!tipsy) {
        tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
        $.data(ele, 'tipsy', tipsy);
      }
      return tipsy;
    }
        
    function enter(evnt) {
      // the tipsyshow event bubbles up the dom, so we only want to
      // listen to the event if the target is the same as the element
      // that is responding to the event. If this wasn't here then when
      // you move your mouse from a tipsy-enabled parent to a child, the
      // tipsyshow event would be fired from the child, bubble through
      // the parent, and get caught higher up. That would cause the 
      // already opened tooltip to close and fade in again. With this
      // code, we ignore the tipsyshow event because the target is the
      // the child that isn't tipsy-enabled.
      if (evnt.type === 'tipsyshow' && evnt.target !== this) return;

      // this element has a sticky open already            
      if (openSticky === this) return;
           
      var tipsy = get(this);
      tipsy.hoverState = 'in';
              
      if (options.delayIn === 0) {
        tipsy.show();
      } else {
        tipsy.fixTitle();
        setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
      }
    }
        
    function leave(evnt) {
      // we do this for the same reason we do it for the tipsyshow event.
      // look at the comment a few lines above for more information.
      if (evnt.type === 'tipsyhide' && evnt.target !== this) return;
  
      var tipsy = get(this);

      // if this is a sticky tooltip, don't close it on tapStart. If we
      // closed it now, it would flicker back on when we mouse up and
      // make it permanent. We'd like it to stay on the whole time.
      if (evnt.type === 'tapstart' && tipsy.options.sticky) return;

      tipsy.hoverState = 'out';
      if (options.delayOut === 0) {
        tipsy.hide();
      } else {
        setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
      }
    }
        
    if (!options.live) this.each(function() { get(this); });
       
    if (options.trigger != 'manual') {
      var eventIn  = options.trigger == 'hover' ? 'tipsyshow' : 'focus';
      var eventOut = options.trigger == 'hover' ? 'tipsyhide tapstart tapend tapcancel' : 'blur';
            
      if (options.live && options.delegate) {
        this.on(eventIn, options.delegate, enter).on(eventOut, options.delegate, leave);
      } else {
        var binder   = options.live ? 'on' : 'bind';
        this[binder](eventIn, enter)[binder](eventOut, leave);
      }
    }
        
    return this;
  };
    
  $.fn.tipsy.defaults = {
    className: null,
    delayIn: 0,
    delayOut: 0,
    fade: false,
    fadeIn: false,
    fadeOut: false,
    fallback: '',
    gravity: 'n',
    html: false,
    live: true,
    offset: 0,
    opacity: 1,
    title: 'title',
    trigger: 'hover'
  };
    
  // Overwrite this method to provide options on a per-element basis.
  // (remember - do not modify 'options' in place!)
  $.fn.tipsy.elementOptions = function(ele, options) {
    options = $.extend({}, options);
    
    var gravity = $(ele).attr('tipsy-gravity');
    if (gravity) {
      options.gravity = gravity;
    }
      
    var offset = parseInt($(ele).attr('tipsy-offset'), 10);
    if (!isNaN(offset)) {
      options.offset = offset;
    }
      
    return options;
  };
    
  $.fn.tipsy.autoNS = function() {
    return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
  };
    
  $.fn.tipsy.autoWE = function() {
    return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
  };
    
  /**
   * yields a closure of the supplied parameters, producing a function that takes
   * no arguments and is suitable for use as an autogravity function like so:
   *
   * @param margin (int) - distance from the viewable region edge that an
   *        element should be before setting its tooltip's gravity to be away
   *        from that edge.
   * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
   *        if there are no viewable region edges effecting the tooltip's
   *        gravity. It will try to vary from this minimally, for example,
   *        if 'sw' is preferred and an element is near the right viewable 
   *        region edge, but not the top edge, it will set the gravity for
   *        that element's tooltip to be 'se', preserving the southern
   *        component.
  */
  $.fn.tipsy.autoBounds = function(margin, prefer) {
    return function() {
			var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
          boundTop = $(document).scrollTop() + margin,
          boundLeft = $(document).scrollLeft() + margin,
          $this = $(this);

			if ($this.offset().top < boundTop) dir.ns = 'n';
			if ($this.offset().left < boundLeft) dir.ew = 'w';
			if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
			if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

			return dir.ns + (dir.ew ? dir.ew : '');
		};
	};
    
  // automatically instantiate tipsy for .tipsy-sticky classes
  $(document).tipsy({
    title: 'tooltip',
    wait: 0,
    live: true,
    delegate: '.tipsy-sticky',
    gravity: 'nw',
    sticky: true,
    fade: false
  });

  var disableLocks = 0;
  function isTipsyDisabled () {
    return disableLocks !== 0;
  }

  function removeDisableLock() {
    disableLocks--;
  }
  
  function addDisableLock() {
    disableLocks++;
  }
  
  return {
    isDisabled: isTipsyDisabled,
    removeDisableLock: removeDisableLock,
    addDisableLock: addDisableLock
  };
});

// fixes an issue with ghost clicks. borrowed the idea of using capture phase rather than bubble phase from:
//    https://developers.google.com/mobile/articles/fast_buttons?csw=1#ghost
//
// but the solution there is far from complete. It doesn't deal with focus being placed in textboxes still, and
// it doesn't prevent the ghost events from propagating down and back up through the dom. Mathquill listens for
// the mousedown and mouseup events, so when they were triggered erroneously, we should prevent them from propagating.
//
// the event handlers defined here need to be added before jquery has chance to add it's own listeners. This is
// especially important for the focus and blur events. The fact that touchtracking.js is split into two separate
// events here is unfortunate, but I think it's fine for now. There are talks of refactoring the touchtracking.js
// code anyways.
define('lib/ipad.ghostevents',['require'],function (require) {
  
  var inGhostEventMode = false;
  var startingActiveElement = null;
    
  function stopGhostEvent (evt) {
    if (inGhostEventMode) {
      evt.stopPropagation();
      evt.stopImmediatePropagation();
    }
  }
    
  function stopAndPreventGhostEvent (evt) {
    if (inGhostEventMode) {
      evt.preventDefault();
      evt.stopPropagation();
      evt.stopImmediatePropagation();
    }
  }
  
  // will get overriden by touchtracking.js
  // would be better not do things this way, but we need to split touchtracking.js into
  // a part that jquery depends on and a part that depends on jquery. This little inconvenience is what
  // splices all of touchtracking back together
  var touchTrackingCallbacks = {
    isGhostEvent: function (evt) {
      return false;
    }
  };
  
  // don't send ghost mousedwon events; someone might be listening for them
  document.addEventListener('mousedown', function (evt) {
    startingActiveElement = document.activeElement;
     
    inGhostEventMode = touchTrackingCallbacks.isGhostEvent(evt);
      
    // stop the mousedown event
    stopGhostEvent(evt);
  }, true);
    
  // don't send ghost mouseup events; someone might be listening for them
  document.addEventListener('mouseup', stopGhostEvent, true);
    
  // prevent links from being followed on ghost clicks.
  document.addEventListener('click', function (evt) {
    stopAndPreventGhostEvent(evt);
     
    // put focus where it was before the start of these events. the focusin and focusout
    // events fired from this will be stopped.
    if (inGhostEventMode && document.activeElement !== startingActiveElement) {
      if (document.activeElement) document.activeElement.blur();
      if (startingActiveElement) startingActiveElement.focus();
    }
      
    // anything after this is not a ghost event
    inGhostEventMode = false;
  }, true);

  // we prevent focus events from firing during ghost events
  document.addEventListener('focus', stopAndPreventGhostEvent, true);
  document.addEventListener('blur', stopAndPreventGhostEvent, true);
  
  return touchTrackingCallbacks;
});

/*
 * Touch/Mouse event handling gets complicated when a user has both a touch
 * device attached and a mouse attached. This tracking system helps deal with
 * that situation. We listen for the touch and mouse events on the document
 * and redispatch new, normalized events that work for many different devices
 * It's important to note that evt.stopPropagation() cannot be called on any
 * events that this is listening for.
 *
 * It normalizes 'touchStart' and 'mouseDown' to the 'tapstart' event.
 * It normalizes 'touchMove' and 'mouseMove' to the 'tapmove' event.
 * It normalizes 'touchEnd' and 'mouseUp' to the 'tapend' event.
 * It sends out a 'tap' event after a single touchStart and touchEnd.
 * It sends out a 'longhold' event if 500ms after a single 'tapstart'
 *    there hasn't been another event and the 'tapstart' is the only touch.
 *    Events have a 'wasLongheld' property that lets you know if a longhold
 *    has happened.
 *
 * TODO - dispatch 'doubletap' event after 'tap' and 'tap' near same location.
 *
 * One thing that it does is enforce that only one device, either touch or
 * or mouse, be used at a time. TOUCH_MODE starts on 'touchStart' and ends when
 * when all touches are lifted. MOUSE_MODE starts on 'mouseDown' and ends on
 * 'mouseUp'. When in TOUCH_MODE, it ignores all MOUSE_MODE events. When in
 * MOUSE_MODE, it ignores all TOUCH_MODE events.
 *
 * There is still one other slight complication. The ipad issues a 'mouseDown'
 * event after the 'touchEnd' event. That means following the logic above, we'd
 * leave TOUCH_MODE on touchEnd, and we'd get a mouseDown event. That'd put us
 * in MOUSE_MODE. We'd process the 'mouseDown' as if it were from a mouse, and
 * we'd happily process the 'mouseUp' event as well. In order to combat that,
 * on each 'mouseDown' event we check if we've recently been in TOUCH_MODE. We
 * enforce that half a second has passed since a person was in TOUCH_MODE
 * before they can enter MOUSE_MODE. If we decide that that's not ideal, we
 * can check if the mouseDown is near the 'touchStart' or 'touchEnd' events, but
 * that sounds like an unnecessary complication.
 *
 * One other interesting thing is that 'mouseMove' can be dispatched even when
 * the mouse button isn't pressed. For that reason, this doesn't require that
 * you be in MOUSE_MODE to listen for 'mouseMove' events.
 */
define('lib/touchtracking',['require','jquery','tipsy','lib/ipad.ghostevents'],function(require){
  
  var $ = require('jquery');
  require('tipsy');
  var GhostEvents = require('lib/ipad.ghostevents');
  
  GhostEvents.isGhostEvent = function (evt) {
    // not a ghost event if it's from a mouse
    if (mode !== TOUCH_MODE && !hasRecentlyEndedTouchMode()) {
      return false;
    }
      
    // it's a ghost event if the target of the event and our lastTarget aren't ancestors. What has happened is 
    // the dom moved around while the legacy events were being generated. We'll be ignoring the upcoming
    // legacy events.
    if (evt.target === lastTarget) return false;
    if (evt.target && $.contains(evt.target, lastTarget)) return false;
    if (lastTarget && $.contains(lastTarget, evt.target)) return false;
    
    return true;
  };
  
  var NO_MODE = 0;    // nothing pressed
  var TOUCH_MODE = 1; // finger is on screen
  var MOUSE_MODE = 2; // mouse is held down

  var mode = NO_MODE;
  var modeEvents = {};
  var modeTargets = [];
  var endTouchModeTime = 0;
  var endTouchModeTimeout = null;
  var lastTarget = null;
  
  var longholdTimeout = null;

  // returns an array of node, parent, grandparent, etc
  var getAncestors = function (node) {
    var nodes = [];
    while (node) {
      nodes.push(node);
      node = $(node).parent()[0];
    }

    return nodes;
  };

  var beginMode = function (evnt) {
    lastTarget = null;
    
    if (evnt.type === 'mousedown') {
      mode = MOUSE_MODE;
      modeTargets = getAncestors(evnt.target);
    } else {
      mode = TOUCH_MODE;
      modeTargets = getAncestors(evnt.originalEvent.touches[0].target);
    }

    // make the elements under the mouse look pressed
    $(modeTargets).addClass('depressed');
    
    // save original scroll positions for elements we've moused on
    $(modeTargets).each(function(){
      var elm = $(this);
      
      elm.data({
        originalScrollTop: elm.scrollTop(),
        originalScrollLeft: elm.scrollLeft()
      });
    });
        
    modeEvents = {};
  };
  
  var endMode = function (evnt) {
    lastTarget = null;
    
    // nothing is pressed anymore
    $('.depressed').removeClass('depressed');
    
    // check if any of the elements we originally moused on have scrolled.
    $(modeTargets).each(function(){
      var elm = $(this);
      var verticalOffset = elm.data('originalScrollTop') - elm.scrollTop();
      var horizontalOffset = elm.data('originalScrollLeft') - elm.scrollLeft();
      // save original scroll positions
      if (verticalOffset || horizontalOffset) {
        modeEvents.scroll = true;
      }
    });
    
    if (modeEvents.tapstart===1 && modeEvents.tapend===1 && !modeEvents.tapcancel && !modeEvents.scroll) {

      // get the x and y position of event.
      var x = evnt.device === 'mouse' ? evnt.pageX : evnt.originalEvent.changedTouches[0].pageX;
      var y = evnt.device === 'mouse' ? evnt.pageY : evnt.originalEvent.changedTouches[0].pageY;
      
      // run through the original modeTargets to see if the touchend is
      // with the bounds.
      var tap_escaped_boundary = false;
      for (var i=0; i<modeTargets.length && !tap_escaped_boundary; i++) {
        var target = $(modeTargets[i]);
        var offset = target.offset();
        
        // don't let tap events escape from a tapboundary.
        //
        // we allow you to mousedown on one element and mouseup on another. We
        // dispatch the tap event on the common ancestor. This allows you to by
        // imprecious when clicking. Sometimes that isn't ideal however. Say
        // you mouse down on a slider thumb and mouse up on the expression. By
        // default, we'd dispatch a tap event on the expression. That'd cause
        // the expression to be selected and focused. That's not what we want.
        // So, we define a tapboundary on the slider element. That will not
        // allow a tap event to start within the slider and end somewhere
        // outside of it. It must terminate within the boundary, otherwise we
        // won't dispatch a tap event at all.
        if (target.attr('tapboundary') === 'true') {
          tap_escaped_boundary = true;
        }
      
        if (offset) {
          
          // check if within top and left sides
          if (x < offset.left || y < offset.top) continue;
  
          // check if within right side
          if (x > offset.left + target.outerWidth()) continue;
          
          // check if within bottom side
          if (y > offset.top + target.outerHeight()) continue;
          
        }
        
        lastTarget = target[0];
        dispatchEvent('tap', evnt, lastTarget);
        break;
      }
    }

    // start the timer after we process the tap event.
    // this fires an event 1000ms in the future. If anything had caused the ipad
    // legacy events to get delayed, that'll also cause this function call to
    // get delayed. For us to switch back to MOUSE_MODE, this event must have
    // fired and it must not have been fired within 500ms of us trying to
    // switch to MOUSE_MODE
    if (mode === TOUCH_MODE) {
      endTouchModeTimeout = setTimeout(function(){
        clearTimeout(endTouchModeTimeout);
        endTouchModeTime = new Date().getTime();
      }, 1000);
    }
     
    modeTargets = [];
    mode = NO_MODE;
  };
    
  var hasRecentlyEndedTouchMode = function () {
    return endTouchModeTimeout || new Date().getTime() - endTouchModeTime < 500;
  };
  
  // it's important to clone touches because some devices keep updating the
  // same reference to a touch.
  var clone = function (touches) {
    var cloned = [];
    for (var i=0; i<touches.length; i++) {
      
      var touch = touches[i];
      cloned.push({
        
        identifier: touch.identifier,
        x: touch.pageX,
        y: touch.pageY,
        
        screenX: touch.screenX,
        screenY: touch.screenY,
        pageX: touch.pageX,
        pageY: touch.pageY,
        clientX: touch.clientX,
        clientY: touch.clientY
      });
    }
    return cloned;
  };
  
  var dispatchEvent = function (type, evnt, differentTarget) {
    
    // count an event type. used to figure out if we should send out
    // a tap and doubletap event.
    if (modeEvents[type.toLowerCase()] === undefined) {
      modeEvents[type.toLowerCase()] = 1;
    } else {
      modeEvents[type.toLowerCase()]++;
    }
        
    var newEvnt = $.event.fix(evnt.originalEvent);
        newEvnt.type = type;
        newEvnt.device = mode === TOUCH_MODE ? 'touch' : 'mouse';
        newEvnt.touches = clone(evnt.originalEvent.touches);
        newEvnt.changedTouches = clone(evnt.originalEvent.changedTouches);
        newEvnt.target = differentTarget ? differentTarget : evnt.target;
        
        var wasLongheld = modeEvents.longhold > 0;
        newEvnt.wasLongheld = function () { return wasLongheld };
        
    // send out a 'longhold' 500ms after a 'tapstart' as long as nothing else happens between
    // now and then.
    clearTimeout(longholdTimeout);
    if (newEvnt.type === 'tapstart' && newEvnt.touches.length === 1) {
      longholdTimeout = setTimeout(function () {
        dispatchEvent('longhold', evnt, differentTarget);
      }, 500);
    }
    
    $(newEvnt.target).trigger(newEvnt);
  };
  
    // TODO - Remember nodes given .hovered last time instead of querying. Only
  //        problem I can see here is that it's possible for a person to
  //        clone an object that has the .hover and add it to
  //        the dom. Then it'll never lose the .hover class. If we find
  //        any more performance problems with this, then maybe we can worry
  //        about it, but I don't think we need that optimization.
  // Already optimized to leave .hover on elements that still are hovered. Saw
  // a preformance problem with sliders before optimization and problem went
  // away after optimization.
  var setHoveredNode = function (node) {
    
    var hoverableNodes = modeTargets; // gets a list of nodes that were under the mouse when it was pressed
    var checkIfNodeIsHoverable = !!modeTargets.length; // simple mouse move with no mouse down
    var hoveredBefore = $.makeArray($('.hovered'));
    var hoveredNow = [];
    var lostHover = [];
    var gainedHover = [];
    
    // loop through all that are currently hovered
    while (node && node !== document) {

      // only add to hovered list if it can be hovered.
      if (!checkIfNodeIsHoverable || hoverableNodes.indexOf(node) !== -1) {
        
        // hovered now, but wasn't before
        if (hoveredBefore.indexOf(node) === -1) {
          gainedHover.push(node);
        }
        
        hoveredNow.push(node);
      }

      node = $(node).parent()[0];
    }
    
    // find the ones that used to be hovered but aren't any more
    for (var i=0; i<hoveredBefore.length; i++) {
      node = hoveredBefore[i];
      if (hoveredNow.indexOf(node) === -1) {
        lostHover.push(node);
      }
    }

    $(lostHover).removeClass('hovered').trigger('tipsyhide');
    $(gainedHover).addClass('hovered').trigger('tipsyshow');
  };
  
  $(document).on('touchstart', function (evnt) {
    if (mode === MOUSE_MODE) return;
    
    // setup TOUCH_MODE
    if (mode === NO_MODE) {
      beginMode(evnt);
    }

    // nothing can be hovered now
    setHoveredNode(null);

    dispatchEvent('tapstart', evnt);
  });
   
   
  $(document).on('touchmove', function (evnt) {
    if (mode !== TOUCH_MODE) return;
    dispatchEvent('tapmove', evnt);
  });
   
   
  $(document).on('touchcancel', function (evnt) {
    if (mode !== TOUCH_MODE) return;
        
    dispatchEvent('tapcancel', evnt);
    
    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
    
  });
   
   
  $(document).on('touchend', function (evnt) {
    if (mode !== TOUCH_MODE) return;

    dispatchEvent('tapend', evnt);

    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
  });
   

   
  $(document).on('mousedown', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;

    // Take evasive action for legacy clicks--that is, click events that are
    // synthesized by touch browsers after a sequence of touches has ended.
    // The problem we're trying to solve here is that if you move a DOM
    // element in response to a touch event, then the legacy mouse events will
    // be fired on whatever element happens to now be under where the touch
    // event occurred.
    //
    // For example, the "functions" menu is hidden when one of its buttons is
    // touched, and the legacy click event is subsequently fired on the graph
    // paper. This takes focus from the expression that was being edited.
    //
    // The solution is to preventDefault() on the legacy events if we are in
    // touch mode. However, this prevents inputs, textareas, and selects from
    // being focused properly in mobile webkit browsers. We compromise by
    // firing preventDefault() only if the target is not an input, textarea,
    // or select.
    if (mode === TOUCH_MODE || hasRecentlyEndedTouchMode()) {
      if (!$(evnt.target).is('input, textarea, select')) {
        evnt.preventDefault();
      }
      return;
    }

    // setup MOUSE_MODE
    beginMode(evnt);
        
    // add in missing touch api information
    evnt.originalEvent.touches = [evnt];
    evnt.originalEvent.changedTouches = [evnt];
    
    dispatchEvent('tapstart', evnt);
  });

  // Stop mousedown event from propagating for any element with an ancestor with
  // class .do-not-blur (and no ancestor with .do-blur)
  $(document).ready(function() {
    $(document).on("mousedown", function(e) {
      var doNotBlur = !!$(e.target).closest('.do-not-blur').length,
        doBlur    = !!$(e.target).closest('.do-blur').length;
      if (doNotBlur && !doBlur) {
        e.preventDefault();
      }

      // we use preventDefault() in places and that will cause text selection
      // to be preserved when it shouldn't be. On mouse down, if the only
      // thing with selection is something that has the .text-selectable class
      // then we can safely remove selection.
      var selection = window.getSelection();
      if (selection.rangeCount === 1) {
        var range = selection.getRangeAt(0);
        if (range.startContainer === range.endContainer && $(range.startContainer).closest('.text-selectable').length) {
          selection.removeAllRanges();
        }
      }
     
    });
	});
   
  // If the mouse isn't pressed, then the mousemove that moves us off the
  // the screen isn't reported. That'll leave the last hovered element hoverd.
  // this checks if we are in NO_MODE and have a mouseleave event.
  $(document).on('mouseleave', function (evnt) {
    // we can move the mouse while not being in mouseMode
    if (mode !== NO_MODE) return;
    
    // check if a significant amount of time has passed since
    // switching from TOUCH_MODE to NO_MODE
    if (hasRecentlyEndedTouchMode()) return;

    // nothing is hovered
    setHoveredNode(null);
  });
   
  $(document).on('mousemove', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;
    

    // we can move the mouse while not being in mouseMode
    if (mode === TOUCH_MODE) return;
   
    // check if a significant amount of time has passed since
    // switching from TOUCH_MODE to MOUSE_MODE
    if (hasRecentlyEndedTouchMode()) return;
    
    setHoveredNode(evnt.target);
    
    // add in missing touch api information
    evnt.originalEvent.touches = [evnt]; // TODO - not perfect because it could be a non-touch
    evnt.originalEvent.changedTouches = [evnt];
    
    dispatchEvent('tapmove', evnt);
  });
   
   
  $(document).on('mouseup', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;

    if (mode !== MOUSE_MODE) return;
    
    // add in missing touch api information
    evnt.originalEvent.touches = [];
    evnt.originalEvent.changedTouches = [evnt];
    
    dispatchEvent('tapend', evnt);
    
    endMode(evnt);
  });
  
  /*For debugging
   
  $(document).on('tapstart tapend tapmove tap tapcancel', function (evt){
    console.log(evt.type, evt.originalEvent.changedTouches);
  });*/

  //Utilities to allow other modules to query this state
  return {
    isTapActive: function(){
      return (mode !== NO_MODE);
    }
  };
  
});

/*
 * A handled event is one that should act like propagation was
 *  stopped, yet it's allowed to still bubble because other
 *  code might expect to see an event higher up on the dom.
 *
 * So the solution is to call 'handle()' when you don't
 *  want the event to be handled by any other other listeners.
 *  The listeners will still get called, but they can check
 *  that evt.wasHandled() == false to make sure that it
 *  should handle the event.
 *
 * You can namespace your event handlings so that two
 *  completely different parts of code can both use this
 *  utility. When you call 'wasHandled()', just pass in a
 *  string, and it will check that namespace. And when you
 *  call 'handle()', pass in a namespace string.
 *
 * For convienience, you can set the handleEvent attribute
 *  for any dom element and the 'wasHandled()' method will
 *  check if the event has passed through any dom element
 *  that should have handled the event.
 */
 
/* global jQuery */
;(function($) {
  var GLOBAL_NAMESPACE = "_*_";
  
  $.Event.prototype.wasHandled = function (namespace) {

    namespace = namespace ? namespace : GLOBAL_NAMESPACE;
    var oe = this.originalEvent;
    var hb = oe && oe.handledBy;
    
    //check if it was explicitly handled in code
    if (hb && hb[namespace]) return true;
    
    // namespace wasn't handled
    if (namespace !== GLOBAL_NAMESPACE) return false;

    //Now, check if it was implicitly handled through
    //the dom attribute 'handleEvent'
    var dom = $(this.target).closest('[handleEvent]');
    //TEMPORARY: just return true instead of deeply parsing
    if (dom.length && dom[0] !== this.currentTarget) {
      return dom.attr('handleEvent') !== "false";
    }

    //must not have been handled
    return false;
  };

  $.Event.prototype.handle = function (namespace) {
    namespace = namespace ? namespace : GLOBAL_NAMESPACE;
    var oe = this.originalEvent;
    if (!oe) return; //can't handle this properly

    var hb = oe.handledBy;
    if (!hb) hb = oe.handledBy = {};

    hb[namespace] = true;
  };

})(jQuery);


define("lib/jquery.handleevent", function(){});

/*! Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.4
 *
 * Requires: 1.2.2+
 */


// need chrome visibility to fix scroll variances
(function($) {
    var userAgent = navigator.userAgent.toLowerCase();
    $.browser.chrome = /chrome/.test(userAgent);
})(jQuery);


(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },

    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },

    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";


    // Old school scrollwheel delta
    if (event.originalEvent)
    {
        if ( event.originalEvent.wheelDelta ) { delta = event.originalEvent.wheelDelta/120; }
        else if ( event.originalEvent.detail     ) { delta = -event.originalEvent.detail/3; }
    }
    else
    {
        if ( event.wheelDelta ) { delta = event.wheelDelta/120; }
        else if ( event.detail     ) { delta = -event.detail/3; }
    }
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;

    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }

    // Webkit
    var wheelDeltaScaleFactor = 1;

    if ($.browser.msie || ($.browser.webkit && !$.browser.chrome)) {
      wheelDeltaScaleFactor = 40;
    }

    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120/wheelDeltaScaleFactor; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120/wheelDeltaScaleFactor; }

	if( delta > 0 ) delta = 1;
	else if( delta < 0)  delta = -1;

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    return $.event.handle.apply(this, args);
}

})(jQuery);

define("vendor/jquery.mousewheel", function(){});

// TODO - rename this.manager to something better. But that'll probably be
//        around the time we rename the Grapher class to something else.
//
// TODO - rename this class to something else. This class is really only
//        supposed to be for the animation / panning / zooming of the
//        grapher. It's not for any and all controlling. There are some
//        methods (such as grapher.addGraphSketch) that should be called
//        directly on the grapher and shouldn't go through this 'controller.'
define('graphing/graphcontroller',['require','jquery','pjs','./viewport','./viewporttransformation','math/distance','./constants','config','lib/touchtracking','lib/jquery.handleevent','vendor/jquery.mousewheel'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var Viewport = require('./viewport');
  var ViewportTransformation = require('./viewporttransformation');
  var Distance = require('math/distance');
  var constants = require('./constants');
  var Config = require('config');

  require('lib/touchtracking');

  require('lib/jquery.handleevent');
  require('vendor/jquery.mousewheel');

  var GraphController = P(function (proto) {
    proto.init = function (grapher) {
      this.manager = grapher;
      this.$ = this.manager.$;

      // callback
      this.triggerViewportStable = function () {};
      // using for jquery's animate feature. Would be nice to use something
      // more suited to only animation, but probably not worth the overhead.
      this.$animation = $('<div></div>');

      this.addMouseWheelEventHandler();
      this.addTouchEventHandler();
    };

    proto.getViewport = function () {
      return this.manager.viewport.clone();
    };

    proto.setViewport = function (viewport) {
      if (!viewport.isValid()) return;
      if (!this.manager.isInTransientState() && viewport.equals(this.manager.viewport)) {
        this.triggerViewportStable();
        return;
      }

      this.manager.viewport = viewport.clone();
      this.endTransientState();
    };

    proto.setTransformation = function (transformation) {

      this.manager.beginTransientState();
      this.manager.transformation = transformation;
      this.manager.redrawAllLayers();

      clearTimeout(this.endTransientTimeout);
      this.endTransientTimeout = setTimeout(this.endTransientState.bind(this), 250);
    };

    proto.endTransientState = function () {
      clearTimeout(this.endTransientTimeout);

      this.manager.endTransientState();
      this.manager.redrawAllLayers();

      this.triggerViewportStable();
    };

    proto.animateTransformation = function (transformation) {
      var self = this;
      var currentTransformation = this.manager.transformation;
      var targetTransformation = currentTransformation.compose(transformation);
      this.cancelAnimation();
      this.$animation.css('percent',0);
      this.$animation.animate( {'percent':100}, {

        duration: constants.ANIMATE_ZOOM_DURATION,

        step: function (percent) {
          self.setTransformation(
            currentTransformation.lerp(targetTransformation, percent/100.0)
          );
        }
      });
    };

    proto.cancelAnimation = function () {
      this.$animation.stop();
    };

    // this is simple enough to encapsulate everything in a single closure.
    proto.addMouseWheelEventHandler = function () {
      var mousewheel_counter = 0;

      var onMouseWheel = function (evt, delta) {
        evt.preventDefault();

        if (mousewheel_counter > 0) return;

        mousewheel_counter += 1;
        setTimeout(function () { mousewheel_counter-- }, 50);
        delta = (delta > 0 ? 1 : -1);

        var t = this.manager.transformation;

        this.setTransformation(
          t.compose(ViewportTransformation(
            0,
            0,
            (delta > 0) ? constants.ZOOM_FACTOR : 1/constants.ZOOM_FACTOR
          ))
        );
      };

      this.$.mousewheel(onMouseWheel.bind(this));
    };

    proto.handleDoubleClick = function (evt) {
      if (Config.get('disable_dblclick_zooming')) return;
      if (evt.wasHandled()) return;
      evt.preventDefault();

      var pageOffset = this.$.offset();
      var screen = this.manager.screen;
      var xOffset = evt.pageX - (pageOffset.left + 0.5*screen.width);
      var yOffset = evt.pageY - (pageOffset.top + 0.5*screen.height);
      var scale = constants.DOUBLETAP_ZOOM;

      // VT(dx*(1 - scale), dy*(1 - scale), scale) ===
      // VT(dx, dy, 1).VT(0, 0, scale).VT(-dx, -dy, 1);
      // Scales about the click point instead of the origin.
      this.animateTransformation(ViewportTransformation(
        xOffset*(1 - scale),
        yOffset*(1 - scale),
        scale
      ));
    };

    proto.applyPanTouchChanges = function (oldTouches, newTouches) {
      var dx = newTouches[0].x - oldTouches[0].x;
      var dy = newTouches[0].y - oldTouches[0].y;
      var transformation = this.manager.transformation.compose(
        ViewportTransformation(dx, dy, 1)
      );
      this.setTransformation(transformation);
    };

    proto.applyScaleTouchChanges = function (oldTouches, newTouches, scaleAxis) {

      var panX = Distance.mean(
        newTouches[0].x - oldTouches[0].x,
        newTouches[1].x - oldTouches[1].x
      );

      var panY = Distance.mean(
        newTouches[0].y - oldTouches[0].y,
        newTouches[1].y - oldTouches[1].y
      );

      var screen = this.manager.screen;
      var offset = this.manager.$.offset();

      var x0 = Distance.mean(oldTouches[0].x, oldTouches[1].x) -
        (offset.left + 0.5*screen.width)
      ;
      var y0 = Distance.mean(oldTouches[0].y, oldTouches[1].y) -
        (offset.top + 0.5*screen.height)
      ;

      var dxNew = Math.abs(newTouches[1].x - newTouches[0].x);
      var dyNew = Math.abs(newTouches[1].y - newTouches[0].y);
      var dxOld = Math.abs(oldTouches[1].x - oldTouches[0].x);
      var dyOld = Math.abs(oldTouches[1].y - oldTouches[0].y);

      // Decide if this is an isotropic or anisotropic scaling.
      var xScale, yScale;

      // avoid very large or small scaling when fingers cross
      var thresh = 50; // px,
      if (scaleAxis === 'x') {
        yScale = 1;
        xScale = Math.max(thresh, dxNew)/Math.max(thresh, dxOld);
      } else if (scaleAxis === 'y') {
        xScale = 1;
        yScale = Math.max(thresh, dyNew)/Math.max(thresh, dyOld);
      } else {
        xScale = yScale = (
          Math.max(thresh, Distance.hypot(dxNew, dyNew)) /
          Math.max(thresh, Distance.hypot(dxOld, dyOld))
        );
      }

      // offset*(1 - scale) is a trick for scaling about a point other than
      // the origin. It's equivalent to translating back to the origin,
      // scaling there, then translating back to offset.
      var transformation = this.manager.transformation.compose(
        ViewportTransformation(
          panX + x0*(1 - xScale),
          panY + y0*(1 - yScale),
          xScale,
          yScale
        )
      );

      this.setTransformation(transformation);
    };

    // a complete closure to all touch event related code
    proto.addTouchEventHandler = function () {

      var self = this;
      var touches = [];
      var isDragging = false;

      var beginDrag = function (evnt) {

        // must not have been handled already. The POI controller may handle
        // this tapStart for POI purposes and we may want to ignore it.
        if (evnt.wasHandled()) return;

        // must not already be dragging
        if (isDragging) return;

        // must not have a touch down anywhere else. Only want to start dragging
        // if this is the first touch and it's on the grapher
        if (evnt.touches.length !== evnt.changedTouches.length) return;

        // setup drag
        isDragging = true;
        $(document).on('tapmove.graphdrag', updateDrag);
        $(document).on('tapstart.graphdrag tapend.graphdrag tapcancel.graphdrag', updateTouches);
      };

      var _computeScaleAxis = function (touches) {
        if (touches.length < 2) return undefined;

        var projection = self.manager.createProjection();
        var offset = self.manager.$.offset();
        var ox = projection.mapx(0);
        var oy = projection.mapy(0);

        // Clamp to screen edges
        ox = Math.min(Math.max(0, ox), projection.screen.width) + offset.left;
        oy = Math.min(Math.max(0, oy), projection.screen.height) + offset.top;

        var xClose = function (x) {
          return 10*Math.abs(x - ox) < projection.screen.width;
        };

        var yClose = function (y) {
          return 10*Math.abs(y - oy) < projection.screen.height;
        };

        var dx = touches[1].x - touches[0].x;
        var dy = touches[1].y - touches[0].y;

        if (
          xClose(touches[0].x) &&
          xClose(touches[1].x) &&
          Math.abs(dy) > 3*Math.abs(dx)
        ) {
          return 'y';
        }

        if (
          yClose(touches[0].y) &&
          yClose(touches[1].y) &&
          Math.abs(dx) > 3*Math.abs(dy)
        ) {
          return 'x';
        }

        return 'both';
      };

      var updateScaleAxis = function (touches) {
        if (!self.manager.scaleAxis) {
          self.manager.scaleAxis = _computeScaleAxis(touches);
        }
        return self.manager.scaleAxis;
      };

      var clearScaleAxis = function () {
        self.manager.scaleAxis = undefined;
      };

      var updateDrag = function (evnt) {
        // must be dragging
        if (!isDragging) return;

        var newTouches = evnt.touches;

        if (touches.length === 2 && newTouches.length === 2) {
          // zoom and pan
          self.applyScaleTouchChanges(
            touches,
            newTouches,
            updateScaleAxis(newTouches)
          );
        } else {
          clearScaleAxis();
        }

        if (touches.length === 1) {
          // only option is to pan...
          self.applyPanTouchChanges(touches, newTouches);
        }

        touches = newTouches;
      };

      var updateTouches = function (evnt) {

        // must be dragging
        if (!isDragging) return;

        self.cancelAnimation();

        // save our touches so that when we move one we can
        // figure out how the touches have moved.
        touches = evnt.touches;

        // check if drag is over
        if (evnt.touches.length === 0) {
          isDragging = false;
          $(document).off('.graphdrag');
        }

        if (evnt.touches.length < 2) {
          clearScaleAxis();
        }

      };

      this.$.on('tapstart', beginDrag);
      this.$.on('dblclick', this.handleDoubleClick.bind(this));
    };

    proto.getSetting = function (setting, _default) {
      var value = this.manager.settings.getProperty(setting);
      return value !== undefined ? value : _default;
    };

    proto.setSetting = function (setting, value, _default) {
      this.manager.settings.setProperty(
        setting,
        value !== undefined ? value : _default
      );
    };

    proto.getState = function () {
      return {
        viewport: this.getViewport().toObject(),
        showLabels: this.getSetting('showLabels'),
        degreeMode: this.getSetting('degreeMode'),
        showGrid: this.getSetting('showGrid'),
        polarMode: this.getSetting('polarMode'),
        showAxes: this.getSetting('showAxes'),
        squareAxes: this.getSetting('squareAxes'),
        labelXMode: this.getSetting('xAxisPiLabels') ? 'pi' : '',
        labelYMode: this.getSetting('yAxisPiLabels') ? 'pi' : ''
      };
    };

    // TODO - Each one of these setSetting commands will update the grids
    // layer. That's not terrible, but it might be nice to have control over
    // that.
    //
    // Might be worth adding the observer in here rather than in
    // graph_settings.js so that we can turn the observer off/on cleanly
    // any time we do a batch update like this.
    proto.setState = function (state) {
      this.setSetting('showLabels', state.showLabels, true);
      this.setSetting('showGrid', state.showGrid, true);
      this.setSetting('polarMode', state.polarMode, false);
      this.setSetting('showAxes', state.showAxes, true);
      this.setSetting('squareAxes', state.squareAxes, true);
      this.setSetting('xAxisPiLabels', state.labelXMode === 'pi');
      this.setSetting('yAxisPiLabels', state.labelYMode === 'pi');
      this.setSetting('degreeMode', state.degreeMode, false);

      if ("viewport" in state) {
        var viewport = Viewport.fromObject(state.viewport);
        if (
          this.getSetting('squareAxes') &&
          !viewport.isSquare(this.manager.screen)
        ) {
          viewport.squareYAxis(this.manager.screen);
          viewport.round(this.manager.screen);
        }

        this.setViewport(viewport);
      }

    };

    proto.zoom = function (action) {
      if (action === 'in') {
        this.animateTransformation(
          ViewportTransformation(0, 0, 2)
        );
      } else if (action === 'out') {
        this.animateTransformation(
          ViewportTransformation(0, 0, 0.5)
        );
      } else if (action === 'default') {
        this.manager.settings.setProperty('squareAxes', true);
        this.setViewport(this.manager.computeDefaultViewport());
      }
    };

    proto.isZoomRestored = function () {
      return this.manager.viewport.equals(this.manager.computeDefaultViewport());
    };

    //executes a the axes squaring
    proto.enforceSquareAxes = function () {
      var settings = this.manager.settings;

      if (!settings.squareAxes) return;

      var preserveDirection = settings.lastChangedAxis;

      var viewport = this.manager.viewport.clone();
      if (preserveDirection == 'y') {
        viewport.squareXAxis(this.manager.screen);
      } else {
        viewport.squareYAxis(this.manager.screen);
      }
      viewport.round(this.manager.screen);
      this.setViewport(viewport);
    };
  });

  return GraphController;
});

//Copied from MDN reference
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

;(function () {
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis,
                                 aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
})();

define("lib/function.bind", function(){});

define('lib/underscore_model',['require','underscore','pjs','lib/function.bind'],function(require){
var _ = require('underscore');
var P = require('pjs');
require('lib/function.bind');

var UnderscoreModel = P(function (model) {

  // each model gets a guid that is unique even across different
  // versions of this file running within the same window
  var guid_count = 0;
  var guid_prefix = 'guid_' + Math.round(Math.random()*1000000) + "_" + (new Date().getTime()) + "_";
  
  model.init = function () {
    this.__observers = {};
    this.__oldProperties = {};
    this.__propertyComparators = {};
    this.guid = guid_prefix + (++guid_count);
  };
  
  model.getProperty = function (property) {
    return this[property];
  };
  
  model.getOldProperty = function (property) {
    return this.__oldProperties[property];
  };
  
  model.setProperty = function (property, newValue) {
    var oldValue = this[property];
    var comparator = this.__propertyComparators[property];
    if (comparator) {
      if (comparator(oldValue, newValue)) {
        return;
      }
    } else if (_.isEqual(oldValue, newValue)) {
      return;
    }
    
    this.__oldProperties[property] = oldValue;
    this[property] = newValue;
    this.notifyPropertyChange(property);
  };

  model.setProperties = function (obj) {
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) this.setProperty(k, obj[k]);
    }
  };
  
  model.setPropertyComparator = function (property, comparator) {
    this.__propertyComparators[property] = comparator;
  };
  
  model.notifyPropertyChange = function (property) {
    var observers = this.__observers[property];
    if (observers) {
     for (var i=0; i<observers.length; i++) {
       observers[i].callback(property, this);
     }
    }
  };
  
  model.unobserve = function (property_string) {
    
    // get rid of all observers
    if (!property_string) {
      this.__observers = {};
      return;
    }
    
    var properties = property_string.split(" ");
    for (var i=0; i<properties.length; i++) {
      var property_parts = properties[i].split(".");
      var property = property_parts[0];
      var namespace = property_parts[1];

      // only keep the ones with a different namespace
      if (property && namespace) {
        var original = this.__observers[property];
        var filtered = [];
        if (!original) continue;
        for (var j=0; j<original.length; j++) {
          var observer = original[j];
          if (observer.namespace !== namespace) {
            filtered.push(observer);
          }
        }
        this.__observers[property] = filtered;
        
      // get rid of all of observers for this property since no namespace given
      } else if (property) {
        if (this.__observers[property]) {
          this.__observers[property] = [];
        }
              
      // we aren't given a property, only a namespace. run through each
      // property that has observers and call .unobserve(property.namespace)
      } else if (namespace) {
        for (property in this.__observers) {
          this.unobserve(property + "." + namespace);
        }
      }
    }
  };
  
  model.observe = function (property_string, callback) {
    var properties = property_string.split(" ");
    for (var i=0; i<properties.length; i++) {
      var property_parts = properties[i].split(".");
      var property = property_parts[0];
      if (!property) throw 'Must supply a property to observe';
      
      var namespace = property_parts[1];
      var observer = {
        namespace: namespace,
        callback: callback
      };
      
      var observers = this.__observers[property];
      if (!observers) {
        this.__observers[property] = [observer];
      } else {
        observers.push(observer);
      }
    }
  };
});

return UnderscoreModel;
});

define('main/graph_settings',['require','jquery','pjs','lib/underscore_model'],function(require){
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreModel = require('lib/underscore_model');

  /*
  * graph settings
  */

  var GraphSettings = P(UnderscoreModel, function (settings, _super) {

    //these are user-defined properties and can be saved in the state
    settings.init = function () {
      _super.init.call(this);
      
      // stored in state
      this.squareAxes = true;
      this.showLabels = true;
      this.showGrid = true;
      this.polarMode = false;
      this.showAxes = true;
      this.xAxisPiLabels = false;
      this.yAxisPiLabels = false;
      this.degreeMode = false;
      
      //non computed -- these are the same for projectorMode and non-projector Mode
      this.labelHangingColor = 'rgba(150,150,150,1)';
      this.labelNormalColor = 'rgba(0,0,0,1)';

      //non-computed and not-stored in state. Just used for squaring Axes
      this.lastChangedAxis = 'x',

      // below here are properties that *are not* stored in the state and can,
      // right now, only be changed by toggling 'projectorMode'
      this.projectorMode = false;

      var self = this;
      function createProjectorProperty (property, offValue, onValue) {
        
        function computeProperty() {
          self.setProperty(property, self.projectorMode ? onValue : offValue);
        }
        
        self.observe('projectorMode', computeProperty);
        computeProperty();
      }
      
      function createHighlightProperty (property, off_off, off_on, on_off, on_on) {
        function computeProperty() {
          var value;
          if (self.projectorMode) {
            value = self.highlight ? on_on : on_off;
          } else {
            value = self.highlight ? off_on : off_off;
          }
          
          self.setProperty(property, value);
        }
        
        self.observe('projectorMode highlight', computeProperty);
        computeProperty();
      }
          
      //font size of labels
      createProjectorProperty('labelSize', 12, 18);
      //darker grid lines
      createProjectorProperty('majorAxisOpacity', 0.2, 0.5);
      
      //lighter grid lines
      createProjectorProperty('minorAxisOpacity', 0.08, 0.15);
      
      //main axes
      createProjectorProperty('axisOpacity', 0.7, 0.9);
      
      createProjectorProperty('axisLineWidth', 1, 2);

      //for antialiasing axes
      createProjectorProperty('axisLineOffset', 0.5, 0);
      
      //minimum separation between major axis lines
      createProjectorProperty('pixelsPerLabel', 70, 100);
      
      //line width for graphs
      createHighlightProperty('graphLineWidth', 2, 3, 6, 9);

      //line width for points
      createHighlightProperty('pointLineWidth', 7, 11, 15, 22);
    };

    settings.clone = function () {
      var newSettings = GraphSettings(this.grapher);
          newSettings.setProperty('squareAxes', this.squareAxes);
          newSettings.setProperty('showLabels', this.showLabels);
          newSettings.setProperty('showGrid', this.showGrid);
          newSettings.setProperty('polarMode', this.polarMode);
          newSettings.setProperty('squareAxes', this.showAxes);
          newSettings.setProperty('xAxisPiLabels', this.xAxisPiLabels);
          newSettings.setProperty('yAxisPiLabels', this.yAxisPiLabels);
          newSettings.setProperty('degreeMode', this.degreeMode);
          newSettings.setProperty('projectorMode', this.projectorMode);

      return newSettings;
    };
    
    settings.registerCallbacks = function (graphController, expressionsView) {
      var redrawGridLayer = function () {
        graphController.manager.redrawGridLayer();
      };
      this.observe('showLabels', redrawGridLayer);
      this.observe('showAxes', redrawGridLayer);
      this.observe('showGrid', redrawGridLayer);
      this.observe('polarMode', redrawGridLayer);
      this.observe('xAxisPiLabels', redrawGridLayer);
      this.observe('yAxisPiLabels', redrawGridLayer);
      this.observe('degreeMode', redrawGridLayer);

      this.observe('squareAxes', function() {
        graphController.enforceSquareAxes();
      });

      var self = this;
      this.observe('projectorMode', function() {
        graphController.manager.redrawAllLayers();

        //set class on the body for POIs & trace -- see poi.css
        $('body').toggleClass('PROJECTOR-MODE', !!self.projectorMode);
        expressionsView.onProjectorModeChange();
      });
    };
  });

  return GraphSettings;
});


/*
 * TimerModules is a way to setup a function to keep getting called every
 * 100ms. This is much cleaner than a lot of individual setTimeout or
 * setInterval calls, and it allows you to optionally load/not load the module.
 *
 * A 'module' is really nothing more than a simple javascript closure. In order
 * to 'add' a 'module', you make a call to Desmos.TimerModules.add and pass two
 * arguments. The first is the name (string) you want to call the module, and
 * the second argument is the module (function) you want to be executed when
 * the module is 'loaded.'
 *
 * When you load a module, you can pass it arguments. This, for instance, would
 * load the 'sample' module with the arguments (0,'a'):
 *
 *    Desmos.TimerModules.load('sample',0,'a')
 *
 * The 'sample' module will be executed. If the module returns a reference to
 * a function, that function will keep getting called every 100ms. It's
 * important to realize that the module itself won't be called every 100ms. The
 * module is used to setup the function that keeps called every 100ms.
 *
 * see expressions.overflows.js, expressions.renderviewport
 * for real examples
 */
define('main/timermodules',[], function(){

var added = {};
var loaded = {};
var runnable = {};

var TimerModules = {};
TimerModules.add = function(name,setup){
  added[name] = setup;
};

TimerModules.load = function(name){
  if( added[name] )
  {
    //load the module
    loaded[name] = added[name].apply(this,Array.prototype.slice.call(arguments,1));

    //add to list of runnable modules
    if( loaded[name] ) runnable[name] = loaded[name];
  }
};

var run = function(){
  
  for (var i in runnable) {
    if (runnable.hasOwnProperty(i)) runnable[i]();
  }
  
  setTimeout( run, 100 );
};

run();

return TimerModules;
});

define('undoredo',['require','underscore','pjs'],function (require) {
  var _ = require('underscore');
  var P = require('pjs');

var UndoRedoManager = P(function (manager, _super) {

  manager.CAUSE_OF_CHANGE = 1;
  manager.RESPONSE_TO_CHANGE = 2;

  manager.triggerFlash = function () {};

  manager.init = function () {
    this.undos = [];
    this.redos = [];
    this.changesCallbacks = [];
    this.__isApplyingTransaction = 0;
    this.markAsSaved();
  };

  // TODO - a different way to listen for z and y keys than hardcoding the numbers
  //Default ctrl-z, ctrl-y behavior
  manager.handleKeydown = function (evt) {
    if (evt.ctrlKey || evt.metaKey) {
      switch(evt.which) {
        case 90: //z
          if (evt.shiftKey) {
            this.redo();
          } else {
            this.undo();
          }
          return false;
        case 89: //y
          this.redo();
          return false;
      }
    }
  };

  manager.clear = function () {
    this.undos = [];
    this.redos = [];
    this.markAsSaved();
  };

  manager.pushUndo = function (transaction) {
    this.undos.push(transaction);
    
    if (transaction.recordChange !== false) {
      this.__changesSinceSave++;
      this.triggerChanges();
    }
  };
  
  manager.pushRedo = function (transaction) {
    this.redos.push(transaction);
    
    if (transaction.recordChange !== false) {
      this.__changesSinceSave--;
      this.triggerChanges();
    }
  };
  
  manager.canUndo = function () {
    return this.undos.length > 0;
  };
  
  manager.canRedo = function () {
    return this.redos.length > 0;
  };
  
  manager.undo = function () {
    if (!this.canUndo()) return;
    
    var action = this.undos.pop();
    this.applyTransaction(action,true);
    this.pushRedo(action);
  };
  
  manager.redo = function () {
    if (!this.canRedo()) return;
    
    var action = this.redos.pop();
    this.applyTransaction(action);
    this.pushUndo(action);
  };

  //this is called from the outside world
  manager.markAsSaved = function () {
    this.__changesSinceSave = 0;
    this.triggerChanges();
  };
  
  manager.changedSinceSave = function () {
    return this.__changesSinceSave !== 0;
  };
  
  manager.isApplyingTransaction = function () {
    return !!this.__isApplyingTransaction;
  };
  
  manager.__applyTransaction = function (transaction, doUndo) {
    var i;
    var batched = transaction.__batched__ ? transaction.__batched__ : [];

    // apply transactions in reverse
    if (doUndo) {
      for (i=batched.length-1; i>=0; i--) {
        this.__applyTransaction(batched[i], doUndo);
      }
     
      transaction.undo();
    }
    
    // apply transactions the way they happened the first time
    else {
      transaction.redo();
      for (i=0; i<batched.length; i++) {
        this.__applyTransaction(batched[i], doUndo);
      }
    }
  };
  
  manager.applyTransaction = function (transaction, doUndo) {
    this.__isApplyingTransaction++;
    
    try {
      this.__applyTransaction(transaction, doUndo);
    } finally {
      this.__isApplyingTransaction--;
    }
  };
  
  // sometimes, we want to just do multiple things, and we want them to all
  // be grouped into a single transaction. We want to just do stuff, and all
  // that stuff gets grouped together. It's important to note that oneTransaction
  // requires that all side effects happen synchronously.
  manager.oneTransaction = function (func) {
    if (!this.__oneTransactionDepth) {
      this.__oneTransactionDepth=0;
    }
    
    this.__oneTransactionDepth++;
    func();
    this.__oneTransactionDepth--;
    
    if (!this.__oneTransactionDepth) {
      this.__oneTransaction = null;
    }
  };
  
  manager.isApplyingOneTransaction = function () {
    return this.__oneTransactionDepth > 0;
  };
  
  manager.addTransaction = function (transaction) {
    var batched;
    
    //don't accept changes that are sideffects of applying a transaction.
    //the transaction should've been written in such a way that chained
    //reactions are accounted for.
    if (this.isApplyingTransaction()) return;
    
    //automatically apply this if it's what's going to cause the initial
    //change.
    if (transaction.type === this.CAUSE_OF_CHANGE)
      this.applyTransaction(transaction);
    
    //if nothing really changed, then stop.
    if (transaction.ensureChangeOccured && transaction.ensureChangeOccured())
      return;
    
    // was this.redos.clear() in the Dark days. this.redos = [] would be
    // simpler, but has different semantics if someone else has a handle to
    // this array.
    this.redos.splice(0);
        
    if (this.isApplyingOneTransaction()) {
      if (!this.__oneTransaction) {
        this.__oneTransaction = transaction;
      } else {
        batched = this.__oneTransaction.__batched__;
        if (!batched) batched = this.__oneTransaction.__batched__ = [];
        batched.push(transaction);
        return;
      }
    }
      
    this.pushUndo(transaction);
  };

  manager.triggerChanges = function () {
    _.each(this.changesCallbacks, function (cb) { cb() });
  };

});


return UndoRedoManager();
});

define('expressions/abstractitem',['require','pjs','lib/underscore_model','undoredo'],function(require) {
  var P = require('pjs');
  var UnderscoreModel = require('lib/underscore_model');
  var UndoRedo = require('undoredo');
  
  var AbstractItemModel = P(UnderscoreModel, function (model, _super) {

    var nextItemId = 1;
    
    model.init = function (state, list) {
      _super.init.call(this);
      
      // TODO - these belong on view, not the model
      this.index = -1;
      this.selected = false;
      this.list = list;
      
      for (var property in state) {
        if (state.hasOwnProperty(property)) {
          this[property] = state[property];
        }
      }
      
      if (!this.hasOwnProperty('id')) {
        this.id = nextItemId++;
      } else if (this.id >= nextItemId) {
        nextItemId = this.id + 1;
      }

      this.observe('folder', this.updateFolder.bind(this));
      this.observe('selected', this.onSelectedChange.bind(this));
    };
    
    model.onAddedToList = function () {};
    model.onRemovedFromList = function () {};

    // Record change for undo-redo
    model.onStateDidChange = function(prop) {
      var id = this.id;
      var oldValue = this.getOldProperty(prop);
      var newValue = this.getProperty(prop);
      
      var list = this.list;
      UndoRedo.addTransaction({
        type: UndoRedo.RESPONSE_TO_CHANGE,
        undo: function() {
          list.getItemById(id).setProperty(prop, oldValue);
        },
        redo: function () {
          list.getItemById(id).setProperty(prop, newValue);
        }
      });
    };

    model.updateCollapsed = function () {
      this.setProperty(
        'inCollapsedFolder',
        this.folder ? this.folder.collapsed : false
      );
    };

    model.updateFolder = function () {
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'collapsed.' + this.id,
          this.updateCollapsed.bind(this)
        );
      }
      this.updateCollapsed();
    };
    
    // selecting an expression within a collapsed folder expands the folder.
    // this can happen by clicking the curve on the graphpaper
    model.onSelectedChange = function () {
      if (this.selected && this.folder && this.folder.collapsed) {
        this.folder.setProperty('collapsed', false);
      }
    };
    
  });
  
  return AbstractItemModel;
});

define('expressions/domain',['require','lib/underscore_model','pjs'],function(require){
  var UnderscoreModel = require('lib/underscore_model');
  var P = require('pjs');

var DomainModel = P(UnderscoreModel, function (model, _super) {
  model.init = function (min, max) {
    _super.init.call(this);
    this.min = min;
    this.max = max;
  };
  
  model.isValid = function () {
    return isFinite(this.min) && isFinite(this.max) && (this.max > this.min);
  };
  
  model.serialize = function () {
    return {min: this.min, max: this.max};
  };
});

DomainModel.deserialize = function (obj) {
  if (!obj) return DomainModel();
  else return DomainModel(obj.min, obj.max);
};

return DomainModel;
});

/* big.js v1.0.1 https://github.com/MikeMcl/big.js/LICENCE */
;(function ( global ) {
    

    /*
      big.js v1.0.1
      A small, fast Javascript library for arbitrary-precision arithmetic with decimal numbers. 
      https://github.com/MikeMcl/big.js/
      Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */

    /****************************** EDITABLE DEFAULTS **********************************/


    // The default values below must be integers within the stated ranges (inclusive).

    /*
     * The maximum number of decimal places of the results of methods involving
     * division, i.e. 'div' and 'sqrt', and 'pow' with negative exponents.
     */
    Big['DP'] = 20;                                  // 0 to MAX_DP

    /*
     * The rounding mode used when rounding to the above decimal places.
     *
     * 0 Round towards zero (i.e. truncate, no rounding).               (ROUND_DOWN     )
     * 1 Round to nearest neighbour. If equidistant, round up.          (ROUND_HALF_UP  )
     * 2 Round to nearest neighbour. If equidistant, to even neighbour. (ROUND_HALF_EVEN)
     */
    Big['RM'] = 1;                                   // 0, 1 or 2

        // The maximum value of 'Big.DP'.
    var MAX_DP = 1E6,                                // 0 to 1e+6

        // The maximum magnitude of the exponent argument to the 'pow' method.
        MAX_POWER = 1E6,                             // 1 to 1e+6

        /*
         * The exponent value at and beneath which 'toString' returns exponential notation.
         * Javascript's Number type: -7
         * -1e+6 is the minimum recommended exponent value of a 'Big'.
         */
        TO_EXP_NEG = -7,                             // 0 to -1e+6

        /*
         * The exponent value at and above which 'toString' returns exponential notation.
         * Javascript's Number type: 21
         * 1e+6 is the maximum recommended exponent value of a 'Big', though there is no
         * enforcing or checking of a limit.
         */
        TO_EXP_POS = 21,                             // 0 to 1e+6


    /***********************************************************************************/

        P = Big.prototype,
        isValid = /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/i,
        ONE = new Big(1);


    // CONSTRUCTOR


    /*
     * The exported function.
     * Create and return a new instance of a 'Big' object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big( n ) {
        var i, j, nL,
            x = this;

        // Enable constructor usage without new.
        if ( !(x instanceof Big) ) {
            return new Big( n )
        }

        // Duplicate.
        if ( n instanceof Big ) {
            x['s'] = n['s'];
            x['e'] = n['e'];
            x['c'] = n['c'].slice();
            return
        }

        // Minus zero?
        if ( n === 0 && 1 / n < 0 ) {
            n = '-0'
        // Ensure 'n' is string and check validity.
        } else if ( !isValid.test(n += '') ) {
            throw NaN
        }

        // Determine sign.
        x['s'] = n.charAt(0) == '-' ? ( n = n.slice(1), -1 ) : 1;

        // Decimal point?
        if ( ( i = n.indexOf('.') ) > -1 ) {
            n = n.replace( '.', '' )
        }

        // Exponential form?
        if ( ( j = n.search(/e/i) ) > 0 ) {

            // Determine exponent.
            if ( i < 0 ) {
                i = j
            }
            i += +n.slice( j + 1 );
            n = n.substring( 0, j )

        } else if ( i < 0 ) {

            // Integer.
            i = n.length
        }

        // Determine leading zeros.
        for ( j = 0; n.charAt(j) == '0'; j++ ) {
        }

        if ( j == ( nL = n.length ) ) {

            // Zero.
            x['c'] = [ x['e'] = 0 ]
        } else {

            // Determine trailing zeros.
            for ( ; n.charAt(--nL) == '0'; ) {
            }

            x['e'] = i - j - 1;
            x['c'] = [];

            // Convert string to array of digits (without leading and trailing zeros).
            for ( i = 0; j <= nL; x['c'][i++] = +n.charAt(j++) ) {
            }
        }
    }


    // PRIVATE FUNCTIONS


    /*
     * Round 'Big' 'x' to a maximum of 'dp' decimal places using rounding mode
     * 'rm'. (Called by 'div', 'sqrt' and 'round'.)
     *
     * x {Big} The 'Big' to round.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * rm {number} 0, 1 or 2 ( ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     * [more] {boolean} Whether the result of division was truncated.
     */
    function rnd( x, dp, rm, more ) {
        var xc = x['c'],
            i = x['e'] + dp + 1;

        if ( rm !== 0 && rm !== 1 && rm !== 2 ) {
            throw '!Big.RM!'
        }

        // 'xc[i]' is the digit after the digit that may be rounded up.
        rm = rm && ( xc[i] > 5 || xc[i] == 5 &&
          ( rm == 1 || more || i < 0 || xc[i + 1] != null || xc[i - 1] & 1 ) );

        if ( i < 1 || !xc[0] ) {
            x['c'] = rm
              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              ? ( x['e'] = -dp, [1] )
              // Zero.
              : [ x['e'] = 0 ];
        } else {

            // Remove any digits after the required decimal places.
            xc.length = i--;

            // Round up?
            if ( rm ) {

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for ( ; ++xc[i] > 9; ) {
                    xc[i] = 0;

                    if ( !i-- ) {
                        ++x['e'];
                        xc.unshift(1)
                    }
                }
            }

            // Remove trailing zeros.
            for ( i = xc.length; !xc[--i]; xc.pop() ) {
            }
        }

        return x
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return
     * 1 if the value of this 'Big' is greater than the value of 'Big' 'y',
     * -1 if the value of this 'Big' is less than the value of 'Big' 'y', or
     * 0 if they have the same value,
     */
    P['cmp'] = function ( y ) {
        var xNeg,
            x = this,
            xc = x['c'],
            yc = ( y = new Big( y ) )['c'],
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {
            return !xc[0] ? !yc[0] ? 0 : -j : i
        }

        // Signs differ?
        if ( i != j ) {
            return i
        }
        xNeg = i < 0;

        // Compare exponents.
        if ( k != l ) {
            return k > l ^ xNeg ? 1 : -1
        }

        // Compare digit by digit.
        for ( i = -1,
              j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
              ++i < j; ) {

            if ( xc[i] != yc[i] ) {
                return xc[i] > yc[i] ^ xNeg ? 1 : -1
            }
        }

        // Compare lengths.
        return k == l ? 0 : k > l ^ xNeg ? 1 : -1
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' divided by the
     * value of 'Big' 'y', rounded, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     */
    P['div'] = function ( y ) {
        var x = this,
            dvd = x['c'],
            dvs = ( y = new Big(y) )['c'],
            s = x['s'] == y['s'] ? 1 : -1,
            dp = Big['DP'];

        if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!Big.DP!'
        }

        // Either 0?
        if ( !dvd[0] || !dvs[0] ) {

            // Both 0?
            if ( dvd[0] == dvs[0] ) {
                throw NaN
            }

            // 'dvs' is 0?
            if ( !dvs[0] ) {
                // Throw +-Infinity.
                throw s / 0
            }

            // 'dvd' is 0. Return +-0.
            return new Big( s * 0 )
        }


        var dvsL, dvsT, next, cmp, remI,
            dvsZ = dvs.slice(),
            dvdI = dvsL = dvs.length,
            dvdL = dvd.length,
            rem = dvd.slice( 0, dvsL ),
            remL = rem.length,
            quo = new Big(ONE),
            qc = quo['c'] = [],
            qi = 0,
            digits = dp + ( quo['e'] = x['e'] - y['e'] ) + 1;

        quo['s'] = s;
        s = digits < 0 ? 0 : digits;

        // Create version of divisor with leading zero.
        dvsZ.unshift(0);

        // Add zeros to make remainder as long as divisor.
        for ( ; remL++ < dvsL; rem.push(0) ) {
        }

        do {

            // 'next' is how many times the divisor goes into the current remainder.
            for ( next = 0; next < 10; next++ ) {

                // Compare divisor and remainder.
                if ( dvsL != ( remL = rem.length ) ) {
                    cmp = dvsL > remL ? 1 : -1
                } else {
                    for ( remI = -1, cmp = 0; ++remI < dvsL; ) {

                        if ( dvs[remI] != rem[remI] ) {
                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
                            break
                        }
                    }
                }

                // Subtract divisor from remainder (if divisor < remainder).
                if ( cmp < 0 ) {

                    // Remainder cannot be more than one digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for ( dvsT = remL == dvsL ? dvs : dvsZ; remL; ) {

                        if ( rem[--remL] < dvsT[remL] ) {

                            for ( remI = remL;
                                  remI && !rem[--remI];
                                  rem[remI] = 9 ) {
                            }
                            --rem[remI];
                            rem[remL] += 10
                        }
                        rem[remL] -= dvsT[remL]
                    }
                    for ( ; !rem[0]; rem.shift() ) {
                    }
                } else {
                    break
                }
            }

            // Add the 'next' digit to the result array.
            qc[qi++] = cmp ? next : ++next;

            // Update the remainder.
            rem[0] && cmp
              ? ( rem[remL] = dvd[dvdI] || 0 )
              : ( rem = [ dvd[dvdI] ] )

        } while ( ( dvdI++ < dvdL || rem[0] != null ) && s-- );

        // Leading zero? Do not remove if result is simply zero (qi == 1).
        if ( !qc[0] && qi != 1) {

            // There can't be more than one zero.
            qc.shift();
            quo['e']--;
        }

        // Round?
        if ( qi > digits ) {
            rnd( quo, dp, Big['RM'], rem[0] != null )
        }

        return quo
    }


    /*
     * Return a new 'Big' whose value is the value of this 'Big' minus the value
     * of 'Big' 'y'.
     */
    P['minus'] = function ( y ) {
        var d, i, j, xLTy,
            x = this,
            a = x['s'],
            b = ( y = new Big( y ) )['s'];

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['plus'](y)
        }

        var xc = x['c'],
            xe = x['e'],
            yc = y['c'],
            ye = y['e'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // 'y' is non-zero?
            return yc[0]
              ? ( y['s'] = -b, y )
              // 'x' is non-zero?
              : new Big( xc[0]
                ? x
                // Both are zero.
                : 0 )
        }

        // Determine which is the bigger number.
        // Prepend zeros to equalise exponents.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = ( xLTy = a < 0 ) ? ( a = -a, xc ) : ( ye = xe, yc );

            for ( d.reverse(), b = a; b--; d.push(0) ) {
            }
            d.reverse()
        } else {

            // Exponents equal. Check digit by digit.
            j = ( ( xLTy = xc.length < yc.length ) ? xc : yc ).length;

            for ( a = b = 0; b < j; b++ ) {

                if ( xc[b] != yc[b] ) {
                    xLTy = xc[b] < yc[b];
                    break
                }
            }
        }

        // 'x' < 'y'? Point 'xc' to the array of the bigger number.
        if ( xLTy ) {
            d = xc, xc = yc, yc = d;
            y['s'] = -y['s']
        }

        /*
         * Append zeros to 'xc' if shorter. No need to add zeros to 'yc' if shorter
         * as subtraction only needs to start at 'yc.length'.
         */
        if ( ( b = -( ( j = xc.length ) - yc.length ) ) > 0 ) {

            for ( ; b--; xc[j++] = 0 ) {
            }
        }

        // Subtract 'yc' from 'xc'.
        for ( b = yc.length; b > a; ){

            if ( xc[--b] < yc[b] ) {

                for ( i = b; i && !xc[--i]; xc[i] = 9 ) {
                }
                --xc[i];
                xc[b] += 10
            }
            xc[b] -= yc[b]
        }

        // Remove trailing zeros.
        for ( ; xc[--j] == 0; xc.pop() ) {
        }

        // Remove leading zeros and adbust exponent accordingly.
        for ( ; xc[0] == 0; xc.shift(), --ye ) {
        }

        if ( !xc[0] ) {

            // Result must be zero.
            xc = [ye = 0]
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' modulo the
     * value of 'Big' 'y'.
     */
    P['mod'] = function ( y ) {
        y = new Big( y );
        var c,
            x = this,
            i = x['s'],
            j = y['s'];

        if ( !y['c'][0] ) {
            throw NaN
        }

        x['s'] = y['s'] = 1;
        c = y['cmp'](x) == 1;
        x['s'] = i, y['s'] = j;

        return c
          ? new Big(x)
          : ( i = Big['DP'], j = Big['RM'],
            Big['DP'] = Big['RM'] = 0,
              x = x['div'](y),
                Big['DP'] = i, Big['RM'] = j,
                  this['minus']( x['times'](y) ) )
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' plus the value
     * of 'Big' 'y'.
     */
    P['plus'] = function ( y ) {
        var d,
            x = this,
            a = x['s'],
            b = ( y = new Big( y ) )['s'];

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['minus'](y)
        }

        var xe = x['e'],
            xc = x['c'],
            ye = y['e'],
            yc = y['c'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // 'y' is non-zero?
            return yc[0]
              ? y
              : new Big( xc[0]

                // 'x' is non-zero?
                ? x

                // Both are zero. Return zero.
                : a * 0 )
        }

        // Prepend zeros to equalise exponents.
        // Note: Faster to use reverse then do unshifts.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = a > 0 ? ( ye = xe, yc ) : ( a = -a, xc );

            for ( d.reverse(); a--; d.push(0) ) {
            }
            d.reverse()
        }

        // Point 'xc' to the longer array.
        if ( xc.length - yc.length < 0 ) {
            d = yc, yc = xc, xc = d
        }

        /*
         * Only start adding at 'yc.length - 1' as the
         * further digits of 'xc' can be left as they are.
         */
        for ( a = yc.length, b = 0; a;
             b = ( xc[--a] = xc[a] + yc[a] + b ) / 10 ^ 0, xc[a] %= 10 ) {
        }

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        if ( b ) {
            xc.unshift(b);
            ++ye
        }

         // Remove trailing zeros.
        for ( a = xc.length; xc[--a] == 0; xc.pop() ) {
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a 'Big' whose value is the value of this 'Big' raised to the power
     * 'e'. If 'e' is negative, round, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     *
     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.
     */
    P['pow'] = function ( e ) {
        var isNeg = e < 0,
            x = new Big(this),
            y = ONE;

        if ( e !== ~~e || e < -MAX_POWER || e > MAX_POWER ) {
            throw '!pow!'
        }

        for ( e = isNeg ? -e : e; ; ) {

            if ( e & 1 ) {
                y = y['times'](x)
            }
            e >>= 1;

            if ( !e ) {
                break
            }
            x = x['times'](x)
        }

        return isNeg ? ONE['div'](y) : y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' rounded, if
     * necessary, to a maximum of 'dp' decimal places using rounding mode 'rm'.
     * If 'dp' is not specified, round to 0 decimal places.
     * If 'rm' is not specified, use 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     * [rm] 0, 1 or 2 ( i.e. ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     */
    P['round'] = function ( dp, rm ) {
        var x = new Big(this);

        if ( dp == null ) {
            dp = 0
        } else if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!round!'
        }
        rnd( x, dp, rm == null ? Big['RM'] : rm );

        return x
    };


    /*
     * Return a new 'Big' whose value is the square root of the value of this
     * 'Big', rounded, if necessary, to a maximum of 'Big.DP' decimal places
     * using rounding mode 'Big.RM'.
     */
    P['sqrt'] = function () {
        var estimate, r, approx,
            x = this,
            xc = x['c'],
            i = x['s'],
            e = x['e'],
            half = new Big('0.5');

        // Zero?
        if ( !xc[0] ) {
            return new Big(x)
        }

        // Negative?
        if ( i < 0 ) {
            throw NaN
        }

        // Estimate.
        i = Math.sqrt( x.toString() );

        // Math.sqrt underflow/overflow?
        // Pass 'x' to Math.sqrt as integer, then adjust the exponent of the result.
        if ( i == 0 || i == 1 / 0 ) {
            estimate = xc.join('');

            if ( !( estimate.length + e & 1 ) ) {
                estimate += '0'
            }

            r = new Big( Math.sqrt(estimate).toString() );
            r['e'] = ( ( ( e + 1 ) / 2 ) | 0 ) - ( e < 0 || e & 1 )
        } else {
            r = new Big( i.toString() )
        }

        i = r['e'] + ( Big['DP'] += 4 );

        // Newton-Raphson loop.
        do {
            approx = r;
            r = half['times']( approx['plus']( x['div'](approx) ) )
        } while ( approx['c'].slice( 0, i ).join('') !==
                       r['c'].slice( 0, i ).join('') );

        rnd( r, Big['DP'] -= 4, Big['RM'] );

        return r
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' times the value
     * of 'Big' 'y'.
     */
    P['times'] = function ( y ) {
        var c,
            x = this,
            xc = x['c'],
            yc = ( y = new Big( y ) )['c'],
            a = xc.length,
            b = yc.length,
            i = x['e'],
            j = y['e'];

        y['s'] = x['s'] == y['s'] ? 1 : -1;

        // Either 0?
        if ( !xc[0] || !yc[0] ) {

            return new Big( y['s'] * 0 )
        }

        y['e'] = i + j;

        if ( a < b ) {
            c = xc, xc = yc, yc = c, j = a, a = b, b = j
        }

        for ( j = a + b, c = []; j--; c.push(0) ) {
        }

        // Multiply!
        for ( i = b - 1; i > -1; i-- ) {

            for ( b = 0, j = a + i;
                  j > i;
                  b = c[j] + yc[i] * xc[j - i - 1] + b,
                  c[j--] = b % 10 | 0,
                  b = b / 10 | 0 ) {
            }

            if ( b ) {
                c[j] = ( c[j] + b ) % 10
            }
        }

        b && ++y['e'];

        // Remove any leading zero.
        !c[0] && c.shift();

        // Remove trailing zeros.
        for ( j = c.length; !c[--j]; c.pop() ) {
        }

        return y['c'] = c, y
    };


    /*
     * Return a string representing the value of this 'Big'.
     * Return exponential notation if this 'Big' has a positive exponent equal
     * to or greater than 'TO_EXP_POS', or a negative exponent equal to or less
     * than 'TO_EXP_NEG'.
     */
    P['toString'] = P['valueOf'] = function () {
        var x = this,
            e = x['e'],
            str = x['c'].join(''),
            strL = str.length;

        // Exponential notation?
        if ( e <= TO_EXP_NEG || e >= TO_EXP_POS ) {
            str = str.charAt(0) + ( strL > 1 ?  '.' + str.slice(1) : '' ) +
              ( e < 0 ? 'e' : 'e+' ) + e

        // Negative exponent?
        } else if ( e < 0 ) {

        // Prepend zeros.
            for ( ; ++e; str = '0' + str ) {
            }
            str = '0.' + str

        // Positive exponent?
        } else if ( e > 0 ) {

            if ( ++e > strL ) {

                // Append zeros.
                for ( e -= strL; e-- ; str += '0' ) {
                }
            } else if ( e < strL ) {
                str = str.slice( 0, e ) + '.' + str.slice(e)
            }

        // Exponent zero.
        } else if ( strL > 1 ) {
            str = str.charAt(0) + '.' + str.slice(1)
        }

        // Avoid '-0'
        return x['s'] < 0 && x['c'][0] ? '-' + str : str
    };


    /*
     ***************************************************************************
     *
     * If 'toExponential', 'toFixed', 'toPrecision' and 'format' are not
     * required they can safely be commented-out or deleted. No redundant code
     * will be left. 'format' is used only by 'toExponential', 'toFixed' and
     * 'toPrecision'.
     *
     ***************************************************************************
     */
     

    /*
     * PRIVATE FUNCTION
     *
     * Return a string representing the value of 'Big' 'x' in normal or
     * exponential notation to a fixed number of decimal places or significant
     * digits 'dp'.
     * (Called by toString, toExponential, toFixed and toPrecision.)
     *
     * x {Big} The 'Big' to format.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * toE {number} undefined (toFixed), 1 (toExponential) or 2 (toPrecision).
     */
    function format( x, dp, toE ) {
        // The index (in normal notation) of the digit that may be rounded up.
        var i = dp - ( x = new Big(x) )['e'],
            c = x['c'];

        // Round?
        if ( c.length > ++dp ) {
            rnd( x, i, Big['RM'] )
        }

        // Recalculate 'i' if toFixed as 'x.e' may have changed if value rounded up.
        i = !c[0] ? i + 1 : toE ? dp : ( c = x['c'], x['e'] + i + 1 );

        // Append zeros?
        for ( ; c.length < i; c.push(0) ) {
        }
        i = x['e'];

        /*
         * 'toPrecision' returns exponential notation if the number of
         * significant digits specified is less than the number of digits
         * necessary to represent the integer part of the value in normal
         * notation.
         */
        return toE == 1 || toE == 2 && ( dp <= i || i <= TO_EXP_NEG )

            // Exponential notation.
            ? ( x['s'] < 0 && c[0] ? '-' : '' ) + ( c.length > 1
              ? ( c.splice( 1, 0, '.' ), c.join('') )
              : c[0] ) + ( i < 0 ? 'e' : 'e+' ) + i

            // Normal notation.
            : x.toString()
    }


    /*
     * Return a string representing the value of this 'Big' in exponential
     * notation to 'dp' fixed decimal places and rounded, if necessary, using
     * 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toExponential'] = function ( dp ) {

        if ( dp == null ) {
            dp = this['c'].length - 1
        } else if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!toExp!'
        }

        return format( this, dp, 1 )
    };


    /*
     * Return a string representing the value of this 'Big' in normal notation
     * to 'dp' fixed decimal places and rounded, if necessary, using 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toFixed'] = function ( dp ) {
        var str,
            x = this,
            neg = TO_EXP_NEG,
            pos = TO_EXP_POS;

        TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );

        if ( dp == null ) {
            str = x.toString()
        } else if ( dp === ~~dp && dp >= 0 && dp <= MAX_DP ) {
            str = format( x, x['e'] + dp );

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if ( x['s'] < 0 && x['c'][0] && str.indexOf('-') < 0 ) {
                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                str = '-' + str
            }
        }
        TO_EXP_NEG = neg, TO_EXP_POS = pos;

        if ( !str ) {
            throw '!toFix!'
        }

        return str
    };


    /*
     * Return a string representing the value of this 'Big' to 'sd' significant
     * digits and rounded, if necessary, using 'Big.RM'. If 'sd' is less than
     * the number of digits necessary to represent the integer part of the value
     * in normal notation, then use exponential notation.
     *
     * sd {number} Integer, 1 to MAX_DP inclusive.
     */
    P['toPrecision'] = function ( sd ) {

        if ( sd == null ) {
            return this.toString()
        } else if ( sd !== ~~sd || sd < 1 || sd > MAX_DP ) {
            throw '!toPre!'
        }

        return format( this, sd - 1, 2 )
    };


    // EXPORT


    // Node and other CommonJS-like environments that support module.exports.
    if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = Big

    //AMD.
    } else if ( typeof define == 'function' && define.amd ) {
        define('vendor/big',[], function () {
            return Big
        })

    //Browser.
    } else {
        global['Big'] = Big
    }

})( this );

define('big',['require','vendor/big'],function(require){
  var Big = require('vendor/big');
  Big.prototype.equals = function (x) { return this.cmp(x) === 0; };
  return Big;
});

define('expressions/slider',['require','pjs','lib/underscore_model','big','lib/rounding'],function(require) {
  var P = require('pjs');
  var UnderscoreModel = require('lib/underscore_model');
  var Big = require('big');
  var Rounding = require('lib/rounding');
  
  var SliderModel = P(UnderscoreModel, function (model, _super) {
    
    model.init = function (value, min, max, step) {
      _super.init.call(this);
      this.min = min !== undefined ? min : -10;
      this.max = max !== undefined ? max : 10;
      this.step = step;
      this.value = value !== undefined ? value : 0;
      this.animationSpeed = 1;
      this.playDirection = 1;
      this.isPlaying = false;
      
      this.observe('isPlaying', function () {
        if (this.isPlaying) {
          this.animationTargetValue = this.value; //Animate target value smoothly, and just round displayed value
        }
      }.bind(this));
      
      this.observe('stepper isPlaying', this.updateObservedStepper.bind(this));
    };
    
    model.updateObservedStepper = function () {
      var canPlayStep = this.isPlaying && this.stepper;
      var shouldUnobserve = (!canPlayStep || this.stepper !== this._observedStepper) && this._observedStepper;
      var shouldObserve = canPlayStep && this._observedStepper !== this.stepper;
      
      if (shouldUnobserve) {
        this._observedStepper.unobserve('playStep.' + this.guid);
        this._observedStepper = undefined;
      }
      
      if (shouldObserve ) {
        this._observedStepper = this.stepper;
        this._observedStepper.observe('playStep.' + this.guid, this.playStep.bind(this));
      }
    };
    
    model.playStep = function () {
      //PingPong behavior
      if (this.animationTargetValue >= this.max) {
        this.playDirection = -1;
      } else if (this.animationTargetValue <= this.min) {
        this.playDirection = +1;
      }

      var animationStep = (this.max - this.min) / 200;

      animationStep *= this.animationSpeed;

      //Animate target without accumulating rounding error
      this.animationTargetValue += animationStep * this.playDirection;

      var newValue = this.computeSnappedValue(this.animationTargetValue); //Always snap to slider markers
      if(!this.step){
        //If no markers, snap to a reasonable decimal close to the animation target
        newValue = Rounding.shortestDecimalBetween(newValue - animationStep * 0.1, newValue + animationStep * 0.1);
      }

      //don't exceed the endpoints
      newValue = Math.max(this.min, Math.min(this.max, newValue));

      //commit the value change
      this.setProperty('value', newValue);
    };
    
    model.serialize = function () {
      return {min: this.min, max: this.max, step: this.step, value: this.value, playDirection: this.playDirection};
    };
    
    model.computeSnappedValue = function (val) {
      if (!this.step) return val;

      var nsteps = Math.round((val - this.min)/this.step);
      // Use big.js to do exact decimal arithmetic to avoid rounding errors here.
      var snapped = (new Big(this.step)).times(nsteps).plus(this.min);
      return parseFloat(snapped.toString());
    };
    
  });
  
  SliderModel.deserialize = function (obj) {
    var slider = SliderModel();
    if (obj) {
      
      // a list of properties we care about
      var props = ['value', 'min', 'max', 'step', 'playDirection'];
      
      // copy over the properties that were set
      props.forEach(function (property) {
        if (obj.hasOwnProperty(property)) {
          slider[property] = obj[property];
        }
      });
      
    }
    return slider;
  };

  return SliderModel;
});

define('expressions/colors',['require'],function(require) {
  var RED = '#C0504D';
  var BLUE = '#4F81BD';
  var GREEN = '#9BBB59';
  var PURPLE = '#8064A2';
  var ORANGE = '#F79646';
  var BLACK = '#000000';
  var all = [ RED, BLUE, GREEN, PURPLE, ORANGE, BLACK ];
  var i = 0;

  function next () {
    var color = all[i];
    i = (i + 1) % all.length;
    return color;
  }

  function reset () {
    i = 0;
  }

  return {
    all: all,
    next: next,
    reset: reset,
    RED: RED,
    BLUE: BLUE,
    GREEN: GREEN,
    PURPLE: PURPLE,
    ORANGE: ORANGE,
    BLACK: BLACK
  };
});
define('expressions/expression',['require','pjs','math/evaluationstate','undoredo','./abstractitem','./domain','./slider','./colors'],function(require){
  var P = require('pjs');
  var EvaluationState = require('math/evaluationstate');
  var UndoRedo = require('undoredo');
  var AbstractItemModel = require('./abstractitem');
  var DomainModel = require('./domain');
  var SliderModel = require('./slider');
  var Colors = require('./colors');
  
  
  var ExpressionObject = P(AbstractItemModel, function(model, _super) {

    model._computeNewLatex = function(latex, newValue) {
      //we know the expression will look like:
      // a bunch of stuff (we ignore this in the regex)
      // an "=" (doesn't slide if it's < or >)
      // 
      // a bunch of stuff (spaces, parens, the rest of the le, ge, etc)  ($1)
      // the number we're trying to replace ($2)
      // a bunch more stuff (spaces, parens, etc.) (we ignore this in the regex)
      var regex = /=(.*?)([-\.0-9]+)/;
      
      //if they're typing something crazy like y=00001, we want to not overwrite their work
      var matches = latex.match(regex);
      if (parseFloat(matches[2]) === newValue) return latex;
      
      return latex.replace(regex, "=$1" + newValue);
    };

    model.isExpression = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);
      
      this.loading = true;
      // a default blank formula while we calculate the real one
      this.formula = EvaluationState({error:''});
      
      // TODO - this is very temporary. Eventually we'll want to save the
      // slider info in here, but there are some old states that have obsolete
      // values stored in there. We've repurposed the .slider variable on this
      // class to be a SliderModel. Because the .slider value is being set
      // on instantiation, we aren't overwriting it with a SliderModel. Then,
      // when the .slider property is expected to do things that a SliderModel
      // can, it throws an error. When we migrate old graph states to use this
      // property, we need to remove the next line.
      delete this.slider;
      // fill in a color if not specified
      if (!this.color) {
        this.color = Colors.next();
      }
      // convert old style of color definition to simpler new version
      else if (typeof this.color === 'object') {
        this.color = this.color.value;
      }
      if (this.style === undefined) {
        this.style = 'normal';
      }
      if (this.userRequestedGraphing === undefined) {
        this.userRequestedGraphing = 'default';
      }

      if (this.latex === undefined) this.latex = '';

      // convert raw domain object to a DomainModel Object
      var raw_domain = this.domain ? this.domain : {min: 0, max: 1};
      this.domain = DomainModel.deserialize(raw_domain);
      this.domain.observe('min max', function (property) {
        this.onExpressionDidChange();
        
        // handle undo/redo
        var id = this.id;
        var oldValue = this.domain.getOldProperty(property);
        var newValue = this.domain.getProperty(property);
        
        UndoRedo.addTransaction({
          type: UndoRedo.RESPONSE_TO_CHANGE,
          undo: function()  { list.getItemById(id).domain.setProperty(property, oldValue); },
          redo: function () { list.getItemById(id).domain.setProperty(property, newValue); }
        });
      }.bind(this));

      this.computeShouldGraph();
      
      this.observe('formula', this.onFormulaUpdate.bind(this));
      this.observe('latex color userRequestedGraphing style', this.onStateDidChange.bind(this));
      this.observe('latex shouldGraph color style', this.onExpressionDidChange.bind(this));
      this.observe('userRequestedGraphing', this.computeShouldGraph.bind(this));
    };
    
    model.onStateDidChange = function (prop) {
      
      // ignore latex changes from transient slider
      if (prop === 'latex' && this.slider && this.slider.transient) {
        return;
      }
      
      _super.onStateDidChange.call(this, prop);
    };
    
    model.updateFolder = function () {
      _super.updateFolder.call(this);

      // TODO namespacing with the id seems kind of gross...
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'hidden.' + this.id,
          this.computeShouldGraph.bind(this)
        );
      }
      this.computeShouldGraph();
    };
    
    model.computeShouldGraph = function () {
      var shouldGraph;
      if (this.folder && this.folder.hidden) {
        shouldGraph = false;
      } else {
        shouldGraph = (
          this.userRequestedGraphing === 'default' ||
          this.userRequestedGraphing === 'always'
        );
      }
      this.setProperty('shouldGraph', shouldGraph);
    };

    model.onExpressionDidChange = function() {
      if (this.domain.isValid()) {
        this.requestParse();
      }
    };

    model.getParsableObject = function () {
      //Work-around for bug in Mathquill / expression list
      // where on deletion of an expression via back-space key, Mathquill fires both an UpwardDelete
      // and a Render event.  UpwardDelete causes the expressionList to delete, and Render causes
      // expression list to fire another add request for the already deleted expression, which comes
      // in with latex === undefined.
      if(this.latex === undefined){
        return undefined;
      }
      return {
        type: 'statement',
        id: this.id,
        latex: this.latex,
        domain: this.domain.serialize(),
        shouldGraph: this.shouldGraph,
        color: this.color,
        style: this.style
      };
    };

    model.requestParse = function () {
      this.list.triggerAddExp(this.getParsableObject());
    };
    
    model.requestUnparse = function () {
      this.list.triggerRemoveExp(this.id);
    };

    model.onAddedToList = function () {
      this.requestParse();
    };

    model.onRemovedFromList = function () {
      // turn slider off when deleted
      if (this.slider) {
        this.slider.setProperty('isPlaying', false);
      }

      this.requestUnparse();
    };

    model.getState = function() {
      var state = {
        id: this.id,
        latex: this.latex,
        domain: this.domain.serialize(),
        userRequestedGraphing: this.userRequestedGraphing,
        color: this.color,
        style: this.style
      };
 
     // TODO - change this to state.slider = this.slider.serialize() but can't
     // do that until we convert all previously saved graphs to have a slider
     // object rather than three global properties. We either need to do that
     // or we need to make the setState() function backwards compatible.
     if (this.slider) {
       state.sliderMin = this.slider.min;
       state.sliderMax = this.slider.max;
       state.sliderInterval = this.slider.step;
     }
 
     return state;
    };
    
    model.onFormulaUpdate = function () {
      var formula = this.formula;
      
      this.setProperty('error', formula.error ? formula.error : '');
      this.setProperty('isGraphable', formula.is_graphable);
      this.setProperty('dependent', formula.assignment);
      this.setProperty('isTableable', formula.is_tableable);
      
      this.validateStyle();
      
      // delay instantiation of a slider for this expression until we need one.
      // once created, the slider object won't be destroyed. The view for the
      // slider will though. The slider sticks around to save information about
      // limits. They'd get reset each time if we didn't keep the slider.
      if (formula.is_slidable && !this.slider) {
        this.createSliderModel();
      }
    };

    model.validateStyle = function () {
      var formula = this.formula;
      if (formula.error) return;
      // If we have changed from a point to a function or vis a versa, we need to be
      // the default draw style for that type.
      if (formula.is_point_list) {
        if (!(this.style === 'point' || this.style === 'open' || this.style === 'cross')) {
          this.setProperty('style', 'point');
        }
      } else if (formula.is_inequality) {
        // Graphlayer will deal with making this dashed if the inequality requires it.
        this.setProperty('style', 'normal');
      } else {
        if (!(this.style === 'normal' || this.style === 'dashed')) {
          this.setProperty('style', 'normal');
        }
      }
    };
    
    model.createSliderModel = function () {
      this.slider = SliderModel.deserialize({
        min: this.sliderMin !== undefined ? this.sliderMin : -10,
        max: this.sliderMax !== undefined ? this.sliderMax : 10,
        step: this.sliderInterval,
        value: this.formula.simple_constant
      });

      var id = this.id;
      var list = this.list;
      
      this.slider.observe('step', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;
        
        var oldStep = this.slider.getOldProperty('step');
        var newStep = this.slider.getProperty('step');
          
        UndoRedo.addTransaction({
          type: UndoRedo.RESPONSE_TO_CHANGE,
          undo: function() {
            list.getItemById(id).slider.setProperty('step', oldStep);
          },
          redo: function() {
            list.getItemById(id).slider.setProperty('step', newStep);
          }
        });
      }.bind(this));
        
      this.slider.observe('min', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;
        
        var oldMin = this.slider.getOldProperty('min');
        var newMin = this.slider.getProperty('min');
        var oldValue = this.slider.getProperty('value');
        var oldLatex = newMin > oldValue ? this.latex : null;
        var newLatex = newMin > oldValue ? this._computeNewLatex(oldLatex, newMin) : null;
          
        UndoRedo.addTransaction({
          type: UndoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('min', oldMin);
            if (oldLatex) {
              expression.setProperty('latex', oldLatex);
            }
          },
          redo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('min', newMin);
            if (newLatex) {
              expression.setProperty('latex', newLatex);
            }
          }
        });
      }.bind(this));
        
      this.slider.observe('max', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;

        var oldMax = this.slider.getOldProperty('max');
        var newMax = this.slider.getProperty('max');
        var oldValue = this.slider.getProperty('value');
        var oldLatex = newMax < oldValue ? this.latex : null;
        var newLatex = newMax < oldValue ? this._computeNewLatex(oldLatex, newMax) : null;
          
        UndoRedo.addTransaction({
          type: UndoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('max', oldMax);
            if (oldLatex) {
              expression.setProperty('latex', oldLatex);
            }
          },
          redo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('max', newMax);
            if (newLatex) {
              expression.setProperty('latex', newLatex);
            }
          }
        });
      }.bind(this));
      
      this.slider.observe('transient', function () {
        var wasTransient = this.slider.getOldProperty('transient');
        var isTransient = this.slider.getProperty('transient');
        
        // just turned transient
        if (!wasTransient && isTransient) {
          
          // this will be filled in when we end the transient state.
          var startingValues = this.slider.serialize();
          var endingValues = this.slider.serialize();
          
          // keep a record to ending values so that we can update them when we end transient state
          this.transientEndingValues = endingValues;
          
          UndoRedo.addTransaction({
            type: UndoRedo.RESPONSE_TO_CHANGE,
            recordChange: false,
            undo: function () {
              var expression =  list.getItemById(id);
              
              // stop the slider animation
              expression.slider.setProperty('isPlaying', false);
              
              // set starting values
              for (var prop in startingValues) {
                if (startingValues.hasOwnProperty(prop)) {
                  expression.slider.setProperty(prop, startingValues[prop]);
                }
              }
             
            },
            redo: function () {
              var expression =  list.getItemById(id);

              // stop the slider animation
              expression.slider.setProperty('isPlaying', false);
              
              // set ending values
              for (var prop in endingValues) {
                if (endingValues.hasOwnProperty(prop)) {
                  expression.slider.setProperty(prop, endingValues[prop]);
                }
              }
            }
          });
        }
        
        // just ended being transient
        else if (wasTransient && !isTransient) {
          var lastValues = this.slider.serialize();

          // update the values stored within the undo/redo transaction
          for (var prop in lastValues) {
            if (lastValues.hasOwnProperty(prop)) {
              this.transientEndingValues[prop] = lastValues[prop];
            }
          }
        }
      }.bind(this));
        
      this.slider.observe('value', function () {
        var newValue = this.slider.getProperty('value');

        // if slider value is smaller than min, decrease min to equal value
        if (newValue < this.slider.min) {
          this.slider.setProperty('min', newValue);
        }
        
        // if slider value is bigger than max, increase max to equal value
        if (newValue > this.slider.max) {
          this.slider.setProperty('max', newValue);
        }

        // compute and set what the new latex should be based on the value change
        var newLatex = this._computeNewLatex(this.latex, newValue);
        this.setProperty('latex', newLatex);
      }.bind(this));
      
      // the list is going to step the slider through its animation
      this.slider.setProperty('stepper', this.list);
      
      // let others know that we've created the slider model
      this.notifyPropertyChange('slider');
    };

    model.isEmpty = function() {
      var latex = this.latex;
      return !latex || latex.split(" ").join("") === "";
    };
  });
  
  return ExpressionObject;
});

define('expressions/text',['require','pjs','./abstractitem'],function(require) {
  var P = require('pjs');
  var AbstractItemModel = require('./abstractitem');

  var TextObject = P(AbstractItemModel, function(model, _super) {
    model.isText = true;
    
    model.init = function (state, list) {
      _super.init.call(this, state, list);
      
      if (!this.text) this.text = '';
      this.observe('text', this.onStateDidChange.bind(this));
    };
    
    model.isEmpty = function() {
      return this.text.split(" ").join("") === "";
    };
    
    model.getState = function() {
      return {
        id: this.id,
        text: this.text
      };
    };

    model.markedUpText = function () {
      // Returns the text value with links wrapped in <a> tags
      var exp = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
      return this.text.replace(exp,"<a href='$1' target ='_blank'>$1</a>");
    };

  });
  
  return TextObject;
});

var _kmq = _kmq || [];
if (window._kmk) {
  var _kms = function (u){
    setTimeout(function(){
      var d = document, f = d.getElementsByTagName('script')[0],
      s = d.createElement('script');
      s.type = 'text/javascript'; s.async = true; s.src = u;
      f.parentNode.insertBefore(s, f);
    }, 1);
  };
  _kms('//i.kissmetrics.com/i.js');
  _kms('//doug1izaerwt3.cloudfront.net/' + _kmk + '.1.js');
}
;
define("analytics/kissmetrics", function(){});

//Utilities for tracking feature usage.
//Not just using straight event tracking because we want to do things like:
// * Record only the discovery of a feature
// * Record only a sub-sample of feature uses
define('lib/track_feature',['require','analytics/kissmetrics'],function(require) {
  require('analytics/kissmetrics');
  
  var discovered = {};

  var discover = function(name){
    if(discovered.hasOwnProperty(name)) return;
    discovered[name] = true;
    _kmq.push(['record', 'Discovered ' + name]);
  };

  var use = function(name){
    sample_usage(name, 1);
  };

  var sample_usage = function(name, n){
    //n should be n integer >= 1
    //Feature usage will be reported 1/n of the time, with a property which records the current n
    //In analytics, summing over this property should give a good estimate of total uses
    //Setting n = 1 will report every instance
    discover(name); //Always report if it's the first usage in a session
    if(Math.random() > 1/n) return;
    var params = {};
    params['E('+name+')'] = n;
    _kmq.push(['record', 'Used ' + name, params]);
  };

  return {
    discover: discover,
    use: use,
    sample_usage: sample_usage
  };
});

define('expressions/table',['require','underscore','pjs','lib/underscore_model','graphing/columnmode','lib/track_feature','big','./abstractitem','./colors','undoredo'],function(require) {
  var _ = require('underscore');
  var P = require('pjs');
  var UnderscoreModel = require('lib/underscore_model');
  var COLUMNMODE = require('graphing/columnmode');
  var Feature = require('lib/track_feature');
  var Big = require('big');
  var AbstractItemModel = require('./abstractitem');
  var Colors = require('./colors');
  var UndoRedo = require('undoredo');

  var Cell = P(UnderscoreModel, function (cellModel, _super) {
    
    cellModel.init = function (column, state) {
      _super.init.call(this);
      
      this.column = column;
      
      if (state) {
        this.value = state.value;
        this.error = state.error;
      }
    };
    
    cellModel.isEmpty = function () {
      return this.value.split(' ').join("") === '';
    };
  });
  
  
  var Column = P(AbstractItemModel, function(colModel, _super) {
    
    colModel.init = function (table, index, state) {

      // backwards compatibility:
      // used to used showLine and showPoints
      // now we use hidden and columnMode
      if (state.showPoints !== undefined || state.showLine !== undefined) {
        state = JSON.parse(JSON.stringify(state)); // make copy so we don't modify passed in state

        if (state.showPoints && state.showLine) {
          state.columnMode = COLUMNMODE.POINTS_AND_LINES;
        } else if (state.showPoints) {
          state.columnMode = COLUMNMODE.POINTS;
        } else if (state.showLine) {
          state.columnMode = COLUMNMODE.LINES;
        } else {
          state.hidden = true;
          state.columnMode = COLUMNMODE.POINTS;
        }
      }

      // default values
      this.latex = '';
      this.hidden = false;
      this.columnMode = COLUMNMODE.POINTS;
      this.values = [];
      this.error = '';

      _super.init.call(this, state);

      if (!this.color) {
        this.color =  Colors.next();
      }

      if (!this.style) {
        this.style =  'point';
      }

      // any column other than the first should generate the correct number
      // of blank cells if none are passed in.
      if (index !== 0 && this.values.length === 0 && table.columns[0].cells) {
        this.values = []; // don't want to modify array passed in through 'state'
        var len = table.columns[0].cells.length;
        for (var i=0; i<len; i++) {
          this.values.push('');
        }
      }
            
      // map cells from raw values to objects
      var self = this;
      this.cells = this.values.map(function (value) {
        return Cell(self, {value: String(value)});
      });
      delete this.values;

      this.table = table;
      this.index = index;
      
      // first column can't be graphed
      if (index === 0) {
        this.hidden = true;
      }
      
      // observers
      this.isGraphable = !this.error;
      this.observe('error', function () {
        this.setProperty('isGraphable', !this.error);
      }.bind(this));
      this.observe('color columnMode hidden latex style', this.onStateChange.bind(this));
      
      // need to factor in whether the table is forcing the column hidden
      this.observe('hidden hiddenByTable', this.computeShouldGraph.bind(this));
      this.computeShouldGraph();
      this.observe('shouldGraph', this.table.requestParse.bind(this.table));
    };
    
    colModel.computeShouldGraph = function () {
      this.setProperty('shouldGraph', !this.hiddenByTable && !this.hidden);
    };
    
    colModel.onStateChange = function (property) {
      this.table.requestParse();
      
      var id = this.table.id;
      var index = this.index;
      var list = this.table.list;
      function getColumn () {
        return list.getItemById(id).columns[index];
      }
      
      var oldValue = this.getOldProperty(property);
      var newValue = this.getProperty(property);
      UndoRedo.addTransaction({
        type: UndoRedo.RESPONSE_TO_CHANGE,
        undo: function () { getColumn().setProperty(property, oldValue); },
        redo: function () { getColumn().setProperty(property, newValue); }
      });
    };
    
    colModel.isEmpty = function () {
      return this.latex.split(" ").join(" ") === "";
    };
    
    colModel.getValues = function () {
      var vals = [];
      var len = this.cells.length;
      for (var i=0; i < len; i++) {
        var val = this.cells[i].value;
        if (val === null || val === undefined) {
          vals.push('');
        } else {
          vals.push(String(val));
        }
      }
      
      return vals;
    };
    
    colModel.triggerRowChange = function () {};

    colModel.insertCell = function (index, value) {
      var cell = Cell(this, {value: value});
      this.cells.splice(index, 0, cell);
    };
    
    colModel.removeCell = function (index) {
      this.cells.splice(index, 1);
    };
    
    function formatValuesForDisplay (values) {
      var vals = [];
      
      for (var i=0; i<values.length; i++) {
        var value = values[i];
        var val_str = '';
        if (_.isNumber(value)) {
          val_str = String(Number(Number(value).toFixed(4)));
          val_str = val_str.replace("NaN", "Undefined");
        }
  
        vals.push(val_str);
      }
      
      return vals;
    }
    
    colModel.setComputedValues = function (c_data) {
    
      //Track discovering dependent columns
      if(!c_data.error && c_data.dependent) Feature.discover('dependent table columns');

      // TODO - get the worker to pass back a blank array. It'll be important
      // for when we check that the size of the output matches the size of the
      // table. If there is a size mismatch, we must throw the computations
      // away because they are stale.
      
      // the worker thread doesn't pass back a list of values in this case.
      // we need to build list of null values
      if (c_data.values.length === 0 && c_data.error) {
        for (var i=0; i<this.cells.length-1; i++) {
          c_data.values[i] = null;
        }
      }
      

      this.setProperty('error', c_data.error);
      this.setProperty('discrete', c_data.discrete);
      this.setProperty('disabled', c_data.dependent);
      this.setErrors(c_data.values);
      
      if (c_data.dependent) {
           
        // if we haven't saved the independent values, save them now before
        // they get overwritten with the values sent back from the evaluator.
        if (!this.independentValues) {
          this.independentValues = this.getValues();
        }
            
        this.setValues(formatValuesForDisplay(c_data.values));
      } else if (this.independentValues) {
            
        // set the indepentedValues back.
        this.setValues(this.independentValues);
            
        // clear out the cached independent values.
        this.independentValues = null;
        
        // send the table back to the evaluator
        this.table.requestParse();
      }
    };
    
    colModel.setValues = function (values) {
      for (var i=0; i<values.length; i++) {
        this.cells[i].setProperty('value', String(values[i]));
      }
    };
    
    colModel.setErrors = function (values) {
      // if the computed value is a string, then it's an error
      for (var i=0; i<values.length; i++) {
        if (typeof values[i] === "string") {
          this.cells[i].setProperty('error', values[i]);
        } else {
          this.cells[i].setProperty('error', '');
        }
      }
    };
    
    colModel.serialize = function () {
      return {
        values: this.getValues(),
        columnMode: this.columnMode,
        hidden: this.hidden,
        id: this.id,
        color: this.color,
        style: this.style,
        latex: this.latex
      };
    };
    
  });
  
  var TableObject = P(AbstractItemModel, function(model, _super) {
    
    model.isTable = true;

    model.init = function (state, list) {
      var r, c;
      _super.init.call(this, state, list);
      
      this.list = list;
      this.selectedCell = null;
      
      // TODO - get rid of this when we upgrade states in DB
      // what we used to call 'headings' is now 'columns'
      if (this.headings) {
        this.columns = this.headings;
        delete this.headings;
      }
      
      // TODO - get rid of this when we upgrade states in DB
      // what used to be 'rows' is now transposed and part of each column
      if (this.rows) {
        for (c=0; c<this.columns.length; c++) {
          var column = this.columns[c];
          column.values = [];
          
          for (r=0; r<this.rows.length; r++) {
            column.values.push(this.rows[r][c]);
          }
        }
        
        delete this.rows;
      }
      
      // map raw columns to Column objects
      var self = this;
      if (!this.columns) this.columns = [];
      this.columns = this.columns.map(function(col_state, index){
        return Column(self, index, col_state);
      });
      
      // add a column to the right
      this.columns.push(Column(this, this.columns.length, {disabled: true}));
      
      // add a bottom row of empty values
      var lastRow = this.columns[0].cells.length;
      _.each(this.columns, function (column) {
        column.insertCell(lastRow, '');
      });
      
      // observers
      this.observe('selected', this.onSelectedChange.bind(this));
    };
    
    model.updateFolder = function () {
      _super.updateFolder.call(this);


      // TODO namespacing with the id seems kind of gross...
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'hidden.' + this.id,
          this.computeColumnsHidden.bind(this)
        );
      }
      this.computeColumnsHidden();
    };
    
    model.computeColumnsHidden = function () {
      var hidden = this.folder && this.folder.hidden;
      
      _.each(this.columns, function (column) {
        column.setProperty('hiddenByTable', hidden);
      });
    };
    
    model.onSelectedChange = function () {
      if (!this.selected) {
        this.setProperty('selectedCell', null);
      }
    };
    
    model.insertColumn = function (index, column) {
    
      var id = this.id;
      var list = this.list;
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
    
        undo: function () {
          var table = list.getItemById(id);
          table.__removeColumn(index);
        },
    
        redo: function () {
          var table = list.getItemById(id);
          table.__insertColumn(index, column);
          
          // need to update reference to heading so that
          // next time we press redo, we pass in the complete
          // heading info. This makes sure the next redo uses
          // the same color and id as the original column that
          // was later deleted and then restored.
          column = table.columns[index].serialize();
        }
      });
      
    };
    
    model.removeColumn = function (index) {
      
      var id = this.id;
      var column = this.columns[index].serialize();
      var list = this.list;
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
    
        undo: function () {
          var table = list.getItemById(id);
          table.__insertColumn(index, column);
        },
    
        redo: function () {
          var table = list.getItemById(id);
          table.__removeColumn(index);
        }
      });
    };
    
    model.moveColumn = function (from, to) {
      var id = this.id;
      var list = this.list;
      
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
        
        undo: function () {
          var table = list.getItemById(id);
          table.__moveColumn(to, from);
        },
        
        redo: function () {
          var table = list.getItemById(id);
          table.__moveColumn(from, to);
        }
      });
    };
    
    // this does the raw column insert. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnAdded = function (index) {};
    model.__insertColumn = function (index, columnData) {
      if (!columnData) {
        columnData = {};
      }

      // add column
      var column = Column(this, index, columnData);
      this.columns.splice(index, 0, column);
      
      // let every column after the insertion point know its new index
      for (var i=index+1; i<this.columns.length; i++) {
        this.columns[i].setProperty('index', i);
      }
      
      this.triggerColumnAdded(index);

      this.requestParse();
    };
    
    // this does the raw column remove. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnRemoved = function (index) {};
    model.__removeColumn = function (index) {
      
      // remove column
      this.requestUnparseColumn(index);
      this.columns.splice(index, 1);
      
      // let every column after the deletion point know its new index
      for (var i=index; i<this.columns.length; i++) {
        this.columns[i].setProperty('index', i);
      }
      
      this.triggerColumnRemoved(index);
      
      this.requestParse();
    };
    
    // this does the raw column move. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnMoved = function (from, to) {};
    model.__moveColumn = function(from, to) {
      if (from === to) return;

      var len = this.columns.length;
      var column = this.columns[from];
        
      // can't move the first or last columns
      if (from < 1 || to < 1 || from >= len-1 || to >= len-1) return;
        
      // remove from items
      this.columns.splice(from , 1);
       
      // insert back in correct spot
      this.columns.splice(to, 0, column);
      
      // insert index on each column
      for (var i=0; i<len; i++) {
        this.columns[i].setProperty('index', i);
      }
        
      // allow a view to tap into this
      this.triggerColumnMoved(from, to);
    };

    // Could try to recognize fractions and multiples of pi (or anything
    // really).
    model.getAutofillValues = function (index) {
      var i;
      var numberOfColumns = this.columns.length;
      var rowValues = [];
      for (i=0; i<numberOfColumns; i++) {
        rowValues.push('');
      }

      var firstColumn = this.columns[0].getValues();
      
      // Use big.js https://github.com/desmosinc/big.js to compute exact
      // differences and sums so that autofilling decimals works.
      // big.js will throw errors if improper input is used.
      //
      // this line just ensures that there is a constant offset between
      // each value in the first column starting from the beginning up
      // right before where we want to auto fill.
      var valDiff;
      try {
        if (index > 1) {
          valDiff = Big(firstColumn[1]).minus(firstColumn[0]);
        }
        
        for (i = 2; i<index && valDiff !== undefined; i++) {
          var nextDiff = Big(firstColumn[i]).minus(firstColumn[i-1]);
          if (!valDiff.equals(nextDiff)) {
            valDiff = undefined;
          }
        }
      } catch (e) {
        valDiff = undefined;
      }

      // add valDiff to the previous row to figure out what the autocomplete
      // value should be
      if (valDiff !== undefined) {
        rowValues[0] = valDiff.plus(firstColumn[index-1]).toString();
      }
      
      return rowValues;
    };
    
    model.setComputedValues = function (columns_data) {
      for (var i=0; i<columns_data.length; i++) {
        this.columns[i].setComputedValues(columns_data[i]);
      }
    };

    model.triggerRowAdded = function (index){};
    model.insertRow = function (index, values) {
      
      for (var i=0; i<this.columns.length; i++) {
        this.columns[i].insertCell(index, values[i]);
      }

      this.triggerRowAdded(index);

      var id = this.id;
      var list = this.list;
      UndoRedo.addTransaction({
        type: UndoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          list.getItemById(id).removeRow(index);
        },
        redo: function () {
          list.getItemById(id).insertRow(index, values);
        }
      });
      
      // TODO - only parse this row
      this.requestParse();
    };
    
    model.triggerRowRemoved = function (index) {};
    model.removeRow = function (index) {
      var values = [];

      //don't let the user delete a row if there's only one row (below the header)
      if (!this.columns.length || this.columns[0].cells.length <= 2) return;

      for (var i=0; i<this.columns.length; i++) {
        values.push(this.columns[i].cells[index].value);
        this.columns[i].removeCell(index);
      }
      
      this.triggerRowRemoved(index);
      
      var id = this.id;
      var list = this.list;
      UndoRedo.addTransaction({
        type: UndoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          list.getItemById(id).insertRow(index, values);
        },
        redo: function () {
          list.getItemById(id).removeRow(index);
        }
      });
      
      // TODO - don't need it now, but sameday may need to unparse the row
    };

    model.getParsableObject = function () {

      var columns = this.columns.map(function (column){
        
        // serialize column to pure JSON
        var obj = column.serialize();
        
        // use shouldGraph rather than hidden when deciding if to graph
        obj.hidden = !column.shouldGraph;
        
        // pop off blank bottom row
        obj.values.pop();
        
        return obj;
      });
      
      // popoff blank right column
      columns.pop();

      return {
        type: 'table',
        id: this.id,
        columns: columns
      };
    };

    model.requestParse = function () {
      this.list.triggerAddExp(this.getParsableObject());
    };
    
    model.requestUnparse = function () {
      var ids = [this.id];
      for (var i=0; i<this.columns.length; i++) {
        ids.push(this.columns[i].id);
      }
      
      this.list.triggerRemoveExps(ids);
    };
    
    model.onAddedToList = function () {
      this.requestParse();
    };
    
    model.onRemovedFromList = function () {
      this.requestUnparse();
    };
    
    model.requestUnparseColumn = function (index) {
      this.list.triggerRemoveExp(this.columns[index].id);
    };

    model.getState = function() {

      // serialize each column
      var columns = this.columns.map(function(column) {
        var data = column.serialize();
       
        // pop off blank bottom row
        data.values.pop();
       
        // TODO - do we want to do this? Might be better for loadup if
        // we save the previous values along with wether or not the column
        // was disabled. If the evaluator ever changes, we can convert
        // old graph states or just let the new system overwrite the values like
        // it does now. The two big complaints I have is that computed columns
        // show up with an 'empty' underline temporarily and the table icon
        // flickers if the column is actually continuous rather than discrete.
        // if column is disabled, all values blanked
        // TODO - convert old graph states to have '' instead of null.
        if (column.disabled) {
          data.values = data.values.map(function(){return ''});
        }
       
        return data;
      });
      
      // pop off blank right column
      columns.pop();
     
      return {
        id: this.id,
        columns: columns
      };
    };

    model.isEmpty = function() {
      return false;
    };
  });

  return TableObject;
});

define('loadcss!css/folder', function(){});
define('expressions/folder',['require','loadcss!css/folder','pjs','underscore','./abstractitem','undoredo'],function (require) {
  require('loadcss!css/folder');
  var P = require('pjs');
  var _ = require('underscore');
  var AbstractItemModel = require('./abstractitem');
  var UndoRedo = require('undoredo');

  var FolderObject = P(AbstractItemModel, function(model, _super) {
    model.isFolder = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);

      if (!this.title) this.title = '';

      if (!this.memberIds) this.memberIds = {};
      this.hidden = !!this.hidden;
      this.collapsed = !!this.collapsed;

      this.updateCount();

      this.observe('title hidden', this.onStateDidChange.bind(this));
    };

    model.updateCount = function () {
      this.setProperty('count', _.size(this.memberIds));
    };

    model.getState = function () {
      return {
        id: this.id,
        type: 'folder',
        title: this.title,
        memberIds: this.memberIds,
        hidden: this.hidden,
        collapsed: this.collapsed
      };
    };

    model._addItem = function(itemId) {
      var list = this.list;
      var item = list.getItemById(itemId);

      this.memberIds[itemId] = true;
      if (item) item.setProperty('folder', this);

      this.updateCount();
    };

    model._removeItem = function(itemId) {
      var list = this.list;
      var item = list.getItemById(itemId);

      if (item) item.setProperty('folder', undefined);
      if (this.memberIds.hasOwnProperty(itemId)) {
        delete this.memberIds[itemId];
      }
      this.updateCount();
    };

    model.addItem = function (item) {
      var list = this.list;
      var id = this.id;
      var itemId = item.id;

      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
        redo: function(){
          list.getItemById(id)._addItem(itemId);
        },
        undo: function(){
          list.getItemById(id)._removeItem(itemId);
        }
      });
    };

    model.removeItem = function (item) {
      var list = this.list;
      var id = this.id;
      var itemId = item.id;

      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
        redo: function () {
          list.getItemById(id)._removeItem(itemId);
        },
        undo: function () {
          list.getItemById(id)._addItem(itemId);
        }
      });
    };
  });

  return FolderObject;
});
define('expressions/list',['require','pjs','underscore','lib/underscore_model','./expression','./text','./table','./folder','undoredo'],function(require) {
  var P = require('pjs');
  var _ = require('underscore');
  var UnderscoreModel = require('lib/underscore_model');
  var ExpressionObject = require('./expression');
  var TextObject = require('./text');
  var TableObject = require('./table');
  var FolderObject = require('./folder');
  var UndoRedo = require('undoredo');
  
  var ExpressionListModel = P(UnderscoreModel, function (model, _super) {

    model.init = function () {
      _super.init.call(this);
      
      this.__items = [];
      this.__itemIds = {};
      this.drawOrder = [];
      
      // keep stepping sliders ever 40ms
      var self = this;
      var stepSliders = function () {
        self.batchEvaluation(function () {
          self.notifyPropertyChange('playStep');
        });

        setTimeout(function () {
          stepSliders();
        }, 40);
      };
      stepSliders();
    };

    model.getItemByIndex = function (index) {
      return this.__items[index];
    };

    model.updateDrawOrder = function () {
      var drawOrder = [];
      var listItems = _.sortBy(this.__itemIds, function (item) {return item.index});
      _.each(listItems, function(item) {
        if (item.hasOwnProperty('columns')) {
          _.each(item.columns, function (column) {
            drawOrder.push(column.id);
          });
        } else {
          drawOrder.push(item.id);
        }
      });
      this.setProperty('drawOrder', drawOrder);
    };

    model.getItemById = function(id) {
      return this.__itemIds[id];
    };

    model._insertItemAt = function (index, item) {
      var item_id = String(item.id);
      if (this.__itemIds.hasOwnProperty(item_id)) {
        throw Error('Item with id \'' + item_id + '\' is already in list');
      }
      
      // add item to list
      this.__itemIds[item_id] = item;
      this.__items.splice(index, 0, item);
      
      // request that expressions get evaluated
      item.onAddedToList();
    };

    model.triggerItemInserted = function (index, item) {};
    model.insertItemAt = function (index, item) {
      
      // insert item
      this._insertItemAt(index, item);
            
      // allow view to tap into this
      this.triggerItemInserted(index, item);
      
      // add to undo/redo
      var self = this;
      var constructor = item.constructor;
      var state = item.getState();
      UndoRedo.addTransaction({
        type: UndoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          self.removeItemAt(index);
        },
        redo: function () {
          self.insertItemAt(index, constructor(state, self));
        }
      });
      
      this.updateDrawOrder();
    };

    model.addItem = function (obj) {
      var lastObject = this.getItemByIndex(this.getItemCount() - 1);
      // Replace empty expressions
      if (
        lastObject &&
        //TODO - remove headings after DB updated
        !(lastObject.text || lastObject.columns || lastObject.headings) &&
        lastObject.latex === ''
      ) {
        this.removeItemAt(this.getItemCount()-1); //pop off last
      }

      this.insertItemAt(this.getItemCount(), obj); //push to end
    };
    
    model.updateItemById = function (id, properties) {
      this.getItemById(id).setProperties(properties);
      this.updateDrawOrder();
    };

    model._removeItemAt = function (index) {
      var item = this.__items[index];
      if (!item) return;
      
      var self = this;
      if (item.isFolder) {
        for (var id in item.memberIds) {
          self.removeItemAt(self.getItemById(id).index);
        }
      }
        
      this.__items.splice(index, 1);
      var item_id = String(item.id);
      delete this.__itemIds[item_id];

      item.onRemovedFromList();

      return item;
    };
    
    model._removeAllItems = function () {
      for (var i=0; i<this.__items.length; i++) {
        this.__items[i].onRemovedFromList();
      }
      
      this.__items = [];
      this.__itemIds = {};
    };

    model.triggerItemRemoved = function (index, item) {};
    model.removeItemAt = function (index) {
      var self = this;
      
      UndoRedo.oneTransaction(function () {
        
        var item = this._removeItemAt(index);
        
        // allow a view to tap into this
        this.triggerItemRemoved(index, item);
        
        var constructor = item.constructor;
        var state = item.getState();
        if (item.folder) item.folder.removeItem(item);
        
        UndoRedo.addTransaction({
          type: UndoRedo.RESPONSE_TO_CHANGE,
          undo: function () {
            var newItem = constructor(state, self);
            self.insertItemAt(index, newItem);
          },
          redo: function () {
            self.removeItemAt(index);
          }
        });
      }.bind(this));
      
      this.updateDrawOrder();
    };
    
    model.triggerItemMoved = function (from, to){};
    model.moveItemTo = function(a, b) {
      var self = this;

      var manipulator = function (from, to) {
        if (from === to) return;

        var len = self.getItemCount();
        var item = self.__items[from];
        
        // check that the numbers are within range
        if (from < 0 || to < 0 || from >= len || to >= len) return;
        
        // remove from items
        self.__items.splice(from , 1);
        
        // insert back in correct spot
        self.__items.splice(to, 0, item);
        
        // allow a view to tap into this
        self.triggerItemMoved(from, to);

        self.updateDrawOrder();
      };

      // add to undo/redo
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
        undo: function () {
          manipulator(b, a);
        },
        redo: function () {
          manipulator(a, b);
        }
      });
    };
    model.moveItemsTo = function(a, b, n){
      UndoRedo.oneTransaction(function () {
        var i;
        if (b >= a && b < a+n) return;
        if(a < b){
          for(i = 0; i < n; i++){
            this.moveItemTo(a, b);
          }
        } else{
          for(i = 0; i < n; i++){
            this.moveItemTo(a + i, b + i);
          }
        }
      }.bind(this));
    };
    
    model.getItemCount = function () {
      return this.__items.length;
    };

    model.isEmpty = function() {
      var len = this.getItemCount();
      if ( len === 0) return true;
      if ( len > 1) return false;

      // TODO - maybe this should be this.getItemByIndex(0).isEmpty(). Only
      // problem I see there is that tables aren't ever considered empty. Not
      // sure if we consider expression list empty if it only contains an
      // empty text.
      return this.getItemByIndex(0).latex === '';
    };

    model.getState = function() {
      var list_state = [];
      var len = this.getItemCount();

      for (var i=0; i<len; i++) {
        list_state.push(this.getItemByIndex(i).getState());
      }

      return {list: list_state};
    };

    model.batchEvaluation = function(fn){
      fn();
    };
    model.triggerSetState = function (list) {};
    model.setState = function(state) {
      var i;
      var list_content = [];
      var folders = [];
      var obj;

      for (i=0; i<state.list.length; i++) {
        var expState = state.list[i];
        
        // Start rendering UI as shell until we know if it's on screen
        expState.renderShell = true;
        
        obj = this.fromState(expState);
        
        if (!obj) continue;
        
        if (obj.isFolder) folders.push(obj);
        
        list_content.push(obj);
      }

      // remove all items and then add the new ones in a single batch
      var self = this;
      this.batchEvaluation(function () {
        self._removeAllItems();
      
        for (i=0; i<list_content.length; i++) {
          self._insertItemAt(i, list_content[i]);
        }
      });

      // Tell expressions about their parent folders.
      folders.forEach(function (folder) {
        for (var id in folder.memberIds) {
          self.getItemById(id).setProperty('folder', folder);
        }
      });

      // allow the view to tap into this
      this.triggerSetState(list_content);

      this.updateDrawOrder();
    };
    
    // Factory method for making a single expression object of the appropriate
    // type from a serialized state.
    model.fromState = function(itemState) {
      if (itemState.text !== undefined) {
        return TextObject(itemState, this);
      }
      if (itemState.columns !== undefined || itemState.headings !== undefined ) {
        // TODO - remove headings after DB updated
        return TableObject(itemState, this);
      }

      if (itemState.type === 'folder') return FolderObject(itemState, this);

      // Expression object
      var valid_graph_modes = ['default', 'always', 'never'];
      
      if (valid_graph_modes.indexOf(itemState.userRequestedGraphing) === -1) {
        if (itemState.hasOwnProperty('graphed')) {
          itemState.userRequestedGraphing = !!itemState.graphed ?
            'always' :
            'never'
          ;
        } else {
          itemState.userRequestedGraphing = 'default';
        }
      }
      
      return ExpressionObject(itemState, this);
    };
    
    model.triggerRemoveExps = function () {};
    model.triggerRemoveExp = function () {};
    model.triggerAddExp = function () {};
  });


  return ExpressionListModel;
});

// i18next, v1.6.3
// Copyright (c)2013 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com
(function (root, factory) {
    if (typeof exports === 'object') {

        module.exports = factory();

    } else if (typeof define === 'function' && define.amd) {

        define('i18next',[], factory);

    } 
}(this, function () {

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }
    
    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }

    var $ = undefined
        , i18n = {}
        , resStore = {}
        , currentLng
        , replacementCounter = 0
        , languages = [];

    // defaults
    var o = {
        lng: undefined,
        load: 'all',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: 'dev',
        fallbackNS: [],
        detectLngQS: 'setLng',
        ns: 'translation',
        fallbackOnNull: true,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,
        
        resGetPath: 'locales/__lng__/__ns__.json',
        resPostPath: 'locales/add/__lng__/__ns__',
    
        getAsync: true,
        postAsync: true,
    
        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,
    
        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',
    
        interpolationPrefix: '__',
        interpolationSuffix: '__',
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,
    
        setJqueryExt: true,
        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
    
        postProcess: undefined,
        parseMissingKey: undefined
    };
    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }
        
        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }
    
    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || typeof object === "function";
    
        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }
    
        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }
    
        return object;
    }
    
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };
    
    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });    
        }else{
            return data;
        }
    }
    
    function _ajax(options) {
    
        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }
    
            // If no XHR support was found, throw an error.
            return callback(new Error());
        };
    
        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }
    
            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }
    
            return result.join('&');
        };
    
        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';
    
            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
    
                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }
    
            return result;
        };
    
        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
    
            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);
    
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
    
                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }
    
                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);
    
            return result;
        };
    
        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];
    
            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }
    
            // Return the merged headers.
            return result;
        };
    
        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }
    
            // Set default parameter values.
            options.cache = options.cache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;
    
            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);
    
            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);            
            }
    
            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }
    
                // Handle caching.
                if(!options.cache) {
                    queryString.push('_=' + (new Date()).getTime());
                }
    
                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }
    
                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }
    
                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);                
                    return;
                }
            }
    
            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);
    
                // Open the request.
                xhr.open(method, url, options.async);
    
                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }
    
                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';
    
                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }
    
                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, {
                            text: function () {
                                return data;
                            },
    
                            json: function () {
                                return JSON.parse(data);
                            }
                        });
                    }
                };
    
                // Actually send the XHR request.
                xhr.send(payload);
            });
        };
    
        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },
    
            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);            
            },
    
            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);            
            },
    
            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },
    
            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },
    
            headers: function (headers) {
                ajax.headers = headers || {};
            },
    
            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },
    
            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },
    
            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);            
            },
    
            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);            
            },
            
            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);            
            },
    
            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };
    
    
        var methode = options.type ? options.type.toLowerCase() : 'get';
    
        http[methode](options.url, options, function (status, data) {
            if (status === 200) {
                options.success(data.json(), status, null);
            } else {
                options.error(data.text(), status, null);
            }
        });
    }
    
    var _cookie = {
        create: function(name,value,minutes) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            document.cookie = name+"="+value+expires+"; path=/";
        },
    
        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },
    
        remove: function(name) {
            this.create(name,"",-1);
        }
    };
    
    var cookie_noop = {
        create: function(name,value,minutes) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };
    
    
    
    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : _ajax,
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {

        },
        toLanguages: function(lng) {
            var languages = [];
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');
    
                lng = o.lowerCaseLng ? 
                    parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                    parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
    
                if (o.load !== 'unspecific') languages.push(lng);
                if (o.load !== 'current') languages.push(parts[0]);
            } else {
                languages.push(lng);
            }
    
            if (languages.indexOf(o.fallbackLng) === -1 && o.fallbackLng) languages.push(o.fallbackLng);
    
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }
    };
    function init(options, cb) {
        
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};
        
        // override defaults with passed in options
        f.extend(o, options);
    
        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }
    
        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }
    
        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
    
        if (!o.lng) o.lng = f.detectLanguage(); 
        if (o.lng) {
            // set cookie with lng set (as detectLanguage will set cookie on need)
            if (o.useCookie) f.cookie.create(o.cookieName, o.lng, o.cookieExpirationTime);
        } else {
            o.lng =  o.fallbackLng;
            if (o.useCookie) f.cookie.remove(o.cookieName);
        }
    
        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);
    
        pluralExtensions.setCurrentLng(currentLng);
    
        // add JQuery extensions
        if ($ && o.setJqueryExt) addJqueryFunct();
    
        // jQuery deferred
        var deferred;
        if ($ && $.Deferred) {
            deferred = $.Deferred();
        }
    
        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            if (cb) cb(translate);
            if (deferred) deferred.resolve();
            if (deferred) return deferred.promise();
            return;
        }
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // else load them
        i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
    
            if (cb) cb(translate);
            if (deferred) deferred.resolve();
        });
    
        if (deferred) return deferred.promise();
    }
    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }
    
    function addResourceBundle(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        f.extend(resStore[lng][ns], resources);
    }
    
    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }
    
    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }
    
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }
    
            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }
    
        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;
    
                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {
    
                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }
    
                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];
    
                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }
    
    function setLng(lng, cb) {
        return init({lng: lng}, cb);
    }
    
    function lng() {
        return currentLng;
    }
    function addJqueryFunct() {
        // $.t shortcut
        $.t = $.t || translate;
    
        function parse(ele, key, options) {
            if (key.length === 0) return;
    
            var attr = 'text';
    
            if (key.indexOf('[') === 0) {
                var parts = key.split(']');
                key = parts[1];
                attr = parts[0].substr(1, parts[0].length-1);
            }
    
            if (key.indexOf(';') === key.length-1) {
                key = key.substr(0, key.length-2);
            }
    
            var optionsToUse;
            if (attr === 'html') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.html($.t(key, optionsToUse));
            } 
            else if (attr === 'text') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.text() }, options) : options;
                ele.text($.t(key, optionsToUse));
            } else {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.attr(attr) }, options) : options;
                ele.attr(attr, $.t(key, optionsToUse));
            }
        }
    
        function localize(ele, options) {
            var key = ele.attr(o.selectorAttr);
            if (!key) return;
    
            var target = ele
              , targetSelector = ele.data("i18n-target");
            if (targetSelector) {
                target = ele.find(targetSelector) || ele;
            }
    
            if (!options && o.useDataAttrOptions === true) {
                options = ele.data("i18n-options");
            }
            options = options || {};
    
            if (key.indexOf(';') >= 0) {
                var keys = key.split(';');
    
                $.each(keys, function(m, k) {
                    if (k !== '') parse(target, k, options);
                });
    
            } else {
                parse(target, key, options);
            }
    
            if (o.useDataAttrOptions === true) ele.data("i18n-options", options);
        }
    
        // fn
        $.fn.i18n = function (options) {
            return this.each(function() {
                // localize element itself
                localize($(this), options);
    
                // localize childs
                var elements =  $(this).find('[' + o.selectorAttr + ']');
                elements.each(function() { 
                    localize($(this), options);
                });
            });
        };
    }
    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;
        
        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
    
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;
    
        f.each(replacementHash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), value);
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.escape(value));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), value);
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }
    
    // append it to functions
    f.applyReplacement = applyReplacement;
    
    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';
    
        var opts = f.extend({}, options);
        delete opts.postProcess;
    
        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
    
    
            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }
    
            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, translated_token);
        }
        return translated;
    }
    
    function hasContext(options) {
        return (options.context && typeof options.context == 'string');
    }
    
    function needsPlural(options) {
        return (options.count !== undefined && typeof options.count != 'string' && options.count !== 1);
    }
    
    function exists(key, options) {
        options = options || {};
    
        var notFound = options.defaultValue || key
            , found = _find(key, options);
    
        return found !== undefined || found === notFound;
    }
    
    function translate(key, options) {
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }
    
    function _injectSprintfProcessor() {
        
        var values = [];
        
        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }
        
        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }
    
    function _translate(key, options) {
        
        if (typeof options == 'string') {
            // mh: gettext like sprintf syntax found, automatically create sprintf processor
            options = _injectSprintfProcessor.apply(null, arguments);
        } else {
            options = options || {};
        }         
    
        var notFound = options.defaultValue || key
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;
    
        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (found === undefined && o.sendMissing) {
            if (options.lng) {
                sync.postMissing(lngs[0], ns, key, notFound, lngs);
            } else {
                sync.postMissing(o.lng, ns, key, notFound, lngs);
            }
        }
    
        var postProcessor = options.postProcess || o.postProcess;
        if (found !== undefined && postProcessor) {
            if (postProcessors[postProcessor]) {
                found = postProcessors[postProcessor](found, key, options);
            }
        }
    
        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }
    
        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);
    
            if (postProcessor && postProcessors[postProcessor]) {
                var val = options.defaultValue || key;
                found = postProcessors[postProcessor](val, key, options);
            }
        }
    
        return (found !== undefined) ? found : notFound;
    }
    
    function _find(key, options){
        options = options || {};
    
        var optionWithoutCount, translated
            , notFound = options.defaultValue || key
            , lngs = languages;
    
        if (!resStore) { return notFound; } // no resStore to translate from
    
        if (options.lng) {
            lngs = f.toLanguages(options.lng);
    
            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;
    
                i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }
    
        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;
    
            var contextKey = ns + o.nsseparator + key + '_' + options.context;
    
            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }
    
        if (needsPlural(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.count;
            optionWithoutCount.defaultValue = o.pluralNotFound;
    
            var pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
            var pluralExtension = pluralExtensions.get(lngs[0], options.count);
            if (pluralExtension >= 0) {
                pluralKey = pluralKey + '_' + pluralExtension;
            } else if (pluralExtension === 1) {
                pluralKey = ns + o.nsseparator + key; // singular
            }
    
            translated = translate(pluralKey, optionWithoutCount);
            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } // else continue translation with original/singular key
        }
    
        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;
    
            var l = lngs[i];
    
            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (Object.prototype.toString.apply(value) === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                            'returned a object instead of string.';
                        f.log(value);
                    } else {
                        var copy = {}; // apply child translation on a copy
                        for (var m in value) {
                            // apply translation on childs
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        }
                        value = copy;
                    }
                }
                found = value;
            }
        }
    
        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) { 
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;
    
            if (o.fallbackNS.length) {
    
                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
                    
                    if (found) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
    
                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
        }
    
        return found;
    }
    function detectLanguage() {
        var detectedLng;
    
        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var parms = query.split('&');
                for (var i=0; i<parms.length; i++) {
                    var pos = parms[i].indexOf('=');
                    if (pos > 0) {
                        var key = parms[i].substring(0,pos);
                        var val = parms[i].substring(pos+1);
                        qsParm[key] = val;
                    }
                }
            })();
            if (qsParm[o.detectLngQS]) {
                detectedLng = qsParm[o.detectLngQS];
            }
        }
    
        // get from cookie
        if (!detectedLng && typeof document !== 'undefined' && o.useCookie ) {
            var c = f.cookie.read(o.cookieName);
            if (c) detectedLng = c;
        }
    
        // get from navigator
        if (!detectedLng && typeof navigator !== 'undefined') {
            detectedLng =  (navigator.language) ? navigator.language : navigator.userLanguage;
        }
        
        return detectedLng;
    }
    var sync = {
    
        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }
    
                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);
    
                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },
    
        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();
    
            if(window.localStorage) {
    
                var todo = lngs.length;
    
                f.each(lngs, function(key, lng) {
                    var local = window.localStorage.getItem('res_' + lng);
    
                    if (local) {
                        local = JSON.parse(local);
    
                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }
    
                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },
    
        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    window.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },
    
        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};
            
            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;
    
                // load each file individual
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        
                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;
    
                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };
                        
                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });
            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };
    
                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data);
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "json",
                        async : options.getAsync
                    });
                }    
            }
        },
    
        _fetchOne: function(lng, ns, options, done) {
            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    done(null, data);
                },
                error : function(xhr, status, error) {
                    f.log('failed loading: ' + url);
                    done(error, {});
                },
                dataType: "json",
                async : options.getAsync
            });
        },
    
        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;
    
            var urls = [];
    
            if (o.sendMissingTo === 'fallback' && o.fallbackLng !== false) {
                urls.push({lng: o.fallbackLng, url: applyReplacement(o.resPostPath, { lng: o.fallbackLng, ns: ns })});
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }
    
            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);
    
                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        }
    };
    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
    var pluralExtensions = {
    
        rules: {
            "ach": {
                "name": "Acholi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "af": {
                "name": "Afrikaans", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ak": {
                "name": "Akan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "am": {
                "name": "Amharic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "an": {
                "name": "Aragonese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ar": {
                "name": "Arabic", 
                "numbers": [
                    0, 
                    1, 
                    2, 
                    3, 
                    11, 
                    100
                ], 
                "plurals": function(n) { return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5); }
            }, 
            "arn": {
                "name": "Mapudungun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ast": {
                "name": "Asturian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ay": {
                "name": "Aymar\u00e1", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "az": {
                "name": "Azerbaijani", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "be": {
                "name": "Belarusian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "bg": {
                "name": "Bulgarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bn": {
                "name": "Bengali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bo": {
                "name": "Tibetan", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "br": {
                "name": "Breton", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "bs": {
                "name": "Bosnian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ca": {
                "name": "Catalan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "cgg": {
                "name": "Chiga", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "cs": {
                "name": "Czech", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "csb": {
                "name": "Kashubian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "cy": {
                "name": "Welsh", 
                "numbers": [
                    1, 
                    2, 
                    3, 
                    8
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3); }
            }, 
            "da": {
                "name": "Danish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "de": {
                "name": "German", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "dz": {
                "name": "Dzongkha", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "el": {
                "name": "Greek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "en": {
                "name": "English", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eo": {
                "name": "Esperanto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es": {
                "name": "Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es_ar": {
                "name": "Argentinean Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "et": {
                "name": "Estonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eu": {
                "name": "Basque", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fa": {
                "name": "Persian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "fi": {
                "name": "Finnish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fil": {
                "name": "Filipino", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fo": {
                "name": "Faroese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fr": {
                "name": "French", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fur": {
                "name": "Friulian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fy": {
                "name": "Frisian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ga": {
                "name": "Irish", 
                "numbers": [
                    1, 
                    2,
                    3,
                    7, 
                    11
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;}
            }, 
            "gd": {
                "name": "Scottish Gaelic", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    20
                ], 
                "plurals": function(n) { return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3); }
            }, 
            "gl": {
                "name": "Galician", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gu": {
                "name": "Gujarati", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gun": {
                "name": "Gun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ha": {
                "name": "Hausa", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "he": {
                "name": "Hebrew", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hi": {
                "name": "Hindi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hr": {
                "name": "Croatian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "hu": {
                "name": "Hungarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hy": {
                "name": "Armenian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ia": {
                "name": "Interlingua", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "id": {
                "name": "Indonesian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "is": {
                "name": "Icelandic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n%10!=1 || n%100==11); }
            }, 
            "it": {
                "name": "Italian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ja": {
                "name": "Japanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jbo": {
                "name": "Lojban", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jv": {
                "name": "Javanese", 
                "numbers": [
                    0, 
                    1
                ], 
                "plurals": function(n) { return Number(n !== 0); }
            }, 
            "ka": {
                "name": "Georgian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kk": {
                "name": "Kazakh", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "km": {
                "name": "Khmer", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kn": {
                "name": "Kannada", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ko": {
                "name": "Korean", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ku": {
                "name": "Kurdish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "kw": {
                "name": "Cornish", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    4
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3); }
            }, 
            "ky": {
                "name": "Kyrgyz", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lb": {
                "name": "Letzeburgesch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ln": {
                "name": "Lingala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "lo": {
                "name": "Lao", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lt": {
                "name": "Lithuanian", 
                "numbers": [
                    1, 
                    2,
                    10
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "lv": {
                "name": "Latvian", 
                "numbers": [
                    0, 
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2); }
            }, 
            "mai": {
                "name": "Maithili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mfe": {
                "name": "Mauritian Creole", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mg": {
                "name": "Malagasy", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mi": {
                "name": "Maori", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mk": {
                "name": "Macedonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n==1 || n%10==1 ? 0 : 1); }
            }, 
            "ml": {
                "name": "Malayalam", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mn": {
                "name": "Mongolian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mnk": {
                "name": "Mandinka", 
                "numbers": [
                    0, 
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(0 ? 0 : n==1 ? 1 : 2); }
            }, 
            "mr": {
                "name": "Marathi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ms": {
                "name": "Malay", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "mt": {
                "name": "Maltese", 
                "numbers": [
                    1, 
                    2, 
                    11, 
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3); }
            }, 
            "nah": {
                "name": "Nahuatl", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nap": {
                "name": "Neapolitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nb": {
                "name": "Norwegian Bokmal", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ne": {
                "name": "Nepali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nl": {
                "name": "Dutch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nn": {
                "name": "Norwegian Nynorsk", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "no": {
                "name": "Norwegian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nso": {
                "name": "Northern Sotho", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "oc": {
                "name": "Occitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "or": {
                "name": "Oriya", 
                "numbers": [
                    2, 
                    1
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pa": {
                "name": "Punjabi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pap": {
                "name": "Papiamento", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pl": {
                "name": "Polish", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "pms": {
                "name": "Piemontese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ps": {
                "name": "Pashto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt": {
                "name": "Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt_br": {
                "name": "Brazilian Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "rm": {
                "name": "Romansh", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ro": {
                "name": "Romanian", 
                "numbers": [
                    1, 
                    2,
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2); }
            }, 
            "ru": {
                "name": "Russian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "sah": {
                "name": "Yakut", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sco": {
                "name": "Scots", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "se": {
                "name": "Northern Sami", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "si": {
                "name": "Sinhala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sk": {
                "name": "Slovak", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "sl": {
                "name": "Slovenian", 
                "numbers": [
                    5, 
                    1, 
                    2, 
                    3
                ], 
                "plurals": function(n) { return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
            }, 
            "so": {
                "name": "Somali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "son": {
                "name": "Songhay", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sq": {
                "name": "Albanian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sr": {
                "name": "Serbian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "su": {
                "name": "Sundanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sv": {
                "name": "Swedish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sw": {
                "name": "Swahili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ta": {
                "name": "Tamil", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "te": {
                "name": "Telugu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tg": {
                "name": "Tajik", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "th": {
                "name": "Thai", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ti": {
                "name": "Tigrinya", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tk": {
                "name": "Turkmen", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tr": {
                "name": "Turkish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tt": {
                "name": "Tatar", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ug": {
                "name": "Uyghur", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "uk": {
                "name": "Ukrainian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ur": {
                "name": "Urdu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "uz": {
                "name": "Uzbek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "vi": {
                "name": "Vietnamese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "wa": {
                "name": "Walloon", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "wo": {
                "name": "Wolof", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "yo": {
                "name": "Yoruba", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "zh": {
                "name": "Chinese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }
        },
    
        // for demonstration only sl and ar is added but you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;    
        },
    
        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');
    
                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },
    
        get: function(lng, count) {
            var parts = lng.split('-');
    
            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule; 
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i = ext.plurals(c);
                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) { 
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }
                        
            return getResult(parts[0], count);
        }
    
    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };
    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }
    
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
    
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }
    
                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };
    
        str_format.cache = {};
    
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };
    
        return str_format;
    })();
    
    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };
    
    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;
    
        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }
    
        return val;
    });
    // public api interface
    i18n.init = init;
    i18n.setLng = setLng;
    i18n.preload = preload;
    i18n.addResourceBundle = addResourceBundle;
    i18n.loadNamespace = loadNamespace;
    i18n.loadNamespaces = loadNamespaces;
    i18n.setDefaultNamespace = setDefaultNamespace;
    i18n.t = translate;
    i18n.translate = translate;
    i18n.exists = exists;
    i18n.detectLanguage = f.detectLanguage;
    i18n.pluralExtensions = pluralExtensions;
    i18n.sync = sync;
    i18n.functions = f;
    i18n.lng = lng;
    i18n.addPostProcessor = addPostProcessor;
    i18n.options = o;
        
    return i18n; 

}));
define('i18n',['require','i18next','config'],function (require) {
  //Configured and initialized i18n, to prevent ever using unconfigured version
  var i18n = require('i18next');
  var Config = require('config');

  var i18nOptions = {
    getAsync: false,
    fallbackLng: false,
    resGetPath: '/assets/generated/locales/__lng__/__ns__.json',
    detectLngQS: 'lang',
    useCookie: false,
    resStore: {en:{translation:{}}}
  };

  // If we are setting a ?lang, then fetch the file, if not then short circuit i18next with an
  // empty translation store (resStore above) so we don't load anything but passthrough
  // strings instead.
  if (Config.get('lang')) {
    delete i18nOptions.resStore;
  }

  i18n.init(i18nOptions);

  return i18n;
});

define('lib/underscore_view',['require','jquery','underscore','./underscore_model','pjs','i18n'],function(require){
var $ = require('jquery');
var _ = require('underscore');
var UnderscoreModel = require('./underscore_model');
var P = require('pjs');
var i18n = require('i18n');

var UnderscoreView = P(UnderscoreModel, function(view){
  
  view.$ = function (selector) {
    var $node = $(this.__domNode);
    if (!selector) {
     return $node;
    } else {
      return $node.filter(selector).add($node.find(selector));
    }
  };

  // methods to adding view to dom. these call .didInsertElement()
  // automatically
  var makeInsertFn = function (methodName) {
    return function (selector) {
      if (!this.__domNode) _render.call(this);

      $(selector)[methodName](this.$());
      this.didInsertElement();
      return this.$();
    };
  };

  view.appendTo = makeInsertFn('append');
  view.replace = makeInsertFn('replaceWith');
  view.prependTo = makeInsertFn('prepend');
  view.insertAfter = makeInsertFn('after');
  view.insertBefore = makeInsertFn('before');

  view.remove = function () {
    this.$().remove();
    this.destruct();
  };
  
  // should be overriden and used to cleanup any resources this view has
  // aquired. Most often, that means remove any observers set and any child
  // views created.
  view.destruct = function () {};
  
  // Called when the view has been rendered, but before its DOM node has been
  // inserted into the document. This is a good time to attach child views and
  // event listeners.
  view.didCreateElement = function () {};
  
  // for this to be called, must insert this.$() into dom using one of the
  // methods above. If not, you must call .didInsertElement() yourself.
  view.didInsertElement = function () {};
  
  // this is the information that will be made available to the underscore template
  view.getTemplateParams = function () {return {};};
  
  // tap into these if you want deep control of how a complete rerender happens.
  // one thing these are useful for are saving/restoring temporary data within
  // the view that will get wiped out when the html is regenerated.
  view.beforeRerender = function () {};
  view.afterRerender = function () {};

  // will render only if something has changed
  view.rerender = function () {
    var oldDomNode = this.__domNode;
    var newParams = this.getTemplateParams();
    if (_.isEqual(newParams, this.__lastRenderParams)) return;

    this.beforeRerender();

    _render.call(this);

    if (oldDomNode && $.contains(document, oldDomNode)) {
      this.replace(oldDomNode);
    }

    this.afterRerender();
  };
  
  view.setDomNode = function (node) {
    this.__domNode = node[0] ? node[0] : node;
    this.didInsertElement();
  };

  // private
  var _render = function () {
    var params = this.getTemplateParams();
    var helpers = {
      t: function(key, args){ return i18n.t(key, args);}
    };
    var combined = _.extend({}, params, helpers);
    var html = this.template(combined);
    var $node = $(html);
    this.__domNode = $node[0];
    this.__lastRenderParams = params;
    this.didCreateElement();
  };

});
return UnderscoreView;
});

define('expressions/dragdrop',['require','jquery','pjs','tipsy'],function(require){
  var $ = require('jquery');
  var P = require('pjs');
  var Tipsy = require('tipsy');

  var DragDrop = P(function(dragdrop){

    // methods to be filled in by subclass
    dragdrop.toggleStyling = function(isDragging) {};
    dragdrop.onDragStart = function (evt, view) {};
    dragdrop.onDragStop = function (evt) {};
    dragdrop.commitDragState = function(dragState) {};
    dragdrop.updateScroll = function () {};
    dragdrop.computeDragPosition = function (x,y) { return {x:x, y:y} };
    dragdrop.computeDragState = function (list, dragPosition) { return {} };
    dragdrop.previewDragState = function(dragState) {};
    dragdrop.buildDragList = function () {};

    dragdrop.init = function(expr_list){
      this.expressions = expr_list;
      this.active = false;
    };
    
    dragdrop.start = function(evt, view){
      if(evt.touches.length !== 1) return;
      if(evt.wasHandled('longhold')) return;
      this.active = true;
      this.exppanel = this.expressions.$('#exppanel');
      
      this.setupEventListeners(evt);
      this.onDragStart(evt, view);

      this.dragList = this.buildDragList();
      this.toggleStyling(true);
      this.drag(evt.touches[0].x, evt.touches[0].y); //Do first drag
      
      // disable tipsy while dragging
      Tipsy.addDisableLock();
    };

    dragdrop.setupEventListeners = function(evt){
      // save the touch identifier so that multitouch doesn't mess us up. Also
      // create a function that allows us to lookup the touch we care about.
      var touch_identifier = evt.touches[0].identifier;
      function getTouch (evt) {
        for (var i=0; i < evt.touches.length; i++) {
          var touch = evt.touches[i];
          if (touch.identifier === touch_identifier) {
            return touch;
          }
        }
      }

      var self = this;

      // listen for mouse movements and tell DragDrop about them.
      $(document).on('tapmove.dragdrop', function (evt) {
        // touch must still be around
        var touch = getTouch(evt);
        if (!touch) return;
        self.drag(touch.x, touch.y);
      });
      
      // listen for mouse ups and tell DragDrop about them.
      $(document).on('tapend.dragdrop', function (evt) {
        // touch must not be around
        var touch = getTouch(evt);
        if (touch) return;
        self.stop();
        evt.handle('dragdrop');
      });

      //add event listener on exppanel.scroll
      this.exppanel.on('scroll.dragdrop', this.drag.bind(this));
    };

    dragdrop.stop = function(evt){
      this.active = false;

      //Clear listeners
      $(document).off('.dragdrop');

      //Get rid of preview styling
      this.toggleStyling(false);

      //Commit changes to model
      this.commitDragState(this.dragState);

      this.onDragStop(evt);
      
      // reenable tipsy after dragging
      Tipsy.removeDisableLock();
    };

    dragdrop.drag = function(x, y){
      if (!this.active) return;
      
      //Need to cache mouse position for scroll-triggered udpates
      if (typeof(x) === 'number') this.mouseX = x;
      if (typeof(y) === 'number') this.mouseY = y;
      
      this.updateScroll();

      var dragPosition = this.computeDragPosition(this.mouseX, this.mouseY);
      this.dragState = this.computeDragState(this.dragList, dragPosition);
      this.previewDragState(this.dragState);
    };
  });

  // TODO - any kind of user interaction (undo, typing, etc) should call
  // finishDrag to prevent us from getting in a weird state where we're dragging
  // an expression that doesn't exist.

  return DragDrop;
});
define('expressions/dragdrop_expressions',['require','jquery','underscore','lib/browser','pjs','undoredo','./dragdrop'],function(require){
  var $ = require('jquery');
  var _ = require('underscore');
  var Browser = require('lib/browser');
  var P = require('pjs');
  var UndoRedo = require('undoredo');
  var DragDrop = require('./dragdrop');

  var DragDropExpressions = P(DragDrop, function(dragdrop, _super){
    
    dragdrop.toggleStyling = function(isDragging){
      this.exppanel.toggleClass('isDragging', isDragging);
      this.draggedView.$().toggleClass('dragging', isDragging);
      if(!isDragging){
        //Remove things that are set by preview code
        this.draggedView.$().removeClass('overFolder');
        $('.expressionitem').css('transform', 'none');
      }
    };
    
    dragdrop.onDragStart = function (evt, view) {
      this.expressions.setSelected(null);
      this.exppanel = this.expressions.$('#exppanel');
      
      $(document.activeElement).blur();
      evt.preventDefault();

      this.draggedView = view;
      this.draggedViewHeight = view.$().outerHeight() - 1; //because of the negative 1 margin

      this.panelTop = this.exppanel.offset().top;
      this.panelHeight = this.exppanel.height();
      this.panelBottom = this.panelTop + this.panelHeight;

      this.grabOffset = view.$().offset().top - evt.touches[0].y;
      this.grabY = this.computeDragPosition(evt.touches[0].x, evt.touches[0].y).y;
      this.grabIndex = view.model.index;
      this.draggedViewCount = 1;

      if(view.model.isFolder){
        this.draggedViewCount += _.size(view.model.memberIds);
        this.dropCollapsed = view.model.collapsed; //Cache whether folder is collapsed before collapsing
        view.model.setProperty('collapsed', true);
      }
    };
    
    dragdrop.onDragStop = function (evt) {
      clearTimeout(this.scrollTimeout);

      //Select the expression we just dragged
      this.expressions.setSelected(this.draggedView.model);
    };

    dragdrop.buildDragList = function(){
      var self = this;
      var expressions = this.expressions.getItemsByIndexRange(0, Infinity);

      var list = [{
        y: -Infinity,
        index: 0,
        folder: undefined
      }];

      var lastItem = [{
        y: Infinity,
        index: 0,
        folder: undefined
      }];

      expressions.forEach(function(expression){
        if(expression.id === self.draggedView.model.id) return;
        if(expression.folder && expression.folder.collapsed) return;
        if(expression.folder && self.draggedView.model.isFolder) return;

        //Figure out which expressions are included in this drag item
        var view = self.expressions.getItemView(expression.id);
        var belowGrabbedView = (expression.index > self.grabIndex);
        var elements = view.$();
        if (expression.isFolder && (expression.collapsed || self.draggedView.model.isFolder)){
          for (var id in expression.memberIds) {
            elements.push(self.expressions.getItemView(id).$()[0]);
          }
        }
        
        //Compute dimensions of the expression(s), removing draggedView from list
        var offset = (belowGrabbedView ? -self.draggedViewHeight : 0);
        var height = view.$().height();
        var top = view.$().position().top + offset;

        //Compute indexes for before and after the expression(s)
        var indexOffset = (belowGrabbedView ? -1 : 0); //-self.draggedViewCount : 0);
        var indexBefore = expression.index + indexOffset;
        var indexAfter = indexBefore + elements.length;

        //Compute folder insertion behavior
        var topFolder, midFolder;
        if(!self.draggedView.model.isFolder){
          topFolder = expression.folder;
          midFolder = (expression.isFolder ? expression : expression.folder);
        }

        //Record what happens when dragging past the top of the expression
        list.push({
          y: top,
          index: indexBefore,
          folder: topFolder
        });

        //Record what happens when dragging past the midpoint of the expression
        list.push({
          y: top + height / 2,
          index: indexAfter,
          folder: midFolder,

          elements: elements, //TODO - should include all elements dragged past
          offset: offset
        });

        //Record what happens when dragging past the bottom of the expression
        //Only appended to list if this was the last item
        lastItem = {
          y: top + height,
          index: indexAfter,
          folder: undefined
        };

      });
      list.push(lastItem);

      return list;
    };
    
    // allows expression list to scroll drag above or below it
    dragdrop.updateScroll = function() {
      clearTimeout(this.scrollTimeout);
      if(!this.active) return;
      var scrollSpeed = 0;

      //Use being over top of list (into header bar) as cue to start scrolling up
      scrollSpeed = Math.min(scrollSpeed, (this.mouseY - this.panelTop));

      //Use bottom 30 pixels as cue to start scrolling down  30px is smaller than one equation,
      //But still big enough to trigger easily
      scrollSpeed = Math.max(scrollSpeed, (this.mouseY - this.panelBottom + 30));

      //Adjust the speed based on the expressions list height.
      //A 30 pixel offset should get us to the other side in about 1 second of 30hz updates
      //30 pixels * 30 updates = 900
      scrollSpeed = (scrollSpeed * this.panelHeight / 900);

      if(scrollSpeed){
        this.exppanel.scrollTop(this.exppanel.scrollTop() + scrollSpeed);
        this.scrollTimeout = setTimeout(this.updateScroll.bind(this), 30);
      }
    };

    //Compute position of the dragged view in terms of the scrolled list
    dragdrop.computeDragPosition = function(x, y) {
      //Clamp effective mouse position to edges of panel
      y = Math.max(y, Math.min(y, this.panelBottom), this.panelTop);

      //Make position relative to the panel
      y -= this.panelTop;

      //Add offset for where element was grabbed
      y += this.grabOffset;

      //Compensate for scrolling
      return {x:NaN, y: y+this.exppanel.scrollTop()};
    };

    //Takes a list of states, which each includes the y value at which it starts,
    //as well as the index and the folder which the dragged item would have it it
    //is dropped below that line.
    dragdrop.computeDragState = function(list, dragPosition){
      function sortMethod (item) {
        return item.y;
      }
      
      var index = _.sortedIndex(list, {y:dragPosition.y}, sortMethod) - 1;//See where we would be inserted
      return {
        list: list,
        index: list[index].index,
        folder: list[index].folder,
        dragY: dragPosition.y
      };
    };

    //Update model to reflect new dragState
    dragdrop.commitDragState = function(dragState){
      var self = this;
      UndoRedo.oneTransaction(function(){
        var draggedModel = self.draggedView.model;

        //Update ordering
        self.expressions.model.moveItemsTo(self.grabIndex, dragState.index, self.draggedViewCount);

        //Update folder membership
        var newFolder = dragState.folder;
        var oldFolder = draggedModel.folder;
        if(newFolder !== oldFolder){
          if(oldFolder) oldFolder.removeItem(draggedModel);
          if(newFolder) newFolder.addItem(draggedModel);
        }

        //Restore folder collapsed state
        if(draggedModel.isFolder){
          draggedModel.setProperty('collapsed', self.dropCollapsed); //Restore collapsed state
        }
      });
    };

    //Display preview of dragState, but don't commit changes
    dragdrop.previewDragState = function(dragState){
      var self = this;

      //Preview height and folder membership of dragged item
      this.draggedView.$().css("transform", Browser.translateRule(0, dragState.dragY - this.grabY));
      this.draggedView.$().toggleClass('overFolder', !!dragState.folder);

      //Update transforms for items above and below dragged view
      _.each(dragState.list, function(item){
        if(item.elements){
          var offset = item.offset + (item.index > dragState.index ? self.draggedViewHeight : 0);
          item.elements.css('transform', Browser.translateRule(0, offset));
        }
      });
    };
  });

  return DragDropExpressions;
});

define('expressions/dragdrop_columns',['require','jquery','underscore','lib/browser','pjs','./dragdrop'],function(require){
  var $ = require('jquery');
  var _ = require('underscore');
  var Browser = require('lib/browser');
  var P = require('pjs');
  var DragDrop = require('./dragdrop');

  var DragDropColumns = P(DragDrop, function(dragdrop, _super){

    dragdrop.toggleStyling = function(isDragging){
      this.draggedCells.toggleClass('dragging', isDragging);
      if(!isDragging){
        $('.expressiontable .cell').css('transform', 'none');
      }
    };
    
    dragdrop.onDragStart = function (evt, view) {
      this.draggedView = view;
      this.draggedCells = $();
      this.tableView = view.tableView;

      // deselect cell when dragging
      this.tableView.model.setProperty('selectedCell', null);

      //select tableView
      view.tableView.model.setProperty('selected', true);

      this.draggedViewWidth = view.$().outerWidth() - 1; //because of the negative 1 margin

      var firstColumn = this.tableView.$('.column:first-child');
      var lastColumn = this.tableView.$('.column:last-child');
      this.minDragX = firstColumn.offset().left + firstColumn.outerWidth();
      this.maxDragX = lastColumn.offset().left - this.draggedViewWidth;
      
      this.grabOffset = view.$().offset().left - evt.touches[0].x;
      this.grabX = this.computeDragPosition(evt.touches[0].x, evt.touches[0].y).x;
      this.grabIndex = view.model.index;
    };
    
    dragdrop.onDragStop = function (evt) {
    };

    dragdrop.buildDragList = function(){
      var self = this;
      var columnViews = this.tableView.columnViews.slice(1); //remove first one, it's not allowed to move
          columnViews.pop(); // remove the last one (it's always empty)
          
      var scrollLeft = 0;
      
      var list = [{
        x: -Infinity,
        index: 1
      }];

      var lastItem = [{
        x: Infinity,
        index: 1
      }];

      columnViews.forEach(function(views){
        var view = views[0];
        var cells = $(views.map(function (view) {return view.$()[0]}));
        
        if(view === self.draggedView) {
          self.draggedCells = cells;
          return;
        }
        
        var column = view.model;
        
        //Figure out which expressions are included in this drag item
        var belowGrabbedView = (column.index > self.grabIndex);
        
        //Compute dimensions of the expression(s), removing draggedView from list
        var offset = (belowGrabbedView ? -self.draggedViewWidth : 0);
        var width = view.$().outerWidth();
        var left = view.$().offset().left + scrollLeft + offset;

        //Compute indexes for before and after the expression(s)
        var indexOffset = (belowGrabbedView ? -1 : 0); //-self.draggedViewCount : 0);
        var indexBefore = column.index + indexOffset;
        var indexAfter = indexBefore + 1;

        //Record what happens when dragging past the top of the expression
        list.push({
          x: left,
          index: indexBefore
        });

        //Record what happens when dragging past the midpoint of the expression
        list.push({
          x: left + width/2,
          index: indexAfter,
          offset: offset,
          views: cells
        });

        //Record what happens when dragging past the end of items
        //Only appended to list if this was the last item
        lastItem = {
          x: left + width,
          index: indexAfter
        };

      });
      list.push(lastItem);
      
      return list;
    };

    dragdrop.computeDragPosition = function(x, y){
      //Add offset for where element was grabbed
      x += this.grabOffset;

      //Clamp effective mouse position to edges of table
      x = Math.max(this.minDragX, Math.min(this.maxDragX, x));
      
      
      return {x:x, y:NaN};
    };

    dragdrop.computeDragState = function(list, dragPosition){
      function sortMethod (item) {
        return item.x;
      }
      
      var index = _.sortedIndex(list, {x:dragPosition.x}, sortMethod) - 1;//See where we would be inserted
      return {
        list: list,
        index: list[index].index,
        dragX: dragPosition.x
      };
    };

    //Update model to reflect new dragState
    dragdrop.commitDragState = function(dragState){
      var table = this.tableView.model;
      table.moveColumn(this.grabIndex, dragState.index);
    };

    //Display preview of dragState, but don't commit changes
    dragdrop.previewDragState = function(dragState){
      var self = this;

      //Preview height and folder membership of dragged item
      this.draggedCells.css("transform", Browser.translateRule(dragState.dragX - this.grabX, 0));

      //Update transforms for items above and below dragged view
      _.each(dragState.list, function(item){
        if(item.views){
          var offset = item.offset + (item.index > dragState.index ? self.draggedViewWidth : 0);
          item.views.css('transform', Browser.translateRule(offset, 0));
        }
      });
    };
  });

  return DragDropColumns;
});
define('loadcss!css/add_expression', function(){});
define('main/popover_view',['require','jquery','pjs','lib/underscore_view'],function(require){
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  
  var allPopovers = [];
  
  function handleIsVisibleChange (changedPopover) {
     // hide all other popovers when this one becomes visible
    if (changedPopover.isVisible) {
      allPopovers.forEach(function (popover) {
        if (popover !== changedPopover) {
          popover.closePopover();
        }
      });
        
      $(document).on('tapstart.popover-' + changedPopover.popoverNumber, function (evt) {
        changedPopover.setProperty('isVisible', !changedPopover.eventShouldClosePopover(evt));
      });
    } else {
      $(document).off('tapstart.popover-' + changedPopover.popoverNumber);
    }
  }
  
  var PopoverView = P(UnderscoreView, function(view, _super){
        
    view.init = function () {
      _super.init.call(this);
      this.isVisible = false;
      
      allPopovers.push(this);
      
      this.popoverNumber = allPopovers.length;
      
      this.observe('isVisible', function () {
        handleIsVisibleChange(this);
        this.renderIsVisible();
      }.bind(this));
    };
    
    view.setupOpenButton = function (openButton, on) {
      this.openButton = openButton;
      this.openButton.on(on, this.onBtnPressed.bind(this));
    };
    
    view.didInsertElement = function () {
      this.renderIsVisible();
    };
  
    view.renderIsVisible = function () {
      this.$().toggle(this.isVisible);
      if (this.openButton) this.openButton.toggleClass('active', this.isVisible);
    };

    // don't do anything if we're inside the popover or if we're inside the openButton
    view.eventShouldClosePopover = function (evt) {
      return !this.eventIsWithinPopover(evt);
    };
    
    view.eventIsWithinPopover = function (evt) {
      var $target = $(evt.target);
      return $target.closest(this.$()).length || $target.closest(this.openButton).length;
    };
    
    view.onBtnPressed = function (evt) {
      var $target = $(evt.target);
      
      // this is a popover whose built inside of the button. act like we didn't
      // press the button
      if ($target.closest('[popover]').length) {
        return;
      }
      
      // pressed the open/close button
      if ($target.closest(this.openButton).length) {
        this.togglePopover();
        return;
      }
    };
    
    view.togglePopover = function () {
      this.setProperty('isVisible', !this.isVisible);
    };

    view.closePopover = function () {
      this.setProperty('isVisible', false);
    };


  });
  
  return PopoverView;
});
define('template',['underscore', 'text'], function(_, text){
  var buildMap = {};

  return {
    load: function(name, req, onLoad, config){
      var text_name = "template_src/" + name + ".underscore";
      text.get(req.toUrl(text_name), function(template_source){
        var template = _.template(template_source);
        if(config.isBuild){
          buildMap[name] = template.source;
        }
        onLoad(template);
      });
    },

    write: function(pluginName, moduleName, write){
      if (moduleName in buildMap) {
        var template = (buildMap[moduleName]);
        write(
          "define('" +
            pluginName + '!' + moduleName + "', " +
            "['underscore'], " +
            "function(_) {return " + template + ";}" +
          ");"
        );
      }
      else{

      }
    }
  };
});

define('template!add_expression', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="add-expression-dropdown popover bottom" popover="true">\n <span class="arrow"></span>\n\n ';
 _.each(expression_types, function(type){
;__p+='\n   <div class=\'new-item do-not-blur action-new'+
(type)+
'\' id=\'new-'+
(type)+
'\'>\n      <i class=\'icon-new-'+
(type)+
' expression-icon\'></i>\n      '+
( t(type) )+
'\n    </div>\n ';
})
;__p+='\n\n</div>\n';
}
return __p;
};});
define('expressions/add_expression',['require','loadcss!css/add_expression','pjs','config','main/popover_view','lib/track_feature','template!add_expression','./expression','./table','./text','./folder','lib/browser','undoredo'],function(require){
  require('loadcss!css/add_expression');
  
  var P = require('pjs');
  var Config = require('config');
  var PopoverView = require('main/popover_view');
  var Feature = require('lib/track_feature');
  var template = require('template!add_expression');
  var ExpressionObject = require('./expression');
  var TableObject = require('./table');
  var TextObject = require('./text');
  var FolderObject = require('./folder');
  var Browser = require('lib/browser');
  var UndoRedo = require('undoredo');

  var AddExpressionView = P(PopoverView, function(view, _super){

    view.template = template;
        
    view.init = function (listView) {
      _super.init.call(this);
      
      this.listView = listView;
      this.list = listView.model;
    };

    view.getTemplateParams = function(){
      var params = _super.getTemplateParams();

      var types = ['expression', 'text', 'table'];
      if(Config.get('folders')) types.push('folder');
      params.expression_types = types;
      return params;
    };
    
    view.didInsertElement = function() {
      _super.didInsertElement.call(this);
      
      if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        // prevents mobile safari from getting into a bad
        // state where the next tap on the screen defocuses
        // whatever is selected.
        // see #3106
        this.$().on('tapstart', function (evt) {
          evt.preventDefault();
        });
      }
            
      this.$('.action-newexpression').on('tap', this.newMath.bind(this));
      this.$('.action-newtext').on('tap', this.newText.bind(this));
      this.$('.action-newfolder').on('tap', this.newFolder.bind(this));
      this.$('.action-newtable').on('tap', this.newTable.bind(this));
    };

    view.newMath = function() {
      this.insertItem(ExpressionObject({selected: true, latex: ''}, this.list));
    };

    view.newText = function() {
      this.insertItem(TextObject({selected: true, text: ''}, this.list));
    };

    view.newFolder = function () {
      this.insertItem(FolderObject({selected: true}, this.list));
    };

    view.newTable = function() {
      var properties = {selected: true, latex:''};
      properties.columns = [
        {
          latex:"x",
          values:[1]
        },
        {
          latex:"y",
          values:['']
        }
      ];

      // create a new expression and populate it
      var obj = TableObject(properties, this.list);
      this.insertItem(obj);
      this.listView.getSelectedView().addFocus('cell', 1, 1);

      Feature.use('create table');
    };


    //rules for insertItem (the + button at the top)
    //
    // overarching: 
    //  (1) pressing that button should always have a visible result (i.e. never a no-op)
    //  (2) a folder can never be inserted inside of another folder
    //  (3) if an item's is a blank expression convert instead of creating a new one (unless that violates #1 or #2)
    //      (unless that violates 1 or 2)
    //  (4) insert below current expression where that's possible (below the folder where necessary)
    //  (5) insert at the highest visible point that's not in a folder

    view.insertItem = function(obj){

      var self = this;
      // close the popover
      this.setProperty('isVisible', false);
      
      //collect up some useful globals
      var item = this.listView.getSelected();

      //case 1: current empty expression needs to be replaced and is outside a folder
      //  only applies if:
      //  item.isExpression and item is empty
      //  obj is not an expression

      if (item && item.isExpression && !item.latex && !item.folder && !obj.isExpression) {

        UndoRedo.oneTransaction(function () {
          self.list.insertItemAt(item.index + 1, obj);
          self.list.removeItemAt(item.index);
        });

        this.listView.getSelectedView().addFocus();
        return;
      }

      //case 2: current empty expression needs to be replaced and is inside a folder
      // only applies if:
      // item.isExpression and item is empty
      // obj is not an expression, obj is not a folder

      if (item && item.isExpression && !item.latex && item.folder && !obj.isExpression && !obj.isFolder) {
        UndoRedo.oneTransaction(function () {
          self.list.insertItemAt(item.index + 1, obj);
          item.folder.addItem(obj);
          self.list.removeItemAt(item.index);
        });
        this.listView.getSelectedView().addFocus();
        return;
      }

      //case 3: current is outside of a folder: insert right below where we are, 
      // no funny business
      if (item && !item.folder && !item.isFolder) {
        this.list.insertItemAt(item.index + 1, obj);
        this.listView.getSelectedView().addFocus();
        return;
      }

      //case 4: current item is inside a folder, and we're not inserting a new folder
      // insert right below us, but inside of the folder
      if (item && item.folder && !obj.isFolder) {

        UndoRedo.oneTransaction(function () {
          self.list.insertItemAt(item.index + 1, obj);
          item.folder.addItem(obj);
        });
        this.listView.getSelectedView().addFocus();
        return;
      }

      //case 5: insert into an existing folder
      if (item && item.isFolder && !item.collapsed && !obj.isFolder) {
        UndoRedo.oneTransaction(function () {
          self.list.insertItemAt(item.index + 1, obj);
          item.addItem(obj);
        });
        this.listView.getSelectedView().addFocus();
        return;
      }

      //case 5: we need to seek downward from here and insert when we're ready.
      //this is either because nothing is selected, or because we're a folder
      //inside of a folder. in either case, seek downward until the first chance
      //that we have that's not inside of a folder.

      if (!item) item = this.listView.getFirstVisibleItem();
      // can't insert a folder right after the starting folder 
      //(fixes problem if you try to insert a folder while in a folder)
      if (item.isFolder) item = this.list.getItemByIndex(item.index + 1);
      //after this, we search for the first non-foldered item, and insert right before it.
      while(item && item.folder) {
        item = this.list.getItemByIndex(item.index + 1);
      }

      var index = (item ? item.index : this.list.getItemCount());
      this.list.insertItemAt(index, obj);
      this.listView.getSelectedView().addFocus();
    };

  });
  
  return AddExpressionView;
});

define('template!toast', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="toast-container">\n  <span class="toast">\n    <span class="msg variable-msg"></span>\n    <a class="undo action-undo">'+
( t('undo') )+
'</a>\n  </span>\n</div>';
}
return __p;
};});
//generates a toast (little message near the top of the page)
// lets you do things like switch back into edit-list mode
define('main/toast',['require','jquery','pjs','lib/underscore_view','undoredo','template!toast'],function (require) {
  
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var UndoRedo = require('undoredo');
  var template = require('template!toast');
  
  var ToastView = P(UnderscoreView, function (toast, _super) {
    toast.template = template;
    
    toast.didCreateElement = function () {
      var self = this;
      
      // hide toast when UndoRedo 
      UndoRedo.changesCallbacks.push(function () {
        self.hide();
      });
  
      this.$('.action-undo').on('tap', function () {
        UndoRedo.undo();
        self.hide();
        if (self.callback) {
          self.callback();
        }
      });
      
      // start off hidden
      this.$().toggle(false);
    };
    
    // str: string in the toast message
    // cb: a function that gets called if the "undo" button is pressed
    toast.show = function (str, cb) {
      clearTimeout(this.hideTimeout);
      $('.toast-container').fadeOut('fast');
      this.$().fadeIn('fast');
      
      this.$('.variable-msg').text(str);
      this.callback = cb;

      // hide after 6 seconds
      var self = this;
      this.hideTimeout = setTimeout(function () {
        self.hide();
      }, 6000);
    };
    
    toast.hide = function () {
      clearTimeout(this.hideTimeout);
      
      this.$().fadeOut('fast');
      this.cb = undefined;
    };
  });

  // for now, toast is a singleton class. It's not the best, but it was already a singleton when it was
  // part of UndoRedo and it makes it really easy to get at from other parts of the code. If we feel like
  // it's worth passing a reference to the Toast through all compoenents, then we can do that too...
  var toastView = new ToastView();
  $(function () {
    toastView.appendTo('#sliding-interior');
  });

  return toastView;
});

define('main/resize',['require','lib/browser','jquery'],function(require){
var Browser = require('lib/browser');
var $ = require('jquery');
var triggeredResizeDuringAnimation = false;
var runningAnimations = 0;

function animationIsRunning () {
  return runningAnimations !== 0;
}

// tells the Resize module to not allow resizes until an animation is complete.
// passes back a deferred so that we can take action when animation is over.
// this animation stuff is hopefully a temporary solution and will get replaced
// by an animation system that allows us to start/stop/monitor css animations.
function waitForCSSAnimation (target, propRegExp) {
  var deferred = $.Deferred();

  if (Browser.IS_IE9) {
    // They're not getting a transition, so we aren't getting an end event.
    triggerResize();
    return deferred.resolve();
  }
  // allows us to pass in jquery object, dom node, or string selector
  var $target = $(target);

  var durationString = $target.css('transition-duration');
  if (durationString[durationString.length - 1] !== 's') {
    triggerResize();
    return deferred.resolve();
  }

  var duration = 1000*parseFloat(durationString.slice(0, -1));

  // If the target element isn't in the body yet, we won't get animation events on it.
  if (!$target.closest('body').length) {
    triggerResize();
    return deferred.resolve();
  }

  target = $target[0];
  
  animationStarted();
  triggerResize();
  
  var events = 'transitionend webkitTransitionEnd MSTransitionEnd';
  
  // Can be called directly in case transitionend fails to fire.
  function _onAnimationEnd () {
    clearTimeout(transitionEndTimeout);
    $target.off(events);
    animationEnded();
    deferred.resolve();
  }

  function onAnimationEnd (evt) {
    // must have the exact target
    if (evt) {
      if (evt.target !== target) return;
      if (propRegExp && !evt.originalEvent.propertyName.match(propRegExp)) {
        return;
      }
    }
    
    _onAnimationEnd();
  }

  $target.on(events, onAnimationEnd);
  // Transitions sometimes fail to fire (epecially noticeable in firefox). This might
  // happen if the transition doesn't actually cause a repaint, or maybe sometimes its
  // just a bug. In any case, look out for it and take corrective action.
  var transitionEndTimeout = setTimeout(function () {
    _onAnimationEnd();
  }, duration + 100);
  return deferred;
}

function animationStarted () {
  runningAnimations++;
}

function animationEnded () {
  runningAnimations--;

  if (!animationIsRunning() && triggeredResizeDuringAnimation) {
    triggeredResizeDuringAnimation = false;
    triggerResize();
  }
}

// call all the resize callbacks
function triggerResize () {
  if (animationIsRunning()) {
    triggeredResizeDuringAnimation = true;
    return;
  }
  
  for (var i=0; i<callbacks.length; i++) {
    callbacks[i]();
  }
}

// registers a callback to be called when triggerResize is called
var callbacks = [];
function registerCallback (callback) {
  callbacks.push(callback);
  
  // we're already monitoring, so trigger resize for this callback
  if (monitoring) {
    callback();
  }
}

// stores the current screen size at all times
var currentScreen = {};

// stores the full size for our window (when soft keyboard is hidden)
var fullScreen = {};

var triggerResizeTimeout;

function defocusMobile () {
  var focused = $(document.activeElement);
  // Only want to do this when we have to, since it can cause some bouncing.
  if (focused.filter('input, textarea').length === 0) return;
  // hack to get jquery to remove focus from hidden input.
  // the following steps work for all tested mobile devices.
  //
  // step 1) add an input textbox to body and focus it.
  // step 2) make that textbox disabled and readonly.
  // step 3) blur the textbox and remove from the dom.
  $('<input />').prependTo('body').focus()
  .attr({
    readonly: 'readonly',
    disabled: 'true'
  })
  .blur().remove();
}

function monitorWindowSize () {
  
  if (Browser.IS_MOBILE) {
    // handle some mobile specific code
    var focused = $(document.activeElement);
    if (focused.filter('input,textarea').length === 0) {
      $(window).scrollTop(0).scrollLeft(0);
    }
  
    if (focused.filter('input:hidden, textarea:hidden').length) {
      defocusMobile();
    }
  } else {
    // desktop specific code
    $(window).scrollTop(0).scrollLeft(0);
  }
    
  // check if anything actually updated
  var w = window.innerWidth + $(window).scrollLeft();
  var h = window.innerHeight + $(window).scrollTop();
  if (w !== currentScreen.width || h !== currentScreen.height) {
    currentScreen.width = w;
    currentScreen.height = h;
    
    // update full size if we're supposed to refresh it or if it hasn't been
    // set yet.
    if (!stickyFullScreen || !fullScreen.width || !fullScreen.height) {
      fullScreen.width = w;
      fullScreen.height = h;
    }
    
    if (monitoring) {
      
      // update immediately on mobile browsers. more responsive and the resize
      // event on mobile browsers is usually a discrete one-time action.
      if (Browser.IS_MOBILE) {
        triggerResize();
      }
      
      // throttle how quickly we triggerResize for desktop. We can have many
      // updates in a row and only want to triggerResize for the last one.
      else {
        clearTimeout(triggerResizeTimeout);
        triggerResizeTimeout = setTimeout(triggerResize, 100);
      }
    }
  }
}

// if stickyFullScreen, we keep the original size of the page inside of the
// 'fullScreen' property
var stickyFullScreen = false;
function init (options) {
  stickyFullScreen = options && options.stickyFullScreen;
  
  // check the initial size
  monitorWindowSize();
  
  // We call the monitorWindowSize() function every 100ms because the
  // window::onResize event just isn't reliable enough. In some browsers
  // (e.g. mobile safari) the event randomly gets dropped.
  setInterval(monitorWindowSize, 100);
  
  // We also call the monitorWindowSize() function on window resize in order
  // to be a little more responsive in most cases
  $(window).resize(function () {
    monitorWindowSize();
  });
}

var monitoring = false;
function monitor () {
  monitoring = true;
  triggerResize();
}
return {
  trigger: triggerResize,
  register: registerCallback,
  fullScreen: fullScreen,
  currentScreen: currentScreen,
  init: init,
  monitor: monitor,
  defocusMobile: defocusMobile,
  animationIsRunning: animationIsRunning,
  animationStarted: animationStarted,
  animationEnded: animationEnded,
  waitForCSSAnimation: waitForCSSAnimation
};

});

define('lib/keys',['require'],function (require) {

  var Keys = function () {

    // based on http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
    var table = {
      8:  this.BACKSPACE = 'Backspace',
      9:  this.TAB = 'Tab',
      13: this.ENTER = 'Enter',
      16: this.SHIFT = 'Shift',
      17: this.CONTROL = 'Control',
      18: this.ALT = 'Alt',
      20: this.CAPSLOCK = 'CapsLock',
      27: this.ESCAPE = 'Esc',
      32: this.SPACEBAR = 'Space',
      33: this.PAGEUP = 'PageUp',
      34: this.PAGEDOWN = 'PageDown',
      35: this.END = 'End',
      36: this.HOME = 'Home',
      37: this.LEFT = 'Left',
      38: this.UP = 'Up',
      39: this.RIGHT = 'Right',
      40: this.DOWN = 'Down',
      46: this.DELETE = 'Del'
    };
  
    this.lookup = function (evt) {
      return table[evt.which];
    };
  };
  
  return new Keys();
});
/* global jQuery */
;(function($) {

  $.fn.extend({

    scrollVisible: function (elms, topOffset, bottomOffset) {
  
      if (elms && elms.length) {
  
        topOffset = topOffset || 0;
        bottomOffset = bottomOffset || 0;
  
        var view_top = this.offset().top + topOffset;
        var view_height = this.outerHeight() + bottomOffset - topOffset;
      
        //set the first top and bottom
        var elms_top = $(elms[0]).offset().top;
        var elms_bottom = $(elms).outerHeight() + elms_top;
  
        //loop through all other elements to find combined top/bottom
        elms.each( function () {
          var elm = $(this);
          var top = elm.offset().top;
          var bottom = elm.outerHeight() + top;
  
          if( top < elms_top) elms_top = top;
          if( bottom > elms_bottom ) elms_bottom = bottom;
        });
  
        var value = -this.scrollTop();
  
        //adjust for the offset of "this"
        elms_top -= view_top + value;
        elms_bottom -= view_top + value;
  
        var min = -elms_top;
        var max = view_height - elms_bottom;
  
        if (value > max && value < min)	{
          //do nothing
        } else if (elms_bottom - elms_top > view_height) {
          // do nothing
          // the content is larger than the viewport and we'll just get in the
          // way of the browser. The browser will put the correct part of the
          // content in view based on which part of the content has focus.
        } else if (value > max) {
          this.scrollTop(-max);
        } else if (value < min) {
          this.scrollTop(-min);
        }
      }
  
      return this;
    }
  });

})(jQuery);


define("lib/jquery.scrollvisible", function(){});

define('loadcss!css/new_expression', function(){});
define('template!new_expression', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="expressionitem new-expression opened">\n  <div class=\'new-math-div do-not-blur action-newmath\'>\n    <div class=\'new-expression-fade\'></div>\n  </div>\n\n  <span\n     class="tab"\n  >\n     <span class=\'num variable-index\'>2</span>\n     <div class=\'tab-interior\'></div>\n  </span>\n\n</div>\n';
}
return __p;
};});
define('expressions/new_expression',['require','loadcss!css/new_expression','pjs','lib/underscore_view','template!new_expression','./expression'],function(require){
  require('loadcss!css/new_expression');
  
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var template = require('template!new_expression');
  var ExpressionObject = require('./expression');
  
  var NewExpressionView = P(UnderscoreView, function(view, _super){

    view.template = template;
        
    view.init = function (listView) {
      _super.init.call(this);
      this.observe('index', this.updateIndex.bind(this));
      this.listView = listView;
    };
    
    view.didInsertElement = function() {
      // update the index now and observe any changes
      this.updateIndex();
      
      this.$('.action-newmath').on('tap', this.newMath.bind(this));
    };

    view.updateIndex = function () {
      this.$('.variable-index').text(this.index);
    };

    view.newMath = function() {
      var constructor = ExpressionObject;
      var properties = {selected:true, latex:''};
      var obj = constructor(properties, this.listView.model);
      this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
      this.listView.getSelectedView().addFocus();
    };

  });

  return NewExpressionView;
});

/*
 * Renders expression items visible in the viewport by setting their "renderShell" property to false.
 * On desktop, also renders off-screen expression in the background if all viewport expressions are shown.
 *
 * NOTE: ideally this shouldn't poll, but listen to events on the expression list to know when items have
 *       been added/deleted, or the viewport has changed.
 */
define('expressions/renderviewport',['require','jquery','main/timermodules','lib/browser'],function(require){
var $ = require('jquery');
var TimerModules = require('main/timermodules');
var Browser = require('lib/browser');

TimerModules.add('expressions.renderviewport', (function(expressions, grapher) {
  var $exppanel   = null;
  var expPanelTop = null;

  var lastScrollStableTime = 0;
  var lastScrollHeight     = 0;
  var lastScrollTop        = 0;

  function getUnrenderedViewportItems() {
    $exppanel = $('#exppanel');
    if (!$exppanel.length) {
      $exppanel = null;
      return [];
    }
    expPanelTop = $exppanel.offset().top;

    var unrenderedViewportItems = [];

    // Wait for scroll bar to settle down for 300ms
    var scrollTop    = $exppanel.scrollTop(),
        scrollHeight = $exppanel.height();
    if (scrollTop == lastScrollTop && scrollHeight == lastScrollHeight) {
      var time = new Date().getTime();
      if (lastScrollStableTime === 0) {
        lastScrollStableTime = time;
      } else if (time - lastScrollStableTime > 300) {
        var first = expressions.expressionAtPoint(5, expPanelTop),
            last  = expressions.expressionAbovePoint(5, expPanelTop + scrollHeight);
        if (first && last) {
          expressions.getItemsByIndexRange(first.index, last.index).forEach(function(item) {
            if (item.renderShell) {
              unrenderedViewportItems.push(item);
            }
          });
        }
      }
    } else {
      lastScrollTop        = scrollTop;
      lastScrollHeight     = scrollHeight;
      lastScrollStableTime = 0;
    }

    return unrenderedViewportItems;
  }

  function renderItems(unrenderedViewportItems) {
    var i;
    
    if (unrenderedViewportItems.length) {
      // If viewport items need to be rendered, then render them all
      // (with a 10ms pause in-between to help them display in view order)
      i=0;
      unrenderedViewportItems.forEach(function(item) {
        (function(item) {
          setTimeout(function() {
            item.setProperty('renderShell', false);
          }, i * 10);
        })(item, i++);
      });
    } else {
      // Otherwise, if not mobile, just render first unrendered item (as long as we're not slowly redrawing.)
      //
      // We can't do this on mobile as iPad 3 doesn't correctly update any expressions rendered off-screen
      // (it renders white boxes instead.)
      if (!Browser.IS_MOBILE && !grapher.redraw_slowly_timeout) {
        var len = expressions.model.getItemCount();
        for (i=0; i < len; ++i) {
          var item = expressions.model.getItemByIndex(i);
          if (item.renderShell) {
            item.setProperty('renderShell', false);
            break;
          }
        }
      }
    }
  }

  return function() {
    renderItems(getUnrenderedViewportItems());
  };
}));
});

define('expressions/list_view',['require','jquery','underscore','pjs','config','tipsy','lib/underscore_view','lib/touchtracking','expressions/dragdrop_expressions','expressions/dragdrop_columns','./add_expression','main/toast','undoredo','main/resize','lib/keys','lib/browser','lib/jquery.scrollvisible','./new_expression','./renderviewport','./expression'],function (require) {
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var Config = require('config');
  require('tipsy');
  var UnderscoreView = require('lib/underscore_view');
  var touchtracking = require('lib/touchtracking');
  var DragDropExpressions = require('expressions/dragdrop_expressions');
  var DragDropColumns = require('expressions/dragdrop_columns');
  var AddExpressionView = require('./add_expression');
  var Toast = require('main/toast');

  var UndoRedo = require('undoredo');
  var Resize = require('main/resize');
  var Keys = require('lib/keys');
  var Browser = require('lib/browser');

  require('lib/jquery.scrollvisible');
  var NewExpressionView = require('./new_expression');
  require('./renderviewport');
  var ExpressionObject = require('./expression');
  
  var ExpressionListView = P(UnderscoreView, function (view, _super) {
    view.__itemViews = {};
    view.__latexChangeCallbacks = [];
    view.keypadView = null;
    view.isTransient = false;
    view.transientChildren = [];

    view.isTablet = Config.get('tablet');

    // Overridden by Calc.
    // TODO: copied and pasted over from list_view_tablet, but this feels really dirty
    // There's got to be a better way to do this.
    view.triggerClearGraph = function () {};

    view.getTemplateParams = function (){
      return  {
        IS_TABLET: this.isTablet
      };
    };
    
    view.getAllSliders = function () {
      var sliders = [];
      
      for (var key in this.__itemViews) {
        if (this.__itemViews[key].hasOwnProperty('sliderView') &&
          this.__itemViews[key].sliderView
        ) {
          sliders.push(this.__itemViews[key].sliderView.slider);
        }
      }
      
      return sliders;
    };

    view.toggleAllSliders = function () {
      var sliders = this.getAllSliders();
      
      // check if any slider is playing. if so, stop all sliders
      for (var i=0; i<sliders.length; i++) {
        if (sliders[i].isPlaying) {
          this.stopAllSliders();
          return;
        }
      }
      
      // none are playing, so start them
      this.playAllSliders();
    };

    view.playAllSliders = function () {
      var sliders = this.getAllSliders();
      
      UndoRedo.oneTransaction(function () {
        for (var i=0; i<sliders.length; i++) {
          sliders[i].setProperty('isPlaying', true);
        }
      }.bind(this));
    };

    view.stopAllSliders = function () {
      var sliders = this.getAllSliders();
      
      UndoRedo.oneTransaction(function () {
        for (var i=0; i<sliders.length; i++) {
          sliders[i].setProperty('isPlaying', false);
        }
      }.bind(this));
    };

    view.onStartMovingPoint = function (id) {
      var movedExpr = this.model.getItemById(id);
      var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
      if (!moveIds) return;
      for (var i = 0; i < moveIds.length; i++) {
        if (moveIds[i] === undefined) continue;
        this.getItemView(moveIds[i]).sliderView.setProperty(
          'isMoving',
          true
        );
        this.getItemView(moveIds[i]).sliderView.slider.setProperty('isPlaying', false);
      }
    };

    view.onStopMovingPoint = function (id) {
      var movedExpr = this.model.getItemById(id);
      var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
      if (!moveIds) return;
      for (var i = 0; i < moveIds.length; i++) {
        if (moveIds[i] === undefined) continue;
        this.getItemView(moveIds[i]).sliderView.setProperty(
          'isMoving',
          false
        );
      }
    };

    view.onMovePoint = function (id, values) {
      var movedExpr = this.model.getItemById(id);
      var moveIds = movedExpr.formula && movedExpr.formula.move_ids;
      if (!moveIds) return;

      var expr, val;
      for (var i = 0; i < values.length; i++) {
        if (moveIds[i] === undefined) continue;
        expr = this.model.getItemById(moveIds[i]);
        if (expr && expr.slider) {
          val = expr.slider.computeSnappedValue(values[i]);
          expr.slider.setProperty('value', val);
        }
      }
      this.setSelected(null);
    };

    view.onLatexChange = function (latex) {
      _.each(this.__latexChangeCallbacks, function (cb) { cb(latex); });
    };

    view.init = function (model) {
      _super.init.call(this);
      this.model = model;
      this.model.triggerItemInserted = this.onItemInserted.bind(this);
      this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
      this.model.triggerItemMoved = this.onItemMoved.bind(this);
      this.model.triggerSetState = this.onSetState.bind(this);
      
      // an optimization so that we don't compare entire items when changing
      // selectedItem property.
      this.setPropertyComparator('selectedItem', function (a,b) {
        return a === b;
      });
      
      this.observe('itemFocused', this.renderItemFocused.bind(this));
      this.observe('editListMode', this.renderEditListMode.bind(this));

      // ensure selected expression is visible on selection change and focused
      // expression is visible on keypress
      this.observe('selectedItem', this.selectedItemChanged.bind(this));
      $(document).on('keypress', '#exppanel', this.ensureActiveChildIsVisible.bind(this));

      this.dragdrop_expressions = DragDropExpressions(this);
      this.dragdrop_columns = DragDropColumns(this);
    };

    view.computeTransient = function(){
      this.setProperty('transient', this.transientChildren.length > 0);
    };

    //when sliding a slider, we want to temporarily pad the bottom enough that things don't move around
    view.padLastExpression = function(padding) {
      var $lastExp = this.$('.expressionitem.new-expression');
      $lastExp.removeClass('animating').css('margin-bottom', + padding + 'px');
    };

    view.unpadLastExpression = function() {
      var $lastExp = this.$('.expressionitem.new-expression');
      $lastExp.addClass('animating').css('margin-bottom', '0');
    };

    view.padLastExpressionUntilTapEnd = function(padding){
      var self = this;
      this.padLastExpression(padding);
      $(document).on('tap.animating-bottom', function() {
        if ($('.exp-options-menu').length === 0) {
          self.unpadLastExpression();
          $(document).off('tap.animating-bottom');
        }
      });
    };
    
    view.updateWidth = function () {
      var exppanel = this.$('#exppanel');
      var maxWidth = 0;
      var minWidth = parseInt(exppanel.css('min-width'), 10);
     
      this.$('.disable-horizontal-scroll-to-cursor').scrollLeft(0);
      
      function includeWidth ($element) {
        var main = $element.find('.main');
        if (!main.length) return;

        var width = main.outerWidth() + main.offset().left + 5;
        if (width > maxWidth) maxWidth = width;
      }
      var selected = this.getSelectedView();
      if (selected && (this.itemFocused || selected.model.isTable)) {
        includeWidth(selected.$());
      }
      
      if (this.editListMode) {
         this.$('.expressiontable').each(function () {
           includeWidth($(this));
         });
      }

      if (maxWidth < minWidth) {
        maxWidth = minWidth;
      }

      var collapse_slowly = parseInt(exppanel.css('max-width'), 10) > maxWidth;
      if (collapse_slowly) {
        exppanel.addClass('collapse-slowly');
        setTimeout(function () {
          exppanel.removeClass('collapse-slowly');
        }, 0.5);
      } else {
        exppanel.removeClass('collapse-slowly');
      }
      
      exppanel.css('max-width', maxWidth);
    };
    

    view.onItemInserted = function (index, item) {
      //update index for newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }
      
      // if we've started adding items to dom, add this item. Otherwise,
      // the view will be created when the ExpressionListView is inserted
      // into the dom
      if (this.$items) {
        var view = this.createItemView(item);
        if (view) {
          if (index === 0) {
            view.prependTo(this.$items); // beginning
          } else if (index === this.model.getItemCount()-1) {
            view.appendTo(this.$items); //end
          } else { //somewhere in the middle
            view.insertAfter(this.$items.children(':nth-child('+ index +')'));
          }

          //in edit list mode, we animate new items
          if (this.editListMode) {
            view.$().css({
              transform: 'scale(0,0)',
              opacity: 0
            });

            //wait one frame, or the 0,0 won't catch
            setTimeout(function() {
              view.$().css({
                transition: '.2s',
                opacity: 1,
                transform: 'scale(1,1)'
              });
            }, 1);
            //remove our transition after the animation's done
            setTimeout(function () {
              view.$().css({
                transition: 'none'
              });
            }, 300);
          }
        }


        // observe selected
        item.observe('selected.listview', this.observeItemSelected.bind(this));
        if (item.selected) {
          this.observeItemSelected('selected', item);
        }
        
        var len = this.model.getItemCount();
        for (var i=index; i<len; i++) {
          this.model.getItemByIndex(i).setProperty('index', i);
        }
        
        this.updateWidth();
      }
    };
    
    view.onItemRemoved = function (index, item) {
      var item_id = String(item.id);
      
      if (this.selectedItem === item) {
        this.setProperty('selectedItem', null);
      }
      
      item.unobserve('.listview');
            
      // update index on newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }
      
      // remove item view from dom
      var view = this.__itemViews[item_id];
      if (view) {
        view.remove();
        delete this.__itemViews[item_id];
        
        var len = this.model.getItemCount();
        for (var i=index; i<len; i++) {
          this.model.getItemByIndex(i).setProperty('index', i);
        }
      }
      
      this.updateWidth();
    };
    
    view.onItemMoved = function (from, to) {
      // update index of each affected item
      var min_affected = Math.min(from,to);
      var max_affected = Math.max(from,to);
      for (var i = min_affected; i <= max_affected; i++) {
        this.model.getItemByIndex(i).setProperty('index', i);
      }
        
      // move view to correct spot
      var view = this.getItemView(this.model.getItemByIndex(to).id);
      if (view) {
        var $items = this.$items;
        // put at beginning
        if (to === 0) {
          $items.prepend(view.$());
        }
          
        // put at end
        else if (to === this.model.getItemCount() - 1) {
          $items.append(view.$());
        }
          
        // put somewhere in middle
        else {
          
          // must add 1 to index if to > from. This is because the from spot will
          // get plucked out and inserted after the to spot. Means we need to
          // search one deeper into sibling list to find the correct node to
          // insert after.
          var child_index = to + ( to > from ? 1 : 0);
          view.$().insertAfter($items.children(':nth-child('+ child_index +')'));
        }
      }
    };
    
    view.onSetState = function (list) {
      // destroy item views
      //TODO - could do a destruct() and remove all at once from dom for optimization.
      for (var id in this.__itemViews) {
        if (this.__itemViews.hasOwnProperty(id)) this.__itemViews[id].remove();
      }
      
      this.__itemViews = {};
      this.selectedItem = null;
      
      // update index on newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }
          
      // make all the views at once and insert one large structure
      this.createAllItemViews();
    };
    
    view.renderItemFocused = function () {
      $('body').toggleClass('ITEM-FOCUSED', !!this.itemFocused);
    };
    
    // MUST OVERRIDE
    view.instantiateItemView = function (item) {};

    view.createItemView = function (item) {
      var view = this.instantiateItemView(item);
      var item_id = String(item.id);
      
      if (view) {
        this.__itemViews[item_id] = view;
        
        // add some triggers to the view
        var self = this;
        view.triggerDelete = function(){self.onDelete(view)};
        view.triggerEnterPressed = function(){self.onEnterPressed(view)};
        view.triggerUpPressed = function(){self.onUpPressed(view)};
        view.triggerDownPressed = function(){self.onDownPressed(view)};
        view.triggerBackspacePressed = function(){self.onBackspacePressed(view)};
        view.triggerDelPressed = function(){self.onDelPressed(view)};
        view.observe('transient', function(prop, view){
          if(view.transient) {
            self.transientChildren.push(view);
          } else {
            self.transientChildren = _(self.transientChildren).without(view);
          }
          self.computeTransient();
        });
      }
      
      return view;
    };
    view.createAllItemViews = function () {
      
      // only do this if we've been added to the dom
      if (!this.$items) return;
      
      var len = this.model.getItemCount();
      for (var i=0; i<len; i++) {
        var item = this.model.getItemByIndex(i);
        var view = this.createItemView(item);
        if (view) {
          view.appendTo(this.$items);
          //TODO - generate only the html

          item.setProperty('index', i);
          
          // observe selected
          item.observe('selected.listview', this.observeItemSelected.bind(this));
          if (item.selected) {
            this.observeItemSelected('selected', item);
          }
        }
      }
      
      //TODO - insert large structure at once
      
      //TODO - assign the nodes for each view based on the structure
      
      //Focus if something is selected
      var selected = this.getSelectedView();
      if(selected) {selected.addFocus();}
      
      this.updateWidth();
    };
    
    // holds a copy of the each item's view for later reference

    view.getItemView = function (id) {
      return this.__itemViews[String(id)];
    };
    
    view.onDelete = function (view) {
      var self = this;
      var animationDuration = 0.2;
      view.$().css({
        'transition': animationDuration + 's',
        'opacity': '0',
        'transform': "scale(.1, .1)"
      });
      setTimeout(function() {
        UndoRedo.oneTransaction(function(){
          self.model.removeItemAt(view.model.index);
          if (self.model.getItemCount() === 0) {
            var new_exp = ExpressionObject(undefined, self.model);
            self.model.insertItemAt(0, new_exp);
          }
        });
      }, 1000*animationDuration);
    };

    view.onUpPressed = function (view) {
      // nothing above
      if (view.model.index === 0) return;
      
      this.selectPrevExpression(view.model);
      this.getSelectedView().addFocus('end');
    };

    view.onDownPressed = function (view) {
      this.selectNextExpression(view.model);
      this.getSelectedView().addFocus('start');
    };
    
    view.onBackspacePressed = function (view) {
      var wasText = view.model.isText;

      //if you press backspace from the last element of a folder, it
      //delete -- it removes you from the folder
      var nextItem = this.getItemByIndex(view.model.index + 1);
      if (view.model.folder && (!nextItem || !nextItem.folder)) {
        view.model.folder.removeItem(view.model);
        return;
      }

      this.upwardDeleteExpression(view.model);

      // having issues in iframe on ipad. backspace deletes the textbox
      // but doesn't focus into the expression above
      // see #3106
      if (wasText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        this.setSelected(null);
        return;
      }

      this.getSelectedView().addFocus('end');
    };
    
    view.onDelPressed = function (view) {
      this.downwardDeleteExpression(view.model);
      this.getSelectedView().addFocus('start');
    };

    view.onEnterPressed = function (view) {
      
      // having issues in iframe on ipad. make enter work like escape
      // see #3106
      if (view.model.isText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        $(document.activeElement).blur();
        this.setSelected(null);
        return;
      }
      

      var obj = ExpressionObject({ selected:true }, this.model);
      var self = this;
      UndoRedo.oneTransaction(function() {
        self.model.insertItemAt(view.model.index + 1, obj);
        if (view.model.isFolder && !view.model.collapsed) {
          view.model.addItem(obj);
        }
        if (view.model.folder) view.model.folder.addItem(obj);
      });
      this.getSelectedView().addFocus();
    };
    
    view.expressionsVisible = true;
    view.hideExpressions = function() {
      // deselect expression
      this.setSelected(null);

      $('#show-expressions-tab').show();

      this.setProperty('expressionsVisible', false);
      //remove the tab and transform the whole thing off the screen
      $('#hide-expressions-tab').hide();
      $(document.activeElement).blur();
      $('body').addClass('fullscreen');
      $('body').addClass('shift-grapher');
      
      // make the grapher bigger now so that it can slide to the left
      Resize.trigger();
    };

    view.showExpressions = function() {
      this.setProperty('expressionsVisible', true);
      $(document.activeElement).blur();
      $('#show-expressions-tab').hide();
      $('body').removeClass('fullscreen');
      
      // keep the grapher bigger until it slides all the way to the right. Then it can shrink
      setTimeout(function () {
        $('body').removeClass('shift-grapher');
        Resize.trigger();
      }, 500);
    };
    
    view.renderEditListMode = function () {
      var $editListBtn = this.$('.edit-list-btn');
      var $body = $('body');
      var self = this;
      
      if (this.editListMode) {
        $editListBtn.addClass('btn-primary');
        $editListBtn.text('done');
        $editListBtn.removeClass('tooltip');
        
        $body.addClass('EDIT-LIST-MODE');
        
        this.setSelected(null);
        this.stopAllSliders();
        
        // listen for a tapstart event to close edit-list-mode
        $(document).on('tapstart.edit-list-mode', function (evt) {
          if (
            $(evt.target).closest('#exppanel').length === 0 &&
            $(evt.target).closest('.options-menu').length === 0 &&
            $(evt.target).closest('#expression-top-bar').length === 0
          ) {
            self.setProperty('editListMode', false);
          }
        });
        
      } else {
        $editListBtn.removeClass('btn-primary');
        $editListBtn.addClass('tooltip');
        $editListBtn.html('<i class="icon-settings" />');
        
        $body.removeClass('EDIT-LIST-MODE');
        
        // don't listen for the event to close edit-list-mode anymore
        $(document).off('.edit-list-mode');
      }
    };

    /*
    * EVENTS
    */
    view.onFocusIn = function (evt) {

      //it's possible to add focus to an expression even when the expressions are hidden.
      // Most prominently: if you click a curve to select it and then type
      // If that happens, we want to show the expression that's being edited, so pop back out the expressions list
      if (!this.expressionsVisible) {
        this.showExpressions();
      }

      var target = $(evt.target);
      var inMathquill = target.closest('.mathquill-rendered-math').length !== 0;
      var inEditableMathquill = target.closest('.mathquill-editable').length !== 0;
      var inText = target.closest('.expressiontext').length !== 0;
        
      if (inMathquill || inEditableMathquill || inText) {
        // in case we're in list mode, get out of it!
        this.setProperty('editListMode', false);
        this.setProperty('itemFocused', true);
      } else {
        this.setProperty('itemFocused', false);
      }

      this.setProperty('needFakeKeypad', inMathquill || inEditableMathquill);
      // editDisabled happens when you're in the dependent column of a table,
      // and you want the keypad arrows to move around, but there's nothing
      // useful that you can type.
      this.setProperty('editDisabled', inMathquill && !inEditableMathquill);

      clearTimeout(this.fakeKeypadTimeout);
    };
    
    view.onFocusOut = function () {
      clearTimeout(this.fakeKeypadTimeout);
      // setTimeout here is used to coalesce calls to onFocusOut and onFocusIn
      // that happen in the same tick. This happens, e.g. when a new
      // expression is created, and we move focus from the previous expression
      // to it.
      this.fakeKeypadTimeout = setTimeout(function () {

        // Mathquill does something weird where it triggers a focusout on
        // render, but nothing actually happens to focus. To combat that, and
        // anything else similar, we check if we still have a focused
        // expression. If so, just ignore this event.
        var selected = this.getSelectedView();
        if (selected && selected.isFocused()) return;

        this.setProperty('itemFocused', false);
        this.setProperty('needFakeKeypad', false);
        this.setProperty('editDisabled', false);
      }.bind(this), 0);
    };
    
    view.offset = function () {
      return this.$().offset();
    };

    view.setBottom = function (bottom) {
      var oldBottom = this.$().height() - this.$().offset().top;
      this.$().css('bottom', bottom + 'px');

      //If the user is currently in a mouse interaction and the height
      //is increasing, pad the last expression until they end their interaction to
      //prevent things from moving under them
      if (bottom < oldBottom && touchtracking.isTapActive()){
        this.padLastExpressionUntilTapEnd(oldBottom - bottom);
      }
    };

    view.didInsertElement = function () {
      var self = this;
      _super.didInsertElement.call(this);
      
      this.addExpressionView = AddExpressionView(this);
      this.addExpressionView.appendTo(this.$());
      this.addExpressionView.setupOpenButton(this.$('.action-add-expression'), 'tap');

      this.$items = this.$('.template-expressioneach');
      Resize.trigger();

      //
      //listen for scroll && add class when scrolled
      //
      this.$('#exppanel').scroll(function(evt) {
        $('#expression-top-bar').toggleClass(
          'expressions-scrolled',
          $(evt.target).scrollTop() > 0
        );
      });
      
      //
      // for iPad & nexus, listen for taps in the empty area underneath an expression and defocus
      // because that doesn't happen automatically. The way I'm detecting such a tap is by checking if the
      // event is within an .expressionitem. If it's not, we're assuming the tap is within empty space.
      //
      this.$('#exppanel').on('tapstart', function(evt) {
        // avoids losing focus when on desktop and we mouseDown on the scrollbar. If we want to lose foucs in
        // that case, this line is perfect to remove. If we want something more robust to detect that we're
        // on the scrollbar, we might be able to check x position of the event compared to the width of the
        // inner content.
        if (evt.device === 'mouse') return;
        
        if ($(evt.target).closest('.expressionitem').length === 0) {
          $(document.activeElement).blur();
        }
      });
      
      //the below should happen automatically, but doesn't on iPad / android
      //this lets you defocus the currently focused expression by clicking the 'Expressions' header
      $('#expression-top-bar').on('tapstart', function(evt) {
        if (evt.wasHandled()) return;
        
        self.setSelected(null);
      });


      this.$().on('tap', '.action-clearall', function () {
        self.triggerClearGraph();
        Toast.show("Graph cleared.", function() {
          self.setProperty('editListMode', true);
        });
      });

      this.$().on('tap', '.action-undo', function () {
        UndoRedo.undo();
      });

      this.$().on('tap', '.action-redo', function () {
        UndoRedo.redo();
      });

      this.$().on('focusout', this.onFocusOut.bind(this));
      this.$().on('focusin',  this.onFocusIn.bind(this));
      this.$('.action-toggleeditlistmode').on('tap', function () {
       self.setProperty('editListMode', !self.editListMode);
      });
      this.$('.action-hideexpressions').on('tap', this.hideExpressions.bind(this));
      this.$('.action-showexpressions').on('tap', this.showExpressions.bind(this));
      $(document.documentElement).on('keydown', this.handleKeyDown.bind(this));
      
      this.$().on('tapstart', '.action-hamburger', function () {
        $('body').toggleClass('resources-open');
        Resize.waitForCSSAnimation('#sliding-interior', /transform/);
      });
      
      this.renderItemFocused();
      this.renderEditListMode();
      
      this.newExpressionView = NewExpressionView(this);
      this.newExpressionView.replace(this.$('.template-newexpression'));
      this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
     
      // whenever mathquill renders
      this.$().on('render', function (evt) {
        self.updateWidth();
      });
      
      // these things all factor into how wide the expression list is, so we watch them
      this.observe('editListMode itemFocused selectedItem', function () {
        self.updateWidth();
      });
      
      // any time that focus changes we need to make sure that a part of the page doesn't
      // scroll in order show the cursor. this is specifically important for IE9 and tables.
      // In IE9 there will be a quick flash when the expression list is scrolled back to 0,0
      // but I can't find anything that happens synchronously. I've tried:
      //    1) Listening to changes to selectedCell of the selected table
      //    2) Listening for 'scroll' event on the element that gets scrolled
      //
      // both of those still show a quick flash, so this is the chosen method since it's
      // the simplest and most general.
      this.$().on('focusin', function () {
        setTimeout(function () {
          self.updateWidth();
        }, 0);
      });

      this.createAllItemViews();
    };

    view.selectedItemChanged = function() {
      this.ensureActiveChildIsVisible();
    };

    view.getFirstVisibleItem = function() {
      var top = this.$('#exppanel').offset().top;
      var el = this.expressionAtPoint(0, top);
      
      if (!el) {
        return this.getItemByIndex(0);
      }
      //make sure it's fully visible
      if (this.getItemView(el.id).$().offset().top < top - 2) { //Allow for overlapping borders
        el = this.getItemByIndex(el.index+1);
      }
      return el;
    };

    view.appendBlankExpression = function() {
      this.newExpressionView.newMath();
    };

    // Find the view for the selected expression and scroll that expression
    // into view. If the expression doesn't have a view yet, we'll let the
    // view call this once it's inserted into the dom. If there is no selected
    // view, then check if there's a focused view. If so, scroll that until
    // it's visible
    view.ensureActiveChildIsVisible = function(){
  
      // if an item is selected, try to force it into view
      if (this.selectedItem) {
        var selectedView = this.getItemView(this.selectedItem.id);
        if (selectedView) {
          this.$('#exppanel').scrollVisible(selectedView.$(), 0, -75);
        }
      }
      
      // otherwise, if an item is focused, try to force it into view
      else {
        var $focused = $(document.activeElement);
        var $expression = $focused.closest('.expressionitem');
        if ($expression.length) {
          this.$('#exppanel').scrollVisible($expression, 0, -20);
        }
      }
      
    };
      
    view.handleKeyDown = function(evt) {
      // make sure nothing has focus
      if ($.contains(document.body, document.activeElement)) {
        return;
      }
      
      // make sure event didn't happen from within expression list
      if ($(evt.target).closest('#exppanel').length) {
        return;
      }
      
      // make sure target is still in dom. fixes #3282
      if (!$.contains(document.documentElement, evt.target)) {
        return;
      }
      
      var selected = this.getSelectedView();
      if (selected && selected.isFocused()) {
        selected.processMissedKeyEvent(evt);
        return;
      }
      if (!selected) {
        return;
      }

      var key = Keys.lookup(evt);
      switch (key) {
        case Keys.UP:
          evt.preventDefault();
          this.selectPrevExpression(selected.model);
          break;
          
        case Keys.DOWN:
          evt.preventDefault();
          this.selectNextExpression(selected.model, true);
          break;
        case Keys.ESCAPE:
          evt.preventDefault();
          this.setSelected(null);
          break;
            
        case Keys.RIGHT:
        case Keys.TAB:
          evt.preventDefault();
          if (selected) {
            if (selected.model.isTable) {
              selected.addFocus('cell', 0, 0);
            } else {
              selected.addFocus('start');
            }
          }
          break;
          
        case Keys.LEFT:
          evt.preventDefault();
          if (selected) {
            if (selected.model.isTable) {
              selected.addFocus('cell', 0, selected.model.columns.length - 1);
            } else {
              selected.addFocus('end');
            }
          }
          break;
          
        case Keys.BACKSPACE:
          evt.preventDefault();
          if(selected){
            this.upwardDeleteExpression(selected.model);
          }
          break;
          
        case Keys.DELETE:
          evt.preventDefault();
          if(selected){
            this.downwardDeleteExpression(selected.model);
          }
          break;
          
        case Keys.ENTER:
          evt.preventDefault();
          if (selected) this.onEnterPressed(selected);
          break;
          
        default:
          //ignore things like ctrl-copy, ctrl-paste, alt-tab, shift
          if (evt.metaKey ||
              evt.ctrlKey ||
              key === Keys.SHIFT ||
              key === Keys.SPACEBAR
          ) {
            return;
          }

          if (selected) {
            if (selected.model.isTable) {
              // do nothing since we don't know where to type
            } else {
              selected.addFocus('end');
            }
          }
      }
    };
      
    /*
    * PUBLIC METHODS
    */

    view.observeItemSelected = function (property, item) {
      var selected = item.selected;
      if(!selected && this.selectedItem === item){
        this.setProperty('selectedItem', null);
      } else if (selected && !this.selectedItem) {
        this.setProperty('selectedItem', item);
      } else if (selected && this.selectedItem !== item) {
        this.selectedItem.setProperty('selected', false);
        this.setProperty('selectedItem', item);
      }
    };

    view.isSelected = function (id) {
      var selected = this.getSelected();

      if (selected && selected.isTable) {
        var selectedCell = selected.selectedCell;
        if (selectedCell) {
          selected = selected.columns[selectedCell.column];
        } else {
          selected = null;
        }
      }

      return selected && selected.id.toString();
    };

    view.getSelected = function() {
      return this.selectedItem;
    };
    
    view.getSelectedView = function () {
      var selected = this.getSelected();
      if (selected) {
        var view = this.getItemView(selected.id);
        return view;
      }
      
      return null;
    };

    view.setSelected = function(i) {
      var nextSelected = i;

      if (typeof i === 'number')  nextSelected = this.model.getItemByIndex(i);
      if (nextSelected) {
        nextSelected.setProperty('selected', true);
      } else {
        var selected = this.getSelected();
        if (selected) selected.setProperty('selected', false);
      }
    };
    
    view.upwardDeleteExpression = function (expression) {
      var index = expression.index;
      var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));
      var self = this;
      
      UndoRedo.oneTransaction(function () {
        // remove this item
        self.model.removeItemAt(index);
        
        // if list is now empty, add a blank expression
        if (self.model.getItemCount() === 0) {
          prev = ExpressionObject(undefined, self.model);
          self.model.insertItemAt(0, prev);
        }
        
        // if there isn't an item before us, select the item that was after us
        if (!prev) {
          prev = self.model.getItemByIndex(self.findNextSelectableIndex(index-1));
        }
        
        if (prev) {
          prev.setProperty('selected', true);
        }
      });
    };
    
    view.findPrevSelectableIndex = function (index) {
      var item;

      do {
       index--;
       item = this.model.getItemByIndex(index);
      } while (item && item.inCollapsedFolder);
      
      return item ? index : undefined;
    };

    view.findNextSelectableIndex = function (index) {
      var item;

      do {
       index++;
       item = this.model.getItemByIndex(index);
      } while (item && item.inCollapsedFolder);
      
      return item ? index : undefined;
    };
        
    view.downwardDeleteExpression = function (expression) {
      var index = expression.index;
      var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));
      var self = this;
      
      if (next) {
        this.setSelected(next);
        this.model.removeItemAt(index);
      }
      
      // last, but not only expression
      else if (this.model.getItemCount() > 1) {
        this.setSelected(index-1);
        this.model.removeItemAt(index);
      }
      
      // only expression
      else {
        UndoRedo.oneTransaction(function(){
          self.model.removeItemAt(0);
          self.model.insertItemAt(0, ExpressionObject(undefined, self.model));
          self.setSelected(0);
        });
      }
    };
    
    view.selectPrevExpression = function (expression) {
      if (!expression) return;
      
      var index = expression.index;
      var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));
       
      if (prev) {
        prev.setProperty('selected', true);

        // check if this was an empty last expression
        // if so, remove it
        if (index === this.model.getItemCount() - 1 && expression.isEmpty()) {
          this.model.removeItemAt(index);
        }
      }
    };
 
     view.selectNextExpression = function (expression, dontCreateNew) {
       if (!expression) return;

       var index = expression.index;
       var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));
       
       if (next) {
         next.setProperty('selected', true);
       } else if(!dontCreateNew) {
         var obj = ExpressionObject({ selected:true }, this.model);
         this.model.insertItemAt(this.model.getItemCount(), obj);
       }
     };

     view.getItemsByIndexRange = function (min, max) {
       min = Math.max(0, min);
       max = Math.min(this.model.getItemCount()-1 , max);
       
       var arr=[];
       for (var i=min; i<=max; i++) {
         arr.push(this.model.getItemByIndex(i));
       }
       return arr;
     };
     
     view.getItemByIndex = function(index) {
       var items = this.getItemsByIndexRange(index, index);
       if (!items.length) return null;
       
       return items[0];
     };

     // TODO - should put this on the model itself. fine for now
     view.getItemById = function(id) {
       return this.model.getItemById(id);
     };
     
     // TODO - figure out if this should be separate from getItemById
     // and if so, figure out a more efficient way to do this. Probably
     // should have each item add/remove it's children from this list. Or
     // we could know the parent's id jump straight to the parent. A way to
     // do that would be for the child's id to be prefixed by the parent's id.
     view.getChildItemById = function (id) {
       if (id === null) return null;
              
       var len = this.model.getItemCount();
       for (var i=0; i<len; i++) {
         var item = this.model.getItemByIndex(i);
         
         // tables are the only ones that can have children
         if (item.isTable) {
           var columns = item.columns;
           for (var j=0; j<columns.length; j++) {
             if (String(columns[j].id) === String(id)) {
               return columns[j];
             }
           }
         }
       }
       
       return null;
     };

    /*
    * Does a binary search to find the .expressionitem that is at the point
    */
    view.expressionAtPoint = function (x, y) { //TODO - always return view and move out of expression list.
      var lo = 0;
      var hi = this.model.getItemCount()-1;

      while (lo<=hi) {
        var mid = lo + Math.floor((hi-lo)/2);
        var exp = this.model.getItemByIndex(mid);
        var view = this.getItemView(exp.id);
        var rect = view && view.getBounds();

        if (!rect || rect.top > y) {
          hi = mid - 1;
        } else if (rect.bottom < y) {
          lo = mid + 1;
        } else {
          return exp;
        }
      }

      return null;
    };

    /*
    * Finds the first expression at or above the point
    */
    view.expressionAbovePoint = function (x, y, getDom, ignoreIndex) {
      //TODO - always return view and move out of here...
      var lo = 0;
      var hi = this.model.getItemCount() - 1;
      var found=null;

      while (lo<=hi) {
        var mid = lo + Math.floor((hi - lo)/2);
        
        if (ignoreIndex && mid === ignoreIndex) {
          if (mid < hi) {
            mid++;
          } else if (mid > lo){
            mid--;
          } else {
            return (getDom) ? $() :  null;
          }
        }
        
        var exp = this.model.getItemByIndex(mid);
        var view = this.getItemView(exp.id);
        var rect = view && view.getBounds();

        if (!rect || rect.top > y) {
          hi = mid - 1;
        } else {
          lo = mid + 1;
          found = exp;
        }
      }

      if (found) return (getDom) ? this.getItemView(found.id).$() : found;

      return (getDom) ? $() :  null;
    };
    
    view.getActiveMathquill = function () {
      return $(document.activeElement).closest('.mathquill-editable');
    };

    view.onProjectorModeChange = function() {
      for (var id in this.__itemViews) {
        if (this.__itemViews.hasOwnProperty(id)) {
          this.__itemViews[id].onProjectorModeChange();
        }
      }
    };

    view.onChange = function(changes) {
      /*jshint loopfunc: true*/
      var id;

      for (id in changes) {
        if (!changes.hasOwnProperty(id)) continue;
        
        var expression = this.getItemById(id);
        if (expression) {
          
          if (expression.constructor === ExpressionObject) {
            var formula = changes[id];
            if (!formula) continue;
            
            var view = this.getItemView(expression.id);
            if (expression.loading === false && view && view.doAnimate === undefined) {
              view.setProperty('doAnimate', true);
            }

            expression.setProperty('loading', false);
            expression.setProperty('formula', formula);
          } else if (expression.isTable) {
            var table_data = changes[id];
            var tableView = this.getItemView(id);
            var shouldSyncAllHeights = false;
            var oldSyncRowHeight;
            
            // swap out the tableView.syncRowHeight function for a no-op
            // while making our changes. It'll be called each time a cell
            // changes. We don't want to be doing duplicate work during this.
            // Also, check if anything actually updates in height. If so,
            // do a syncAllRowHeights() afterwards.            
            try {
              oldSyncRowHeight = tableView.syncRowHeight;
              tableView.syncRowHeight = function () {
                shouldSyncAllHeights = true;
              };
            
              expression.setComputedValues(table_data);
            } finally {
              tableView.syncRowHeight = oldSyncRowHeight;
            }
            
            if (shouldSyncAllHeights) {
              tableView.syncAllRowHeights();
            }
          }
        }
      }
    };
  });
  
  return ExpressionListView;
});

define('expressions/abstract_icon',['require','jquery','lib/underscore_view','pjs','lib/keys'],function(require){
  var $ = require('jquery');
  var UnderscoreView = require('lib/underscore_view');
  var P = require('pjs');
  var Keys = require('lib/keys');

  var icon_count = 0;
  
  var AbstractIconView = P(UnderscoreView, function (view, _super) {
    
    view.init = function (parentView) {
      this.parentView = parentView;
      this.model = parentView.model;
      
      _super.init.call(this);
      this.optionsmenu_guid = (++icon_count);

      // model.error is a message; this.error is boolean whether we care about
      // the error. One time we don't care is if the model is empty.
      this.model.observe('error.iconview', this.renderErrorTooltip.bind(this));
      this.observe('error', this.renderErrorTooltip.bind(this));

      this.observe('error errorStable', this.computeErrorShown.bind(this));
      this.observe('errorShown', this.renderErrorShown.bind(this));
    };
    
    view.destruct = function () {
      this.model.unobserve('.iconview');
    };
       
    view.computeErrorShown = function () {
      this.setProperty('errorShown', this.error && this.errorStable);
    };
    
    view.renderErrorTooltip = function () {
      var error = this.error ? this.model.error : '';
      this.$().closest('.variable-errortooltip').attr('tooltip', error);
    };

    view.renderErrorShown = function () {
      this.$().toggleClass('error', !!this.errorShown);
    };

    view.didInsertElement = function () {
      this.renderErrorShown();
      this.renderErrorTooltip();
    };
    
    // defined in subclass
    view.createOptionsMenuView = function () {};
    
    view.toggleOptions = function() {
      if (this.error) {
        this.hideOptions();
        return;
      }
      if (this.optionsShown) {
        this.hideOptions();
        return;
      }
      
      this.optionsShown = true;

      // Add options menu to #main. workaround bug with "-webkit-scrolling-overflow: touch" and child "position:
      // relative" elements not respecting z-index
      // see: "-webkit-overflow-scrolling: touch is messing up z-index stacking"
      // [http://code.google.com/p/chromium/issues/detail?id=128325]
      this.optionsMenu = this.createOptionsMenuView(); //defined in subclass
      
      // TODO - temporary until we have a better popup menu manager
      window.opened_options_menu = this;

      var id = this.optionsmenu_guid;
      
      // ipad sends out a scroll event when you tapstart on the button that
      // opens the context menu. We want that first scroll event to be
      // ignored, so we add the listener after a slight timeout to give the
      // first scroll event time to pass through.
      setTimeout(function(){
        //make sure options menu hasn't closed before the timeout fires
        if (this.optionsShown) {
          $('#exppanel').on("scroll.options-menu-" + id, function(evt) {
            this.hideOptions();
          }.bind(this));
        }
      }.bind(this), 0);
      
      $(document).on("keydown.options-menu-" + id, function (e) {
        if (Keys.lookup(e) === Keys.ESCAPE) {
          this.hideOptions();
        }
      }.bind(this));
            
      $(document).on("tapstart.options-menu-" + id, function (e) {
        
        // close this unless:
        // * we click on the icon again (will handle that separately)
        // * we click insde the context-menu (that's been moved to the body)
     
        // we click inside the context menu (but not on the "close" button)
        if ($(e.target).closest('.options-menu').length) return;
     
        // we click within this view again
        if ( $(e.target).closest(this.$()).length) return;

        this.hideOptions();

      }.bind(this));
    };
    
    view.hideOptions = function() {
      var id = this.optionsmenu_guid;
      $(document).off("tapstart.options-menu-" + id);
      $(document).off("keydown.options-menu-" + id);
      $('#exppanel').off("scroll.options-menu-" + id);
      this.optionsShown = false;
      
      if (this.optionsMenu) {
        this.optionsMenu.remove();
        this.optionsMenu = null;
      }
      
      // TODO - temporary until we have a better popup menu manager
      if (window.opened_options_menu === this) {
        window.opened_options_menu = null;
      }
    },
    
    view.onDisplayChange = function () {
      var error = this.model.error ? true : false;
      if (this.model.isEmpty()) error = false;
      
      //next sequence of code will only add the errorStable property
      //if the error value hasn't changed within the last 500ms
      if (error !== this.error) {
        this.setProperty('errorStable',false);
        this.__errorTime = new Date().getTime();
        setTimeout(this.onDisplayChange.bind(this), 100);
      } else if (this.__errorTime + 500 < new Date().getTime()) {
        this.setProperty('errorStable', true);
      } else if (!this.errorStable) {
        setTimeout(this.onDisplayChange.bind(this), 100);
      }

      this.setProperty('error', error);
    };
    
  });
 
  return AbstractIconView;
});

define('template!expression_options_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'exp-options-menu options-menu ';
 if (styles.length === 0) { 
;__p+='colors-only';
 } 
;__p+='\'>\n  <div class=\'triangle\'></div>\n  ';
 if (styles.length > 0) { 
;__p+='\n    <div class=\'styles-div\'>\n      <div class=\'styles-menu\'>\n        <div class=\'title\'>style:</div>\n        <div class=\'styles-menu\'>\n        ';
 _.each(styles, function (style) { 
;__p+='\n          <span class="style-option graph-icon graph-'+
( style )+
'"\n            draw-style="'+
( style )+
'"\n            style=""\n            handleevent="true">\n          </span>\n        ';
 }) 
;__p+='\n        </div>\n      </div>\n    </div>\n  ';
 } 
;__p+='\n  <div class=\'colors-div\'>\n    <div class=\'title\'>color:</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>';
}
return __p;
};});
define('loadcss!css/color_menu', function(){});
define('template!color_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="color-menu do-not-blur">\n  ';
 _.each(colors, function (color) { 
;__p+='\n    <span class="color-option"\n          color="'+
( color )+
'"\n          style="background: '+
( color )+
'"\n          handleevent="true">\n          <i class=\'icon-check\'></i>\n    </span>\n  ';
 }) 
;__p+='\n</div>';
}
return __p;
};});
define('expressions/color_menu_view',['require','loadcss!css/color_menu','jquery','pjs','lib/underscore_view','./colors','template!color_menu'],function(require){
  require('loadcss!css/color_menu');
  
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var Colors = require('./colors');
  
  var template = require('template!color_menu');
 
  var ExpressionColorsView = P(UnderscoreView, function (view, _super) {
    view.template = template,
    
    view.init = function (expression) {
      _super.init.call(this);
      this.expression = expression;
      this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
      this.expression.observe('userRequestedGraphing.colorview', this.renderSelectedColor.bind(this));
    };
    
    view.destruct = function () {
      this.expression.unobserve('.colorview');
    };
    
    view.renderSelectedColor = function () {
      var color = this.expression.color;
      this.$('.color-option').removeClass('selected');
      this.$('.color-option[color="'+color+'"]').addClass('selected');
    };
    
    view.didInsertElement = function () {
      this.$().on('tap tapstart', '.color-option', this.onSelectColor.bind(this));
      this.renderSelectedColor();
    };

    view.getTemplateParams = function () {
      return {
        colors: Colors.all
      };
    };

    view.onSelectColor = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;
      var color = $(evt.target).closest('.color-option').attr('color');
      this.expression.setProperty('color', color);
    };
    
  });
  
  return ExpressionColorsView;
});

define('expressions/expression_options_view',['require','pjs','jquery','underscore','lib/underscore_view','template!expression_options_menu','./colors','./color_menu_view'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var UnderscoreView = require('lib/underscore_view');
  var template = require('template!expression_options_menu');
  var Colors = require('./colors');
  var ColorMenuView = require('./color_menu_view');
    
  var ExpressionOptionsMenuView = P(UnderscoreView, function (view, _super) {
    view.template = template;
    
    view.init = function (expression) {
      this.expression = expression;
      this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
      this.expression.observe('userRequestedGraphing', this.renderSelectedStyle.bind(this));
    };
    
    view.destruct = function () {
      if (this.colorsView) {
        this.colorsView.remove();
        this.colorsView = null;
      }
    };

    view.getTemplateParams = function () {
      var params = {colors: Colors.all, styles: []};
      if (this.expression.formula.is_point_list && !this.expression.formula.move_ids) {
        params.styles = ['point', 'open'];
      } else if (!this.expression.table && !this.expression.formula.move_ids) {
        if (!this.expression.formula.is_inequality) {
          params.styles = ['normal', 'dashed'];
        }
      }
      return params;
    };

    view.renderSelectedColor = function () {
      var color = this.expression.color;
      _.each(this.$('.style-option'), function (option) {
        $(option).css('background', color);
      });
    };

    view.onSelectStyle = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;

      var style = $(evt.target).closest('.style-option').attr('draw-style');
      if (style === this.expression.style && this.expression.userRequestedGraphing !== 'never') {
        this.$('.style-option').removeClass('selected');
        this.expression.setProperty('userRequestedGraphing', 'never');
      } else {
        this.expression.setProperty('userRequestedGraphing', 'default');
        this.$('.style-option').removeClass('selected');
        $('.style-option[draw-style="'+style+'"]').addClass('selected');
        this.expression.setProperty('style', style);
      }
    };
    
    view.renderSelectedStyle = function () {
      var style = this.expression.style;
      this.$('.style-option').removeClass('selected');
      if (this.expression.userRequestedGraphing !== 'never') {
        this.$('.style-option[draw-style="'+style+'"]').addClass('selected');
      }
    };
    
    view.didInsertElement = function () {
      // this view has a nested template. We instantiate the color picker
      // and replace a placeholder element within the html.
      this.colorsView = ColorMenuView(this.expression);
      this.colorsView.replace(this.$('.template-colorsview'));
      this.$().on('tap tapstart', '.style-option', this.onSelectStyle.bind(this));
      this.renderSelectedColor();
      this.renderSelectedStyle();
    };
    
  });

  return ExpressionOptionsMenuView;
});

define('template!expression_icon', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="icon graph-icon variable-colorcss variable-errortooltip tipsy-sticky">\n\t<i class=\'icon-play\'></i>\n\t<i class=\'icon-pause\'></i>\n\t<i class=\'icon-hidden\'></i>\n</span>\n';
}
return __p;
};});
define('expressions/expression_icon_view',['require','pjs','expressions/abstract_icon','./expression_options_view','math/comparators','template!expression_icon'],function(require){
  var P = require('pjs');
  var AbstractIconView = require('expressions/abstract_icon');
  var ExpressionOptionsMenuView = require('./expression_options_view');
  var Comparators = require('math/comparators');
  var template = require('template!expression_icon');

  var ExpressionIconView = P(AbstractIconView, function (view, _super) {
    view.template = template;
    
    view.init = function (parentView) {
      _super.init.call(this, parentView);
      this.expression = this.model;

      // wait for the slider to be created. Then observe the isPlaying property on it
      this.expression.observe('slider.iconview', function () {
        this.expression.slider.observe('isPlaying.iconview', this.onDisplayChange.bind(this));
      }.bind(this));
      
      this.expression.observe('formula.iconview', this.onDisplayChange.bind(this));
      this.expression.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
      this.expression.observe('isGraphable.iconview', this.renderUngraphable.bind(this));
      this.expression.observe('loading.iconview', this.renderLoading.bind(this));
      this.expression.observe('color.iconview', this.renderColorCSS.bind(this));
      this.expression.observe('style.iconview', this.onDisplayChange.bind(this));
    };
    
    view.destruct = function () {
      _super.destruct.call(this);
      
      this.expression.unobserve('.iconview');
      if (this.expression.slider) {
        this.expression.slider.unobserve('.iconview');
      }
    };
    
    view.renderUngraphable = function () {
      this.$().toggleClass('ungraphable', !this.expression.isGraphable);
    };

    view.renderLoading = function () {
      this.$().toggleClass('loading', !!this.expression.loading);
    };
    
    view.renderColorCSS = function() {
      this.$('.variable-colorcss').css({
        'border-color' : this.expression.color,
        'background' : this.expression.color
      });
    };
    
    view.didInsertElement = function () {
      var self = this;
      _super.didInsertElement.call(this);
      
      this.renderLoading();
      this.renderUngraphable();
      this.renderColorCSS();
      this.onDisplayChange();

      this.$icon = this.$('.icon');

      var handleIconTapped = function(evt, device){
        if(evt.wasHandled('dragdrop')) return; //Don't toggle if we were handled by dragdrop
        if(evt.wasLongheld()) return;
        if(evt.device !== device) return;

        if (self.optionsShown) {
          self.toggleOptions();
          return false;
        }

        if (self.parentView.listView.editListMode) {
          if (self.expression.isGraphable) {
            self.toggleOptions();
          }
        } else if (self.expression.formula.is_animatable) {
          self.toggleSliderIsPlaying();
        } else {
          self.toggleGraphShown();
        }
      };

      var handleIconLongHold = function(evt, device) {
        if(evt.device !== device) return;
        if (!self.model.isGraphable) return;

        evt.handle('longhold');
        self.toggleOptions();
      };

      this.$().closest('.action-icon-mouse').on('tap', function(evt){
        handleIconTapped(evt, 'mouse');
      });

      this.$().closest('.action-icon-touch').on('tap', function(evt){
        handleIconTapped(evt, 'touch');
      });

      this.$().closest('.action-icon-mouse').on('longhold', function(evt){
        handleIconLongHold(evt, 'mouse');
      });

      this.$().closest('.action-icon-touch').on('longhold', function(evt){
        handleIconLongHold(evt, 'touch');
      });
    };

    // TODO - consider userRequestedGraphing being part of the expression's
    // view not it's model. Not sure on that because whether the expression
    // is graphed might be model worthy.
    view.isGraphShown = function () {
      return this.expression.userRequestedGraphing !== "never";
    };

    view.toggleSliderIsPlaying = function () {
      var slider = this.expression.slider;
      if (slider) {
        slider.setProperty('isPlaying', !slider.isPlaying);
      }
    };

    view.toggleGraphShown = function() {
      if (!this.model.isGraphable) return;
      if (this.errorShown) return;

      // Trying to edit whether a graph is shown in a hidden folder should
      // show the folder, and also ensure that the clicked icon is graphed
      if (this.model.folder && this.model.folder.hidden) {
        this.model.folder.setProperty('hidden', false);
        this.expression.setProperty("userRequestedGraphing", "always");
        return;
      }

      if (this.isGraphShown()) {
        this.expression.setProperty("userRequestedGraphing", "never");
      } else {
        this.expression.setProperty("userRequestedGraphing", "always");
      }
    };

    view.createOptionsMenuView = function () {
      var optionsView = ExpressionOptionsMenuView(this.expression);
      optionsView.appendTo(this.$().closest('.expressionitem'));
      return optionsView;
    };
    
    view.onDisplayChange = function () {
      _super.onDisplayChange.call(this);
      if (!this.$icon) return;
      
      var formula = this.expression.formula;
      var icon_class = '';
      
      if (formula.is_animatable) {
        if (this.expression.slider.isPlaying) {
          icon_class = 'animate-pause';
        } else {
          icon_class = 'animate-play';
        }
      } else if (this.error || !formula.is_graphable) {
        icon_class = '';
      } else {

        var shouldGraph = this.expression.shouldGraph;
        var style = this.expression.style;
        var operator = formula.operator;
        var shaded = Comparators.table[operator].direction !== 0;
        var dotted = Comparators.table[operator].inclusive === false;
        if (!shouldGraph) {
          icon_class = 'graph-hidden';
        } else if (formula.move_ids) {
          icon_class = 'graph-movable-point';
        } else if (formula.is_point_list) {
          if (style === 'open') {
            icon_class = 'graph-open';
          } else if (style === 'cross') {
            icon_class = 'graph-cross';
          } else {
            icon_class = 'graph-point';
          }
        } else if (formula.is_shade_between) {
          // TODO - missing icon for this
          icon_class = 'graph-shaded-inequality';
        } else if (!dotted && !shaded) {
          if (style === 'normal') {
            icon_class = 'graph-normal';
          } else if (style === 'dashed') {
            icon_class = 'graph-dashed';
          }
        } else if (!dotted && shaded) {
          // TODO - missing icon for this
          icon_class = 'graph-shaded-inequality';
        } else if (dotted && !shaded) {
          icon_class = 'graph-inequality';
        } else if (dotted && shaded) {
          icon_class = 'graph-shaded-inequality';
        }
      }
      
      // efficently changes the class of the icon
      if (this.rendered_icon_class === icon_class) return;
      if (this.rendered_icon_class) {
        this.$icon.removeClass(this.rendered_icon_class);
      }
      this.rendered_icon_class = icon_class;
      if (icon_class) {
        this.$icon.addClass(icon_class);
      }
      
    };
  });
  
  return ExpressionIconView;
});

define('template!evaluation_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="evaluation do-blur" handleEvent="true">\n  <table>\n    <tr>\n      <th class="action-selectevaluation">\n        <span class="template-dependentlabelhtml"></span>\n        <span class="equals">=</span>\n      </th>\n      <td class="text-selectable template-evaluationshtml"></td>\n    </tr>\n  </table>\n</div>';
}
return __p;
};});

define('expressions/evaluation',['require','pjs','lib/underscore_view','template!evaluation_view','i18n'],function(require){
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var template = require('template!evaluation_view');
  var i18n = require('i18n');

  var EvaluationView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (domain) {
      _super.init.call(this);
      this.evaluations = [];

      this.observe('dependentLabel', this.renderDependent.bind(this));
      this.observe('evaluations', this.renderEvaluations.bind(this));
    };

    view.renderDependent = function () {
      this.$('.template-dependentlabelhtml').html(this.dependentLabel);
    };
    
    view.renderEvaluations = function () {
      var vals = this.evaluations;
      var vals_str = [];

      for (var i=0; i<vals.length; i++) {
        var f_val = vals[i];
        if (f_val.val === false) {
          f_val.val = 'false';
        } else if (isNaN(f_val.val)) {
          f_val.val = 'undefined';
        } else if (f_val.val === true) {
          f_val.val = 'true';
        } else if (Math.abs(f_val.val) < 1e-15) {
          f_val.val = 0;
        } else if (vals.length === 1) {
          f_val.val = Number(f_val.val.toPrecision(8));
        } else {
          f_val.val = Number(f_val.val.toPrecision(6));
        }

        vals_str.push(f_val.val);
      }

      if (vals_str.length === 0) return "";
      var output = vals_str.join('<span class="or">'+ i18n.t('or') + '</span>');
      
      this.$('.template-evaluationshtml').html(output);
    };

    view.didInsertElement = function () {
      this.renderDependent();
      this.renderEvaluations();
      
      this.$('.action-selectevaluation').on('tap', this.onSelectEvaluation.bind(this));
    };

      
    view.onSelectEvaluation = function () {
      var numberElement = this.$('td')[0];
      var range = document.createRange();
      range.selectNodeContents(numberElement);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
    };

  });
  return EvaluationView;
});

define('template!domain_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="domain do-blur" handleEvent="true">\n  \n  <div class="edit-domain variable-invalid desmos-input-container">\n    <table>\n      <tr>\n        <td>\n          <span class="before-input"></span>\n          <input type="number" limit="min" />\n          <span class="after-input"></span>\n        </td>\n        <td class="text">≤</td>\n        <td class="text">t</td>\n        <td class="text">≤</td>\n        <td>\n          <span class="before-input"></span>\n          <input type="number" limit="max" />\n          <span class="after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n  <div class="display-domain">\n    <span class="variable-min"></span> ≤ t ≤ <span class="variable-max"></span>    \n  </div>\n\n</div>';
}
return __p;
};});
define('expressions/domain_view',['require','jquery','lib/underscore_view','pjs','template!domain_view','lib/keys'],function(require){
  var $ = require('jquery');
  var UnderscoreView = require('lib/underscore_view');
  var P = require('pjs');
  var template = require('template!domain_view');
  var Keys = require('lib/keys');

var DomainView = P(UnderscoreView, function (view, _super) {
  view.template = template;

  view.init = function (domain) {
    _super.init.call(this);

    this.domain = domain;

    this.domain.observe('min.domainview', this.renderMin.bind(this));
    this.domain.observe('max.domainview', this.renderMax.bind(this));
    this.setProperty('editing', false);
    this.setProperty('invalid', !this.domain.isValid());
    this.observe('invalid', this.renderInvalid.bind(this));
    this.observe('editing', this.renderEditing.bind(this));
    this.storeLastValidDomain();
  };

  view.checkInvalid = function () {
    var min = parseFloat(this.$('input[limit=min]').attr('value'));
    var max = parseFloat(this.$('input[limit=max]').attr('value'));

    var invalid = ( !isFinite(min) || !isFinite(max) || min>=max);
    this.setProperty('invalid', invalid);
  };
  
  view.destruct = function () {
    this.domain.unobserve('.domainview');
  };
  
  view.storeLastValidDomain = function () {
    if (this.domain.isValid()) {
      this.lastValidDomain = this.domain.serialize();
    }
  };
  
  view.renderInvalid = function () {
    this.$('.edit-domain').toggleClass('invalid', !!this.invalid);
  };
  
  view.renderEditing = function () {
    var editing = this.getProperty('editing');
    this.$().toggleClass('editing-domain', !!editing);
  };
  
  view.renderMin = function () {
    var min = this.domain.min;
    this.$('input[limit=min]').val(min);
    this.$('.variable-min').text(min);
  };
  
  view.renderMax = function () {
    var max = this.domain.max;
    this.$('input[limit=max]').val(max);
    this.$('.variable-max').text(max);
  };

  view.didInsertElement = function () {
    this.$('input').on('focusin', this.focusIn.bind(this))
                   .on('focusout', this.focusOut.bind(this))
                   .on('keydown keyup keypress', this.handleUserInput.bind(this));
    this.$('.display-domain').on('tap', this.onEditLimit.bind(this));
    this.renderEditing();
    this.renderMin();
    this.renderMax();
  };

  view.onEditLimit = function (evt) {
    evt.preventDefault();
    var $target = $(evt.toElement);
    this.setProperty('editing', true);
    if ($target.hasClass('variable-max')) {
      this.$('input[limit="max"]').focus().select();
    } else {
      this.$('input[limit="min"]').focus().select();
    }
  };

  view.stopEditing = function () {
    if (!this.domain.isValid() && this.lastValidDomain) {
      this.domain.setProperty('min', this.lastValidDomain.min);
      this.domain.setProperty('max', this.lastValidDomain.max);
    }
    this.setProperty('editing', false);
  };

  // blur input when enter pressed
  view.handleUserInput = function(evt) {
     if (Keys.lookup(evt) === Keys.ENTER) {
      $(document.activeElement).blur();
    } else {
      this.checkInvalid();
      
      // save the domain now so that it redraws
      if (!this.invalid) {
        this.save(evt.target);
      }
    }
  };

  // went straight into a focus, so don't save
  view.focusIn = function(evt) {
    clearTimeout(this.saveAfterBlurTimeout);
    this.checkInvalid();
  };

  // if we don't focus into one of the other boxes really soon,
  // we'll just act like the save button was pressed. This is
  // a sideeffect of focusin being fired AFTER focusout. Temporarily,
  // nothing is focused and we can't tell if focus is about to be
  // placed or not.
  view.focusOut = function(evt) {
    var self = this;
    this.save(evt.target);
    this.saveAfterBlurTimeout = setTimeout(function() {
      clearTimeout(self.saveAfterBlurTimeout);
      self.stopEditing();
    }, 1);
    this.checkInvalid();
  };

  view.save = function(node) {
    if (node) {
      var target = $(node);
      var value = parseFloat(target.attr('value'));

      if (target.attr('limit') === 'min') {
        // set the new min
        if (value < this.domain.max) {
          this.domain.setProperty('min', value);
        // reset the value since it's invalid
        } else {
          target.attr('value', this.domain.min);
        }
      } else if (target.attr('limit') === 'max') {
        // set the new max
        if (value > this.domain.min) {
          this.domain.setProperty('max', value);
        // reset the value since it's invalid
        } else {
          target.attr('value', this.domain.max);
        }
      }
      this.storeLastValidDomain();
    }
  };
});

return DomainView;
});

define('loadcss!css/slider', function(){});
define('main/focus',['require'],function (require) {
  // The point of this right now is to allow settings, subheader, etc. to
  // take focus from the expressions list. Leaving it very simple since its
  // current needs are simple.
  return {
    // overridden by calc*.js to remove focus from the expressions list.
    takeFocus: function () {}
  };
});
define('template!slider_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="slider-container" tapboundary="true">\n\n  <div class="do-blur slider" handleEvent="true">\n    <div class="minLabel template-minlabelhtml">\n    </div>\n    <div class="maxLabel">\n      <span class="template-maxlabelhtml"></span>\n    </div>\n    <div class="track action-moveslider">\n      <div class="ticks template-tickmarkhtml"></div>\n      <div class="graphic"></div>\n    </div>\n    <div class="zeroMarker action-moveslider">\n      <div class="graphic"></div>\n    </div>\n    <div class="thumb action-startdragging" disablescroll="true">\n      <div class="graphic"></div>\n      <div class="center"></div>\n    </div>\n  </div>\n  \n  <div class="slider-speed-container do-not-blur" handleEvent="true">\n    <span class="action-slower" >&laquo;</span>\n    <span class="variable-speed"></span>\n    <span class="action-faster">&raquo;</span>\n  </div>\n\n  <div class="slider_menu do-blur desmos-input-container" handleEvent="true">\n    <table>\n      <tr>\n        <td>\n          <span class="before-input"></span>\n            <input class="slider_min" limit="min" type="number">\n          <span class="after-input"></span>\n    ';
 /*
      Need to be careful with unescaped html insertion. This html is generated
      from user input by mathquill, so we"re relying on mathquill to escape
      html as necessary.
    */ 
;__p+='\n        </td>\n        <td class="text">\n          ≤\n        </td>\n        <td class="template-dependentlabelhtml text"></td>\n        <td class="text">≤</td>\n        <td>\n          <span class="before-input"></span>\n            <input class="slider_max" limit="max" type="number">\n          <span class="after-input"></span>\n        \n        </td>\n        <td class="step text">'+
( t('step:') )+
'</td>\n        <td> \n          <span class="before-input"></span>\n            <input class="slider_interval" limit="step" type="number">\n          <span class="after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n</span>';
}
return __p;
};});
define('expressions/slider_view',['require','loadcss!css/slider','jquery','pjs','lib/rounding','lib/underscore_view','main/focus','template!slider_view','config','underscore','lib/keys'],function(require) {
  require('loadcss!css/slider');
  
  var $ = require('jquery');
  var P = require('pjs');
  var Rounding = require('lib/rounding');
  var UnderscoreView = require('lib/underscore_view');
  var Focus = require('main/focus');
  var template = require('template!slider_view');
  var Config = require('config');
  var _ = require('underscore');
  var Keys = require('lib/keys');

  var label2html = function(num) {
    var onum=num;
    var str = String(num).split("-").join("");

    if (str.length > 4 || str.indexOf("e") != -1) {
      // size of input
      var digits = Math.floor(Math.log(Math.abs(num))/Math.LN10);

      // move the decimial over to the unit's place
      num = num/Math.pow(10, digits);

      // round to 1 sig figs
      num = Math.round(num);

      if (Math.abs(num) >= 10) {
        digits++;
        if (num < 0) {
          num = -1;
        } else {
          num = 1;
        }
      }

      if (digits >= -3 && digits <= 3) {
        str = String(onum);
        if (str.indexOf("0.") === 0) {
          str = str.substr(1);
        } else if (str.indexOf("-0.") === 0) {
          str = "-" + str.substr(2);
        }

        return str.substr(0, 5);
      }

      return num + "\u00D7" + "10<span class='sup'>" + digits + "</span> ";
    } else {
      return String(num);
    }
  };

  var SliderView = P(UnderscoreView, function(view, _super) {
    view.template = template;
    view.animationSpeeds = [0.05, 0.1, 0.15, 0.2, 0.35, 0.5, 0.75, 1, 1.5, 2, 3.5, 5, 7.5, 10, 15, 20];

    view.init = function (slider, parentView) {
      _super.init.call(this);
      this.slider = slider;
      this.parentView = parentView;
      
      // we hold a local copy of the slider's value. this allows us to
      // throttle how quickly we set the value back to the slider.
      this.value = this.slider.value;
      
      // if the slider's value changes, we immediately overwrite our local
      // copy of the variable with the new official value.
      this.slider.observe('value', function () {
        this.setProperty('value', this.slider.value);
      }.bind(this));

      this.editing = false;
    
      // Watch changes to the properties while we edit the slider.
      this.slider.observe('min.sliderview max.sliderview', this.renderThumbPosition.bind(this));
      this.observe('value', this.renderThumbPosition.bind(this));
      
      this.slider.observe('min.sliderview max.sliderview', this.renderZeroMarker.bind(this));
      this.slider.observe('min.sliderview max.sliderview step.sliderview', this.renderTickMarks.bind(this));
      this.slider.observe('min.sliderview', this.renderMin.bind(this));
      this.slider.observe('max.sliderview', this.renderMax.bind(this));
      this.slider.observe('step.sliderview', this.renderStep.bind(this));
      this.observe('dependentLabel', this.renderDependent.bind(this));
      this.observe('editing', this.renderEditing.bind(this));
      this.observe('editing', function () {
        this.slider.setProperty('isPlaying', false);
      }.bind(this));
      this.observe('invalid', this.renderInvalid.bind(this));
      this.observe('dragging', this.renderDragging.bind(this));
      this.slider.observe('isPlaying.sliderview', this.renderIsPlaying.bind(this));
      this.slider.observe('isPlaying.sliderview', this.setTransient.bind(this));
      this.observe('dragging isMoving', this.setTransient.bind(this));
      this.slider.observe('animationSpeed', this.renderAnimationSpeed.bind(this));
    };

    view.renderAnimationSpeed = function () {
      var speed = this.slider.animationSpeed;
      
      var text = speed + 'x';
      this.$('.variable-speed').text(text);
      this.$('.action-slower').toggleClass('disabled', _.min(this.animationSpeeds) >= speed);
      this.$('.action-faster').toggleClass('disabled', _.max(this.animationSpeeds) <= speed);
    };

    view.setTransient = function () {
      this.slider.setProperty(
        'transient',
        this.dragging || this.slider.isPlaying || this.isMoving
      );
    };
    
    view.destruct = function () {
      this.slider.unobserve('.sliderview');
    };
    
    view.renderDependent = function () {
      this.$('.template-dependentlabelhtml').html(this.dependentLabel);
    };
    
    view.renderDragging = function () {
      this.$('.thumb').toggleClass('down', !!this.dragging);
    };

    view.renderStep = function () {
      this.$('input[limit=step]').val(this.slider.step);
    };
    
    view.renderMin = function () {
      this.$('.template-minlabelhtml').html(label2html(this.slider.min));
      this.$('input[limit=min]').val(this.slider.min);
    };
    
    view.renderMax = function () {
      this.$('.template-maxlabelhtml').html(label2html(this.slider.max));
      this.$('input[limit=max]').val(this.slider.max);
    };

    view.renderEditing = function () {
      this.$().toggleClass('editing-limits', this.editing);
    };
    
    view.renderInvalid = function () {
      this.$('.slider_menu').toggleClass('invalid', !!this.invalid);
    };

    view.renderThumbPosition = function() {
      var left;
      var min = this.slider.min;
      var max = this.slider.max;
      var val = this.value;
      
      if (val <= min) {
        left = 0;
      } else if (val >= max) {
        left = 100;
      } else {
        left = (val - min)/(max - min) * 100;
      }

      this.$('.thumb').css('left', left + "%");
    };
    
    view.renderZeroMarker = function() {
      var t = (0 - this.slider.min)/(this.slider.max - this.slider.min);
      var css = {};
      if (t >= 0 && t <= 1) {
        var left = t*100;
        css.display = "block";
        css.left = left + '%';
      } else {
        css.display = "none";
      }
      
      this.$('.zeroMarker').css(css);
    };

    view.renderTickMarks = function() {
      var step = this.slider.step;
      var min = this.slider.min;
      var max = this.slider.max;
      
      var percent = 100*step/(max - min);
      if (percent < 3) percent = 0; // don't draw too many ticks

      var html = "";
      if (percent > 0 && percent < 100) {
        for (var i=percent; i<100; i += percent) {
          html += '<div class="tick" style="left:' + i + '%"></div>';
        }
      }

      this.$('.template-tickmarkhtml').html(html);
    };

    view.getDimensions = function() {
      var track = this.$('.track');
      var trackLeft = track.offset().left;
      var trackRight = trackLeft + track.width();
      return {
        trackLeft: trackLeft,
        trackRight: trackRight
      };
    };

    view.animateSlower = function () {
      var speed = this.slider.animationSpeed;
      var slowers = _.filter(this.animationSpeeds, function (val) { return val<speed; });
      if (slowers.length === 0) return;
      
      this.slider.setProperty('animationSpeed', _.max(slowers));
    };

    view.animateFaster = function () {
      var speed = this.slider.animationSpeed;
      var fasters = _.filter(this.animationSpeeds, function (val) { return val>speed; });
      if (fasters.length === 0) return;
      
      this.slider.setProperty('animationSpeed', _.min(fasters));
    };

    view.didInsertElement = function() {

      // setup event handlers
      this.$('.action-startdragging').on('tapstart', this.onStartDragging.bind(this));
      this.$('.action-moveslider').on('tap', function (evt) {
        var touch = evt.changedTouches[0];
        this.slider.setProperty('isPlaying', false);
        this.setValueByTouch(touch);
        this.commitSliderValue();
      }.bind(this));
      
      this.$().on('focusout', this.focusOut.bind(this));
      this.$().on('focusin', this.focusIn.bind(this));
      this.$().on('keydown', this.keyDown.bind(this));
      this.$('input[limit]').on('keypress keydown keyup', this.checkInvalid.bind(this));

      this.$('.action-play').on('tap', function () {
        this.slider.setProperty('isPlaying', true);
      }.bind(this));

      this.$('.action-faster').on('tap', this.animateFaster.bind(this));
      this.$('.action-slower').on('tap', this.animateSlower.bind(this));

      //Editing from main view - only active when using mouse
      this.$().on('tap', '.minLabel', this.onEditMin.bind(this));
      this.$().on('tap', '.maxLabel', this.onEditMax.bind(this));

      this.renderTickMarks();
      this.renderThumbPosition();
      this.renderZeroMarker();
      this.renderDependent();
      this.renderMin();
      this.renderMax();
      this.renderStep();
      this.renderAnimationSpeed();
 
      this.checkInvalid();
    };
    
    view.setValueByTouch = function (touch) {

      // properties of the slider
      var min = this.slider.min;
      var max = this.slider.max;

      // figures out where the slider is located on the screen.
      var dimensions = this.getDimensions();
      
      var left = dimensions.trackLeft;
      var right = dimensions.trackRight;
      var width = right - left;
      var pixel_units = (max-min)/width;
      
      // figures out the percent 0%-100% of the thumbs position
      var t = Math.min(1, Math.max(0,(touch.pageX - left)/width));
        
      var val = min*(1 - t) + max*t;
      if (val <= min ) val = min;
      else if (val >= max) val = max;
      else {

        // round to a pretty number
        val = Rounding.bestRound(val, pixel_units );

        // snap to the step interval
        val = this.slider.computeSnappedValue(val);
        
        if (val<min) val=min;
        else if(val>max) val=max;
      }

      this.setProperty('value', val);
    };

    view.onStartDragging = function(evt) {

      // only start dragging if this is the first touch
      if (evt.touches.length !== 1) return;

      // updated by eli. On Android it's especially noticeable, but in general
      // it feels like we want to defocus expressions we're sliding a slider
      // unintended positive side effect:
      // also improves performance, since we don't need to stream POIs while sliding
      Focus.takeFocus();
      
      var self = this;

      // Stop any slider animation
      this.slider.setProperty('isPlaying', false);
      
      var getTouchByIdentifier = function (evt, identifier) {
        var touches = evt.touches;
        var touch = null;
        
        for (var i=0; i<touches.length; i++) {
          if (touches[i].identifier === identifier) {
            touch = touches[i];
          }
        }
        
        return touch;
      };
      
      var throttleInterval = Config.get('platform') === 'ios' ? 30 : 10;
      var commitSliderValueThrottled = _.throttle(self.commitSliderValue.bind(self), throttleInterval);

      self.setProperty('dragging', true);
      
      var touchIdentifier = evt.changedTouches[0].identifier;
      var onMouseMove = function(evt) {
        
        // lookup the touch that started this
        var touch = getTouchByIdentifier(evt, touchIdentifier);
        if (!touch) return;
                
        self.setValueByTouch(touch);
        
        // We commit the slider's value manually here instead of using an
        // observer on 'value' because we need precise control of when the
        // value is committed. When the user types in mathquill, that causes
        // a change in the sliders value. We don't want that change to get
        // routed back into commitSliderValue(). If it did, the user would never
        // be able to type decimals. When they typed "a=1.", the
        // commitSliderValue() function would turn that into "a=1" again.
        commitSliderValueThrottled();
      };

      var stopDragging = function () {
        $(document).off('tapmove', onMouseMove);
        $(document).off('tapend tapcancel', onMouseUp);

        self.setProperty('dragging', false);
      };

      var onMouseUp = function(evt) {
        
        // checks if the touch that started the slider is still around. If so,
        // don't do anything here. A different touch must have lifted.
        var touch = getTouchByIdentifier(evt, touchIdentifier);
        if (touch) return;
        
        stopDragging();
        self.commitSliderValue();
      };

      $(document).on('tapmove', onMouseMove);
      $(document).on('tapend tapcancel', onMouseUp);
    };

    view.commitSliderValue = function() {
      this.slider.setProperty('value', this.value);
    };
    
    view.checkInvalid = function () {
      var min = parseFloat(this.$('input[limit=min]').attr('value'));
      var max = parseFloat(this.$('input[limit=max]').attr('value'));
      var step = this.$('input[limit=step]').attr('value');
          step = step === '' ? 0 : parseFloat(step);
      
      var invalid = ( !isFinite(min) || !isFinite(max) || min>=max || step < 0 || step > (max-min));
      this.setProperty('invalid', invalid);
    };

    // blur input when enter pressed
    view.keyDown = function(evt) {
      if (Keys.lookup(evt) === Keys.ENTER) {
        $(document.activeElement).blur();
      } else {
        this.checkInvalid();
      }
    },

    // went straight into a focus, so don't save
    view.focusIn = function(evt) {
      this.slider.setProperty('isPlaying', false);
      clearTimeout(this.saveAfterBlurTimeout);
      this.checkInvalid();
    },

    // if we don't focus into one of the other boxes really soon,
    // we'll just act like the save button was pressed. This is
    // a sideeffect of focusin being fired AFTER focusout. Temporarily,
    // nothing is focused and we can't tell if focus is about to be
    // placed or not.
    view.focusOut = function(evt) {
      var self = this;
      this.save(evt.target);

      this.saveAfterBlurTimeout = setTimeout(function() {
        clearTimeout(self.saveAfterBlurTimeout);
        self.onClose();
      }, 1);
      
      this.checkInvalid();
    },

    view.save = function(node) {

      if (node) {
        var target = $(node);
        var value = parseFloat(target.attr('value'));
        var step = (this.$('.slider_interval').attr('value') === '') ? 0 : this.slider.step;

        if (target.hasClass('slider_min')) {

          // set the new min
          if (value < this.slider.max && this.slider.max - value > step) {
            this.slider.setProperty('min', value);

          // reset the value since it's invalid
          } else {
            target.attr('value', this.slider.min);
          }

        } else if (target.hasClass('slider_max')) {

          // set the new min
          if (value > this.slider.min && value - this.slider.min > step) {
            this.slider.setProperty('max', value);

          // reset the value since it's invalid
          } else {
            target.attr('value', this.slider.max);
          }

        } else if (target.hasClass('slider_interval')) {
          // set the new step interval
          if (value >= 0 && value < this.slider.max - this.slider.min) {
            this.slider.setProperty('step', value);
          } else if (target.attr('value') === '') {
            // This happens when someone enters a 'blank' step, e.g. deletes the value
            this.slider.setProperty('step', undefined);
          } else {
            // invalid step intervals get reset.
            if (step === undefined) {
              target.attr('value', '');
            } else {
              target.attr('value', this.slider.step);
            }
          }
        }
      }
    };

    view.onClose = function() {
      this.setProperty('editing', false);
    };

    view.onEditMin = function(evt) {
      this.setProperty('editing', true);
      evt.preventDefault();
      this.$('.slider_min').focus().select();
    };

    view.onEditMax = function(evt) {
      this.setProperty('editing', true);
      evt.preventDefault();
      this.$('.slider_max').focus().select();
    };

    view.renderIsPlaying = function () {
      if (this.slider.step < 0) {
        this.slider.setProperty('isPlaying', false);
        return;
      }
      this.parentView.$().toggleClass('isPlaying', !!this.slider.isPlaying);
    };

  });
  
  return SliderView;
});

define('template!prompt_sliders', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="create_sliders action-createslider" handleEvent="true">\n  <span class="msg">'+
( t('add slider:') )+
'</span>\n  <span class="btns">\n    ';
 _.each(variables, function (variable) { 
;__p+='\n      <div class="slider_btn_container" var_name="'+
( variable.name )+
'" >\n        <div class="btn btn-primary btn-small">'+
( variable.label )+
'</div>\n      </div>\n    ';
 }) 
;__p+='\n              \n    ';
 if (variables.length > 1) { 
;__p+='\n      <div class="slider_btn_container all">\n        <div class="btn btn-small btn-success all">all!</div>\n      </div>\n    ';
 } 
;__p+='\n  </span>\n</div>';
}
return __p;
};});
define('expressions/promptslider_view',['require','jquery','pjs','lib/underscore_view','main/focus','template!prompt_sliders'],function(require) {
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var Focus = require('main/focus');
  var template = require('template!prompt_sliders');

  var PromptSliderView = P(UnderscoreView, function (view, _super) {

    view.template = template;
    
    view.init = function (expressionView) {
      _super.init.call(this);
      
      this.variables = [];
      this.expressionView = expressionView;
      this.observe('variables', this.rerender.bind(this));
    };
    
    view.didInsertElement = function () {
      this.$('.action-createslider').on('tap', this.onCreateSlider.bind(this));
    };
    
    view.getTemplateParams = function () {
      var vars = this.variables;
      var formattedVariables = [];
      for (var i=0; i<4 && i<vars.length; i++) {
        var v = vars[i];
        var vName, vHtml = v.split('{').join('').split('}').join('').split('_');
        
        if (vHtml.length > 1) {
          vName = vHtml[0] + "_{" + vHtml[1] + "}";
          vHtml = vHtml[0] + "<sub>" + vHtml[1] + "</sub>";
        } else {
          vName = vHtml[0];
          vHtml = vHtml[0];
        }
        
        formattedVariables.push({ name:vName, label:vHtml });
      }

      return {variables: formattedVariables};
    };

    view.onCreateSlider = function(evt) {

      // this action feels like it should defocus expressions
      Focus.takeFocus();

      var dom = $(evt.target).closest('.slider_btn_container');
      if (!dom.length) return;

      var vars;
      if (dom.hasClass('all')) {
        vars = this.variables.slice();
      } else {
        vars = [dom.attr('var_name')];
      }

      if (!vars.length) return;

      this.expressionView.createSliders(vars);
    };
    
  });

  return PromptSliderView;
});

define('loadcss!vendor_css/mathquill/mathquill', function(){});
/**
 * Copyleft 2010-2011 Jay and Han (laughinghan@gmail.com)
 *   under the GNU Lesser General Public License
 *     http://www.gnu.org/licenses/lgpl.html
 * Project Website: http://mathquill.com
 */

(function() {

var $ = jQuery,
  undefined,
  _, //temp variable of prototypes
  mqCmdId = 'mathquill-command-id',
  mqBlockId = 'mathquill-block-id',
  min = Math.min,
  max = Math.max;

var __slice = [].slice;

function noop() {}

/**
 * sugar to make defining lots of commands easier.
 * TODO: rethink this.
 */
function bind(cons /*, args... */) {
  var args = __slice.call(arguments, 1);
  return function() {
    return cons.apply(this, args);
  };
}

/**
 * a development-only debug method.  This definition and all
 * calls to `pray` will be stripped from the minified
 * build of mathquill.
 *
 * This function must be called by name to be removed
 * at compile time.  Do not define another function
 * with the same name, and only call this function by
 * name.
 */
function pray(message, cond) {
  if (!cond) throw new Error('prayer failed: '+message);
}
var P = (function(prototype, ownProperty, undefined) {
  // helper functions that also help minification
  function isObject(o) { return typeof o === 'object'; }
  function isFunction(f) { return typeof f === 'function'; }

  function P(_superclass /* = Object */, definition) {
    // handle the case where no superclass is given
    if (definition === undefined) {
      definition = _superclass;
      _superclass = Object;
    }

    // C is the class to be returned.
    // There are three ways C will be called:
    //
    // 1) We call `new C` to create a new uninitialized object.
    //    The behavior is similar to Object.create, where the prototype
    //    relationship is set up, but the ::init method is not run.
    //    Note that in this case we have `this instanceof C`, so we don't
    //    spring the first trap. Also, `args` is undefined, so the initializer
    //    doesn't get run.
    //
    // 2) A user will simply call C(a, b, c, ...) to create a new object with
    //    initialization.  This allows the user to create objects without `new`,
    //    and in particular to initialize objects with variable arguments, which
    //    is impossible with the `new` keyword.  Note that in this case,
    //    !(this instanceof C) springs the return trap at the beginning, and
    //    C is called with the `new` keyword and one argument, which is the
    //    Arguments object passed in.
    //
    // 3) For internal use only, if new C(args) is called, where args is an
    //    Arguments object.  In this case, the presence of `new` means the
    //    return trap is not sprung, but the initializer is called if present.
    //
    //    You can also call `new C([a, b, c])`, which is equivalent to `C(a, b, c)`.
    //
    //  TODO: the Chrome inspector shows all created objects as `C` rather than `Object`.
    //        Setting the .name property seems to have no effect.  Is there a way to override
    //        this behavior?
    function C(args) {
      var self = this;
      if (!(self instanceof C)) return new C(arguments);
      if (args && isFunction(self.init)) self.init.apply(self, args);
    }

    // set up the prototype of the new class
    // note that this resolves to `new Object`
    // if the superclass isn't given
    var proto = C[prototype] = new _superclass();

    // other variables, as a minifier optimization
    var _super = _superclass[prototype];
    var extensions;

    // set the constructor property on the prototype, for convenience
    proto.constructor = C;

    C.mixin = function(def) {
      C[prototype] = P(C, def)[prototype];
      return C;
    }

    return (C.open = function(def) {
      extensions = {};

      if (isFunction(def)) {
        // call the defining function with all the arguments you need
        // extensions captures the return value.
        extensions = def.call(C, proto, _super, C, _superclass);
      }
      else if (isObject(def)) {
        // if you passed an object instead, we'll take it
        extensions = def;
      }

      // ...and extend it
      if (isObject(extensions)) {
        for (var ext in extensions) {
          if (ownProperty.call(extensions, ext)) {
            proto[ext] = extensions[ext];
          }
        }
      }

      // if there's no init, we assume we're inheriting a non-pjs class, so
      // we default to applying the superclass's constructor.
      if (!isFunction(proto.init)) {
        proto.init = function() { _superclass.apply(this, arguments); };
      }

      return C;
    })(definition);
  }

  // ship it
  return P;

  // as a minifier optimization, we've closured in a few helper functions
  // and the string 'prototype' (C[p] is much shorter than C.prototype)
})('prototype', ({}).hasOwnProperty);
/*************************************************
 * Textarea Manager
 *
 * An abstraction layer wrapping the textarea in
 * an object with methods to manipulate and listen
 * to events on, that hides all the nasty cross-
 * browser incompatibilities behind a uniform API.
 *
 * Design goal: This is a *HARD* internal
 * abstraction barrier. Cross-browser
 * inconsistencies are not allowed to leak through
 * and be dealt with by event handlers. All future
 * cross-browser issues that arise must be dealt
 * with here, and if necessary, the API updated.
 *
 * Organization:
 * - key values map and stringify()
 * - manageTextarea()
 *    + defer() and flush()
 *    + event handler logic
 *    + attach event handlers and export methods
 ************************************************/

var manageTextarea = (function() {
  // The following [key values][1] map was compiled from the
  // [DOM3 Events appendix section on key codes][2] and
  // [a widely cited report on cross-browser tests of key codes][3],
  // except for 10: 'Enter', which I've empirically observed in Safari on iOS
  // and doesn't appear to conflict with any other known key codes.
  //
  // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues
  // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
  // [3]: http://unixpapa.com/js/key.html
  var KEY_VALUES = {
    8: 'Backspace',
    9: 'Tab',

    10: 'Enter', // for Safari on iOS

    13: 'Enter',

    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',

    27: 'Esc',

    32: 'Spacebar',

    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',

    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',

    45: 'Insert',

    46: 'Del',

    144: 'NumLock'
  };

  // To the extent possible, create a normalized string representation
  // of the key combo (i.e., key code and modifier keys).
  function stringify(evt) {
    var which = evt.which || evt.keyCode;
    var keyVal = KEY_VALUES[which];
    var key;
    var modifiers = [];

    if (evt.ctrlKey) modifiers.push('Ctrl');
    if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');
    if (evt.altKey) modifiers.push('Alt');
    if (evt.shiftKey) modifiers.push('Shift');

    key = keyVal || String.fromCharCode(which);

    if (!modifiers.length && !keyVal) return key;

    modifiers.push(key);
    return modifiers.join('-');
  }

  // create a textarea manager that calls callbacks at useful times
  // and exports useful public methods
  return function manageTextarea(el, opts) {
    if (!el.is('textarea')) return { select: noop };
    var keydown = null;
    var keypress = null;

    if (!opts) opts = {};
    var textCallback = opts.text || noop;
    var keyCallback = opts.key || noop;
    var pasteCallback = opts.paste || noop;
    var onCut = opts.cut || noop;

    var textarea = $(el);
    var target = $(opts.container || textarea);

    // defer() runs fn immediately after the current thread.
    // flush() will run it even sooner, if possible.
    // flush always needs to be called before defer, and is called a
    // few other places besides.
    var timeout, deferredFn;

    function defer(fn) {
      timeout = setTimeout(fn);
      deferredFn = fn;
    }

    function flush() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = undefined;
        deferredFn();
      }
    }

    target.bind('keydown keypress input keyup focusout paste', flush);


    // -*- public methods -*- //
    function select(text) {
      flush();

      textarea.val(text);
      if (text) textarea[0].select();
    }

    // -*- helper subroutines -*- //

    // Determine whether there's a selection in the textarea.
    // This will always return false in IE < 9, which don't support
    // HTMLTextareaElement::selection{Start,End}.
    function hasSelection() {
      var dom = textarea[0];

      if (!('selectionStart' in dom)) return false;
      return dom.selectionStart !== dom.selectionEnd;
    }

    function popText(callback) {
      var text = textarea.val();
      textarea.val('');
      if (text) callback(text);
    }

    function handleKey() {
      keyCallback(stringify(keydown), keydown);
    }

    // -*- event handlers -*- //
    function onKeydown(e) {
      keydown = e;
      keypress = null;

      handleKey();
    }

    function onKeypress(e) {
      // call the key handler for repeated keypresses.
      // This excludes keypresses that happen directly
      // after keydown.  In that case, there will be
      // no previous keypress, so we skip it here
      if (keydown && keypress) handleKey();

      keypress = e;

      defer(function() {
        // If there is a selection, the contents of the textarea couldn't
        // possibly have just been typed in.
        // This happens in browsers like Firefox and Opera that fire
        // keypress for keystrokes that are not text entry and leave the
        // selection in the textarea alone, such as Ctrl-C.
        // Note: we assume that browsers that don't support hasSelection()
        // also never fire keypress on keystrokes that are not text entry.
        // This seems reasonably safe because:
        // - all modern browsers including IE 9+ support hasSelection(),
        //   making it extremely unlikely any browser besides IE < 9 won't
        // - as far as we know IE < 9 never fires keypress on keystrokes
        //   that aren't text entry, which is only as reliable as our
        //   tests are comprehensive, but the IE < 9 way to do
        //   hasSelection() is poorly documented and is also only as
        //   reliable as our tests are comprehensive
        // If anything like #40 or #71 is reported in IE < 9, see
        // b1318e5349160b665003e36d4eedd64101ceacd8

        //updated by Eli
        //in Safari, when text is selected inside of the textarea
        //and then a key is pressed, there's a brief moment where
        //the new text is selected. This circumvents that problem, by
        //trying again a moment later
        //this should be a no-op except in Safari
        //NOTE / TODO: this still seems to introduce a problem with vertical
        //alignment. In DCG, try:
        // * type "1"
        // * highlight the "1"
        // * type "/"
        // note that vertical alignment of the icon is broken
        // it's only fixed when another action is taken that changes
        // vertical alignment (i.e. a division inside of one of the
        // division signs)
        if (hasSelection()) {
          setTimeout(function() {
            if (!hasSelection())
              popText(textCallback);
          });
        } else {
          popText(textCallback);
        }

        if (hasSelection()) return;

        popText(textCallback);
      });
    }

    function onBlur() { keydown = keypress = null; }

    function onPaste(e) {
      // browsers are dumb.
      //
      // In Linux, middle-click pasting causes onPaste to be called,
      // when the textarea is not necessarily focused.  We focus it
      // here to ensure that the pasted text actually ends up in the
      // textarea.
      //
      // It's pretty nifty that by changing focus in this handler,
      // we can change the target of the default action.  (This works
      // on keydown too, FWIW).
      //
      // And by nifty, we mean dumb (but useful sometimes).
      textarea.focus();

      defer(function() {
        popText(pasteCallback);
      });
    }

    // -*- attach event handlers -*- //
    target.bind({
      keydown: onKeydown,
      keypress: onKeypress,
      focusout: onBlur,
      cut: onCut,
      paste: onPaste
    });

    // -*- export public methods -*- //
    return {
      select: select
    };
  };
}());
var Parser = P(function(_, _super, Parser) {
  // The Parser object is a wrapper for a parser function.
  // Externally, you use one to parse a string by calling
  //   var result = SomeParser.parse('Me Me Me! Parse Me!');
  // You should never call the constructor, rather you should
  // construct your Parser from the base parsers and the
  // parser combinator methods.

  function parseError(stream, message) {
    if (stream) {
      stream = "'"+stream+"'";
    }
    else {
      stream = 'EOF';
    }

    throw 'Parse Error: '+message+' at '+stream;
  }

  _.init = function(body) { this._ = body; };

  _.parse = function(stream) {
    return this.skip(eof)._(stream, success, parseError);

    function success(stream, result) { return result; }
  };

  // -*- primitive combinators -*- //
  _.or = function(alternative) {
    pray('or is passed a parser', alternative instanceof Parser);

    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      return self._(stream, onSuccess, failure);

      function failure(newStream) {
        return alternative._(stream, onSuccess, onFailure);
      }
    });
  };

  _.then = function(next) {
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      return self._(stream, success, onFailure);

      function success(newStream, result) {
        var nextParser = (next instanceof Parser ? next : next(result));
        pray('a parser is returned', nextParser instanceof Parser);
        return nextParser._(newStream, onSuccess, onFailure);
      }
    });
  };

  // -*- optimized iterative combinators -*- //
  _.many = function() {
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      var xs = [];
      while (self._(stream, success, failure));
      return onSuccess(stream, xs);

      function success(newStream, x) {
        stream = newStream;
        xs.push(x);
        return true;
      }

      function failure() {
        return false;
      }
    });
  };

  _.times = function(min, max) {
    if (arguments.length < 2) max = min;
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      var xs = [];
      var result = true;
      var failure;

      for (var i = 0; i < min; i += 1) {
        result = self._(stream, success, firstFailure);
        if (!result) return onFailure(stream, failure);
      }

      for (; i < max && result; i += 1) {
        result = self._(stream, success, secondFailure);
      }

      return onSuccess(stream, xs);

      function success(newStream, x) {
        xs.push(x);
        stream = newStream;
        return true;
      }

      function firstFailure(newStream, msg) {
        failure = msg;
        stream = newStream;
        return false;
      }

      function secondFailure(newStream, msg) {
        return false;
      }
    });
  };

  // -*- higher-level combinators -*- //
  _.result = function(res) { return this.then(succeed(res)); };
  _.atMost = function(n) { return this.times(0, n); };
  _.atLeast = function(n) {
    var self = this;
    return self.times(n).then(function(start) {
      return self.many().map(function(end) {
        return start.concat(end);
      });
    });
  };

  _.map = function(fn) {
    return this.then(function(result) { return succeed(fn(result)); });
  };

  _.skip = function(two) {
    return this.then(function(result) { return two.result(result); });
  };

  // -*- primitive parsers -*- //
  var string = this.string = function(str) {
    var len = str.length;
    var expected = "expected '"+str+"'";

    return Parser(function(stream, onSuccess, onFailure) {
      var head = stream.slice(0, len);

      if (head === str) {
        return onSuccess(stream.slice(len), head);
      }
      else {
        return onFailure(stream, expected);
      }
    });
  };

  var regex = this.regex = function(re) {
    pray('regexp parser is anchored', re.toString().charAt(1) === '^');

    var expected = 'expected '+re;

    return Parser(function(stream, onSuccess, onFailure) {
      var match = re.exec(stream);

      if (match) {
        var result = match[0];
        return onSuccess(stream.slice(result.length), result);
      }
      else {
        return onFailure(stream, expected);
      }
    });
  };

  var succeed = Parser.succeed = function(result) {
    return Parser(function(stream, onSuccess) {
      return onSuccess(stream, result);
    });
  };

  var fail = Parser.fail = function(msg) {
    return Parser(function(stream, _, onFailure) {
      return onFailure(stream, msg);
    });
  };

  var letter = Parser.letter = regex(/^[a-z]/i);
  var letters = Parser.letters = regex(/^[a-z]*/i);
  var digit = Parser.digit = regex(/^[0-9]/);
  var digits = Parser.digits = regex(/^[0-9]*/);
  var whitespace = Parser.whitespace = regex(/^\s+/);
  var optWhitespace = Parser.optWhitespace = regex(/^\s*/);

  var any = Parser.any = Parser(function(stream, onSuccess, onFailure) {
    if (!stream) return onFailure(stream, 'expected any character');

    return onSuccess(stream.slice(1), stream.charAt(0));
  });

  var all = Parser.all = Parser(function(stream, onSuccess, onFailure) {
    return onSuccess('', stream);
  });

  var eof = Parser.eof = Parser(function(stream, onSuccess, onFailure) {
    if (stream) return onFailure(stream, 'expected EOF');

    return onSuccess(stream, stream);
  });
});
/*************************************************
 * Base classes of the MathQuill virtual DOM tree
 *
 * Only doing tree node manipulation via these
 * adopt/ disown methods guarantees well-formedness
 * of the tree.
 ************************************************/

/**
 * MathQuill virtual-DOM tree-node abstract base class
 */
var Node = P(function(_) {
  _.prev = 0;
  _.next = 0;
  _.parent = 0;
  _.firstChild = 0;
  _.lastChild = 0;

  _.children = function() {
    return Fragment(this.firstChild, this.lastChild);
  };

  _.eachChild = function(fn) {
    return this.children().each(fn);
  };

  _.foldChildren = function(fold, fn) {
    return this.children().fold(fold, fn);
  };

  _.adopt = function(parent, prev, next) {
    Fragment(this, this).adopt(parent, prev, next);
    return this;
  };

  _.disown = function() {
    Fragment(this, this).disown();
    return this;
  };
});

/**
 * An entity outside the virtual tree with one-way pointers (so it's only a
 * "view" of part of the tree, not an actual node/entity in the tree) that
 * delimits a doubly-linked list of sibling nodes.
 * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range
 * classes: like DocumentFragment, its contents must be sibling nodes
 * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),
 * but like Range, it has only one-way pointers to its contents, its contents
 * have no reference to it and in fact may still be in the visible tree (unlike
 * DocumentFragment, whose contents must be detached from the visible tree
 * and have their 'parent' pointers set to the DocumentFragment).
 */
var Fragment = P(function(_) {
  _.first = 0;
  _.last = 0;

  _.init = function(first, last) {
    pray('no half-empty fragments', !first === !last);

    if (!first) return;

    pray('first node is passed to Fragment', first instanceof Node);
    pray('last node is passed to Fragment', last instanceof Node);
    pray('first and last have the same parent',
         first.parent === last.parent);

    this.first = first;
    this.last = last;
  };

  function prayWellFormed(parent, prev, next) {
    pray('a parent is always present', parent);
    pray('prev is properly set up', (function() {
      // either it's empty and next is the first child (possibly empty)
      if (!prev) return parent.firstChild === next;

      // or it's there and its next and parent are properly set up
      return prev.next === next && prev.parent === parent;
    })());

    pray('next is properly set up', (function() {
      // either it's empty and prev is the last child (possibly empty)
      if (!next) return parent.lastChild === prev;

      // or it's there and its next and parent are properly set up
      return next.prev === prev && next.parent === parent;
    })());
  }

  _.adopt = function(parent, prev, next) {
    prayWellFormed(parent, prev, next);

    var self = this;
    self.disowned = false;

    var first = self.first;
    if (!first) return this;

    var last = self.last;

    if (prev) {
      // NB: this is handled in the ::each() block
      // prev.next = first
    } else {
      parent.firstChild = first;
    }

    if (next) {
      next.prev = last;
    } else {
      parent.lastChild = last;
    }

    self.last.next = next;

    self.each(function(el) {
      el.prev = prev;
      el.parent = parent;
      if (prev) prev.next = el;

      prev = el;
    });

    return self;
  };

  _.disown = function() {
    var self = this;
    var first = self.first;

    // guard for empty and already-disowned fragments
    if (!first || self.disowned) return self;

    self.disowned = true;

    var last = self.last;
    var parent = first.parent;

    prayWellFormed(parent, first.prev, first);
    prayWellFormed(parent, last, last.next);

    if (first.prev) {
      first.prev.next = last.next;
    } else {
      parent.firstChild = last.next;
    }

    if (last.next) {
      last.next.prev = first.prev;
    } else {
      parent.lastChild = first.prev;
    }

    return self;
  };

  _.each = function(fn) {
    var self = this;
    var el = self.first;
    if (!el) return self;

    for (;el !== self.last.next; el = el.next) {
      if (fn.call(self, el) === false) break;
    }

    return self;
  };

  _.fold = function(fold, fn) {
    this.each(function(el) {
      fold = fn.call(this, fold, el);
    });

    return fold;
  };
});
/*************************************************
 * Abstract classes of math blocks and commands.
 ************************************************/

var uuid = (function() {
  var id = 0;

  return function() { return id += 1; };
})();

/**
 * Math tree node base class.
 * Some math-tree-specific extensions to Node.
 * Both MathBlock's and MathCommand's descend from it.
 */
var MathElement = P(Node, function(_) {
  _.init = function(obj) {
    this.id = uuid();
    MathElement[this.id] = this;
  };

  _.toString = function() {
    return '[MathElement '+this.id+']';
  };

  _.bubble = function(event /*, args... */) {
    var args = __slice.call(arguments, 1);

    for (var ancestor = this; ancestor; ancestor = ancestor.parent) {
      var res = ancestor[event] && ancestor[event].apply(ancestor, args);
      if (res === false) break;
    }

    return this;
  };

  _.postOrder = function(fn /*, args... */) {
    if (typeof fn === 'string') {
      var methodName = fn;
      fn = function(el) {
        if (methodName in el) el[methodName].apply(el, arguments);
      };
    }

    (function recurse(desc) {
      desc.eachChild(recurse);
      fn(desc);
    })(this);
  };

  _.jQ = $();
  _.jQadd = function(jQ) { this.jQ = this.jQ.add(jQ); };

  this.jQize = function(html) {
    // Sets the .jQ of the entire math subtree rooted at this command.
    // Expects .createBlocks() to have been called already, since it
    // calls .html().
    var jQ = $(html);

    function jQadd(el) {
      if (el.getAttribute) {
        var cmdId = el.getAttribute('mathquill-command-id');
        var blockId = el.getAttribute('mathquill-block-id');
        if (cmdId) MathElement[cmdId].jQadd(el);
        if (blockId) MathElement[blockId].jQadd(el);
      }
    }
    function traverse(el) {
      for (el = el.firstChild; el; el = el.nextSibling) {
        jQadd(el);
        if (el.firstChild) traverse(el);
      }
    }

    for (var i = 0; i < jQ.length; i += 1) {
      jQadd(jQ[i]);
      traverse(jQ[i]);
    }
    return jQ;
  };

  _.finalizeInsert = function() {
    var self = this;
    self.postOrder('finalizeTree');

    // note: this order is important.
    // empty elements need the empty box provided by blur to
    // be present in order for their dimensions to be measured
    // correctly in redraw.
    self.postOrder('blur');

    // adjust context-sensitive spacing
    self.postOrder('respace');
    if (self.next.respace) self.next.respace();
    if (self.prev.respace) self.prev.respace();

    self.postOrder('redraw');
    self.bubble('redraw');
    self.bubble('redraw');
  };

  _.seek = function(cursor, clientX, clientY, root, clientRect) {
    var frontier = [];
    function popClosest() {
      var iClosest, minSqDist = Infinity;
      for (var i = 0; i < frontier.length; i += 1) {
        if (!frontier[i]) continue;
        var sqDist = frontier[i].sqDist;
        if (sqDist < minSqDist) iClosest = i, minSqDist = sqDist;
      }
      var closest = frontier[iClosest];
      frontier[iClosest] = null;
      return closest;
    }
    function seekPoint(node) {
      var pt = node.seekPoint(clientX, clientY, clientRect);
      if (!pt) return;
      var dx = clientX - pt.x, dy = clientY - pt.y;
      frontier.push({ point: pt, sqDist: dx*dx + dy*dy });
    }
    function addNode(node) {
      if (!node) return;
      var rect = clientRect(node);
      var closestX = max(rect.left, min(rect.right, clientX));
      var closestY = max(rect.top, min(rect.bottom, clientY));
      var dx = clientX - closestX, dy = clientY - closestY;
      frontier.push({ node: node, sqDist: dx*dx + dy*dy });
    }
    function addContainer(node) {
      if (node === root) return; // no potential Points outside root container
      var rect = clientRect(node);
      var dist = max(0, min(clientX - rect.left, clientY - rect.top,
                            rect.right - clientX, rect.bottom - clientY));
      frontier.push({ container: node, sqDist: dist * dist });
    }

    seekPoint(this);
    this.eachChild(addNode);
    addContainer(this);
    for (var closest = popClosest(); !closest.point; closest = popClosest()) {
      if (closest.container) {
        var container = closest.container, outer = container.parent;
        seekPoint(outer);
        outer.eachChild(function(n) { if (n !== container) addNode(n); });
        addContainer(outer);
      }
      else {
        seekPoint(closest.node);
        closest.node.eachChild(addNode);
      }
    }
    if (closest.point.next) cursor.insertBefore(closest.point.next)
    else cursor.appendTo(closest.point.parent);
  };
});

/**
 * Commands and operators, like subscripts, exponents, or fractions.
 * Descendant commands are organized into blocks.
 */
var MathCommand = P(MathElement, function(_, _super) {
  _.init = function(ctrlSeq, htmlTemplate, textTemplate) {
    var cmd = this;
    _super.init.call(cmd);

    if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;
    if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;
    if (textTemplate) cmd.textTemplate = textTemplate;
  };

  // obvious methods
  _.replaces = function(replacedFragment) {
    replacedFragment.disown();
    this.replacedFragment = replacedFragment;
  };
  _.isEmpty = function() {
    return this.foldChildren(true, function(isEmpty, child) {
      return isEmpty && child.isEmpty();
    });
  };

  _.parser = function() {
    var block = latexMathParser.block;
    var self = this;

    return block.times(self.numBlocks()).map(function(blocks) {
      self.blocks = blocks;

      for (var i = 0; i < blocks.length; i += 1) {
        blocks[i].adopt(self, self.lastChild, 0);
      }

      return self;
    });
  };

  // createBefore(cursor) and the methods it calls
  _.createBefore = function(cursor) {
    var cmd = this;
    var replacedFragment = cmd.replacedFragment;

    cmd.createBlocks();
    MathElement.jQize(cmd.html());
    if (replacedFragment) {
      replacedFragment.adopt(cmd.firstChild, 0, 0);
      replacedFragment.jQ.appendTo(cmd.firstChild.jQ);
    }

    cursor.jQ.before(cmd.jQ);
    cursor.prev = cmd.adopt(cursor.parent, cursor.prev, cursor.next);

    cmd.finalizeInsert(cursor);

    cmd.placeCursor(cursor);
  };
  _.createBlocks = function() {
    var cmd = this,
      numBlocks = cmd.numBlocks(),
      blocks = cmd.blocks = Array(numBlocks);

    for (var i = 0; i < numBlocks; i += 1) {
      var newBlock = blocks[i] = MathBlock();
      newBlock.adopt(cmd, cmd.lastChild, 0);
    }
  };
  _.respace = noop; //placeholder for context-sensitive spacing
  _.placeCursor = function(cursor) {
    //append the cursor to the first empty child, or if none empty, the last one
    cursor.appendTo(this.foldChildren(this.firstChild, function(prev, child) {
      return prev.isEmpty() ? prev : child;
    }));
  };

  _.seekPoint = noop;
  _.expectedCursorYNextTo = function(clientRect) {
    return this.firstChild.expectedCursorYInside(clientRect);
  };

  // remove()
  _.remove = function() {
    this.disown()
    this.jQ.remove();

    this.postOrder(function(el) { delete MathElement[el.id]; });

    return this;
  };

  // methods involved in creating and cross-linking with HTML DOM nodes
  /*
    They all expect an .htmlTemplate like
      '<span>&0</span>'
    or
      '<span><span>&0</span><span>&1</span></span>'

    See html.test.js for more examples.

    Requirements:
    - For each block of the command, there must be exactly one "block content
      marker" of the form '&<number>' where <number> is the 0-based index of the
      block. (Like the LaTeX \newcommand syntax, but with a 0-based rather than
      1-based index, because JavaScript because C because Dijkstra.)
    - The block content marker must be the sole contents of the containing
      element, there can't even be surrounding whitespace, or else we can't
      guarantee sticking to within the bounds of the block content marker when
      mucking with the HTML DOM.
    - The HTML not only must be well-formed HTML (of course), but also must
      conform to the XHTML requirements on tags, specifically all tags must
      either be self-closing (like '<br/>') or come in matching pairs.
      Close tags are never optional.

    Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',
    your HTML template would have to have '&amp;123'.
  */
  _.numBlocks = function() {
    var matches = this.htmlTemplate.match(/&\d+/g);
    return matches ? matches.length : 0;
  };
  _.html = function() {
    // Render the entire math subtree rooted at this command, as HTML.
    // Expects .createBlocks() to have been called already, since it uses the
    // .blocks array of child blocks.
    //
    // See html.test.js for example templates and intended outputs.
    //
    // Given an .htmlTemplate as described above,
    // - insert the mathquill-command-id attribute into all top-level tags,
    //   which will be used to set this.jQ in .jQize().
    //   This is straightforward:
    //     * tokenize into tags and non-tags
    //     * loop through top-level tokens:
    //         * add #cmdId attribute macro to top-level self-closing tags
    //         * else add #cmdId attribute macro to top-level open tags
    //             * skip the matching top-level close tag and all tag pairs
    //               in between
    // - for each block content marker,
    //     + replace it with the contents of the corresponding block,
    //       rendered as HTML
    //     + insert the mathquill-block-id attribute into the containing tag
    //   This is even easier, a quick regex replace, since block tags cannot
    //   contain anything besides the block content marker.
    //
    // Two notes:
    // - The outermost loop through top-level tokens should never encounter any
    //   top-level close tags, because we should have first encountered a
    //   matching top-level open tag, all inner tags should have appeared in
    //   matching pairs and been skipped, and then we should have skipped the
    //   close tag in question.
    // - All open tags should have matching close tags, which means our inner
    //   loop should always encounter a close tag and drop nesting to 0. If
    //   a close tag is missing, the loop will continue until i >= tokens.length
    //   and token becomes undefined. This will not infinite loop, even in
    //   production without pray(), because it will then TypeError on .slice().

    var cmd = this;
    var blocks = cmd.blocks;
    var cmdId = ' mathquill-command-id=' + cmd.id;
    var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);

    pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);

    // add cmdId to all top-level tags
    for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {
      // top-level self-closing tags
      if (token.slice(-2) === '/>') {
        tokens[i] = token.slice(0,-2) + cmdId + '/>';
      }
      // top-level open tags
      else if (token.charAt(0) === '<') {
        pray('not an unmatched top-level close tag', token.charAt(1) !== '/');

        tokens[i] = token.slice(0,-1) + cmdId + '>';

        // skip matching top-level close tag and all tag pairs in between
        var nesting = 1;
        do {
          i += 1, token = tokens[i];
          pray('no missing close tags', token);
          // close tags
          if (token.slice(0,2) === '</') {
            nesting -= 1;
          }
          // non-self-closing open tags
          else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {
            nesting += 1;
          }
        } while (nesting > 0);
      }
    }
    return tokens.join('').replace(/>&(\d+)/g, function($0, $1) {
      return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');
    });
  };

  // methods to export a string representation of the math tree
  _.latex = function() {
    return this.foldChildren(this.ctrlSeq, function(latex, child) {
      return latex + '{' + (child.latex() || ' ') + '}';
    });
  };
  _.textTemplate = [''];
  _.text = function() {
    var i = 0;
    return this.foldChildren(this.textTemplate[i], function(text, child) {
      i += 1;
      var child_text = child.text();
      if (text && this.textTemplate[i] === '('
          && child_text[0] === '(' && child_text.slice(-1) === ')')
        return text + child_text.slice(1, -1) + this.textTemplate[i];
      return text + child.text() + (this.textTemplate[i] || '');
    });
  };
});

/**
 * Lightweight command without blocks or children.
 */
var Symbol = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, html, text) {
    if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;

    _super.init.call(this, ctrlSeq, html, [ text ]);
  };

  _.parser = function() { return Parser.succeed(this); };
  _.numBlocks = function() { return 0; };

  _.replaces = function(replacedFragment) {
    replacedFragment.remove();
  };
  _.createBlocks = noop;

  _.seek = function(cursor, clientX, clientY, root, clientRect) {
    var rect = clientRect(this), left = rect.left, right = rect.right;
    // insert at whichever side the click was closer to
    if (clientX - left < right - clientX) cursor.insertBefore(this);
    else cursor.insertAfter(this);
  };
  _.expectedCursorYNextTo = function(clientRect) {
    return (clientRect(this).top + clientRect(this).bottom)/2;
  };

  _.latex = function(){ return this.ctrlSeq; };
  _.text = function(){ return this.textTemplate; };
  _.placeCursor = noop;
  _.isEmpty = function(){ return true; };
});

/**
 * Children and parent of MathCommand's. Basically partitions all the
 * symbols and operators that descend (in the Math DOM tree) from
 * ancestor operators.
 */
var MathBlock = P(MathElement, function(_) {
  _.join = function(methodName) {
    return this.foldChildren('', function(fold, child) {
      return fold + child[methodName]();
    });
  };
  _.latex = function() { return this.join('latex'); };
  _.text = function() {
    return this.firstChild === this.lastChild ?
      this.firstChild.text() :
      '(' + this.join('text') + ')'
    ;
  };
  _.isEmpty = function() {
    return this.firstChild === 0 && this.lastChild === 0;
  };
  _.seekPoint = function(clientX, clientY, clientRect) {
    if (!this.firstChild) {
      var pt = { next: 0, x: (clientRect(this).left + clientRect(this).right)/2 };
    }
    else {
      function pointLeftOf(n) { return { next: n, x: clientRect(n).left }; }
      var pt = pointLeftOf(this.firstChild);
      if (clientX > pt.x) {
        pt = pointLeftOf(this.lastChild);
        var rightwardPt = { next: 0, x: clientRect(pt.next).right };
        while (clientX < pt.x) rightwardPt = pt, pt = pointLeftOf(pt.next.prev);
        if (rightwardPt.x - clientX < clientX - pt.x) pt = rightwardPt;
      }
    }
    return { parent: this, next: pt.next,
             x: pt.x, y: this.expectedCursorYInside(clientRect) };
  };
  _.expectedCursorYInside = function(clientRect) {
    if (this.firstChild) return this.firstChild.expectedCursorYNextTo(clientRect);
    else return (clientRect(this).top + clientRect(this).bottom)/2;
  };
  _.focus = function() {
    this.jQ.addClass('hasCursor');
    this.jQ.removeClass('empty');

    return this;
  };
  _.blur = function() {
    this.jQ.removeClass('hasCursor');
    if (this.isEmpty())
      this.jQ.addClass('empty');

    return this;
  };
});

/**
 * Math tree fragment base class.
 * Some math-tree-specific extensions to Fragment.
 */
var MathFragment = P(Fragment, function(_, _super) {
  _.init = function(first, last) {
    // just select one thing if only one argument
    _super.init.call(this, first, last || first);
    this.jQ = this.fold($(), function(jQ, child){ return child.jQ.add(jQ); });
  };
  _.latex = function() {
    return this.fold('', function(latex, el){ return latex + el.latex(); });
  };
  _.remove = function() {
    this.jQ.remove();

    this.each(function(el) {
      el.postOrder(function(desc) {
        delete MathElement[desc.id];
      });
    });

    return this.disown();
  };
});
/*********************************************
 * Root math elements with event delegation.
 ********************************************/

function createRoot(container, root, textbox, editable) {
  var contents = container.contents().detach();

  if (!textbox) {
    container.addClass('mathquill-rendered-math');
  }

  root.jQ = $('<span class="mathquill-root-block"/>').appendTo(container.attr(mqBlockId, root.id));
  root.revert = function() {
    container.empty().unbind('.mathquill')
      .removeClass('mathquill-rendered-math mathquill-editable mathquill-textbox')
      .append(contents);
  };

  var cursor = root.cursor = Cursor(root);

  root.renderLatex(contents.text());

  var is_ios = navigator.userAgent.match(/(iPad|iPhone|iPod)/i) !== null;
  var is_android = navigator.userAgent.match(/(Android|Silk|Kindle)/i) !== null;
  
  var textareaSpan = root.textarea = (is_ios || is_android) ?
      $('<span class="textarea"><span tabindex=0></span></span>')
    : $('<span class="textarea"><textarea></textarea></span>'),
    textarea = textareaSpan.children();

  /******
   * TODO [Han]: Document this
   */
  var textareaSelectionTimeout, prevLatex;
  root.selectionChanged = function() {
    if (textareaSelectionTimeout === undefined) {
      textareaSelectionTimeout = setTimeout(setTextareaSelection);
    }
    forceIERedraw(container[0]);
  };
  function setTextareaSelection() {
    textareaSelectionTimeout = undefined;
    var latex = cursor.selection ? '$'+cursor.selection.latex()+'$' : '';
    if (latex === prevLatex) return;
    textareaManager.select(latex);
    prevLatex = latex;
    root.triggerSpecialEvent('selectionChanged');
  }

  //prevent native selection except textarea
  container.bind('selectstart.mathquill', function(e) {
    if (e.target !== textarea[0]) e.preventDefault();
    e.stopPropagation();
  });

  //drag-to-select event handling
  var anticursor, blink = cursor.blink;
  container.bind('mousedown.mathquill', function(e) {
    e.preventDefault();

    if (root.ignoreMousedownTimeout !== undefined) {
      clearTimeout(root.ignoreMousedownTimeout);
      root.ignoreMousedownTimeout = undefined;
      return;
    }

    var cachedClientRect = cachedClientRectFnForNewCache();
    function mousemove(e) {
      cursor.seek($(e.target), e.clientX, e.clientY, cachedClientRect);

      if (cursor.prev !== anticursor.prev
          || cursor.parent !== anticursor.parent) {
        cursor.selectFrom(anticursor);
      }

      e.preventDefault();
    }

    // docmousemove is attached to the document, so that
    // selection still works when the mouse leaves the window.
    function docmousemove(e) {
      // [Han]: i delete the target because of the way seek works.
      // it will not move the mouse to the target, but will instead
      // just seek those X and Y coordinates.  If there is a target,
      // it will try to move the cursor to document, which will not work.
      // cursor.seek needs to be refactored.
      delete e.target;

      return mousemove(e);
    }

    function mouseup(e) {
      anticursor = undefined;
      cursor.blink = blink;
      if (!cursor.selection) {
        if (editable) {
          cursor.show();
        }
        else {
          textareaSpan.detach();
        }
      }

      // delete the mouse handlers now that we're not dragging anymore
      container.unbind('mousemove', mousemove);
      $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);
    }

    setTimeout(function() { if (root.blurred) textarea.focus(); });
      // preventDefault won't prevent focus on mousedown in IE<9
      // that means immediately after this mousedown, whatever was
      // mousedown-ed will receive focus
      // http://bugs.jquery.com/ticket/10345

    cursor.blink = noop;
    cursor.hideHandle().seek($(e.target), e.clientX, e.clientY, cachedClientRect);

    anticursor = {parent: cursor.parent, prev: cursor.prev, next: cursor.next};

    if (!editable) container.prepend(textareaSpan);

    container.mousemove(mousemove);
    $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);
  });

  // event handling for touch-draggable handle
  /**
   * Usage:
   * jQ.on('touchstart', firstFingerOnly(function(touchstartCoords) {
   *   return { // either of these are optional:
   *     touchmove: function(touchmoveCoords) {},
   *     touchend: function(touchendCoords) {}
   *   };
   * });
   */
  function firstFingerOnly(ontouchstart) {
    return function(e) {
      e.preventDefault();
      var e = e.originalEvent, target = $(e.target);
      if (e.changedTouches.length < e.touches.length) return; // not first finger
      var touchstart = e.changedTouches[0];
      var handlers = ontouchstart(touchstart) || 0;
      if (handlers.touchmove) {
        target.bind('touchmove', function(e) {
          var touchmove = e.originalEvent.changedTouches[0];
          if (touchmove.id !== touchstart.id) return;
          handlers.touchmove.call(this, touchmove);
        });
      }
      target.bind('touchend', function(e) {
        var touchend = e.originalEvent.changedTouches[0];
        if (touchend.id !== touchstart.id) return;
        if (handlers.touchend) handlers.touchend.call(this, touchend);
        target.unbind('touchmove touchend');
      });
    };
  }
  cursor.jQ.delegate('.handle', 'touchstart', firstFingerOnly(function(e) {
    cursor.blink = noop;
    var cursorRect = cursor.jQ[0].getBoundingClientRect();
    var offsetX = e.clientX - cursorRect.left;
    var offsetY = e.clientY - (cursorRect.top + cursorRect.bottom)/2;
    var cachedClientRect = cachedClientRectFnForNewCache();
    return {
      touchmove: function(e) {
        var adjustedX = e.clientX - offsetX, adjustedY = e.clientY - offsetY;
        cursor.seek(elAtPt(adjustedX, adjustedY, root), adjustedX, adjustedY, cachedClientRect, true);

        // visual "haptic" feedback
        var cursorRect = cursor.jQ[0].getBoundingClientRect();
        var dx = adjustedX - cursorRect.left;
        var dy = adjustedY - (cursorRect.top + cursorRect.bottom)/2;
        var dist = Math.sqrt(dx*dx + dy*dy);
        var weight = (Math.log(dist)+1)/dist;
        var skewX = Math.atan2(weight*dx, offsetY);
        var scaleY = (weight*dy + offsetY)/offsetY;
        var steeperScale = 2*(scaleY - 1) + 1;
        cursor.handle.css({
          WebkitTransform: 'translateX(.5px) skewX('+skewX+'rad) scaleY('+scaleY+')',
          opacity: 1 - steeperScale*.5
        });
      },
      touchend: function(e) {
        cursor.handle.css({ WebkitTransform: '', opacity: '' });
        cursor.blink = blink;
        cursor.show(true);
      }
    };
  }));

  if (!editable) {
    var textareaManager = manageTextarea(textarea, { container: container });
    container.bind('cut paste', false).bind('copy', setTextareaSelection)
      .prepend('<span class="selectable">$'+root.latex()+'$</span>');
    textarea.blur(function() {
      cursor.clearSelection();
      setTimeout(detach); //detaching during blur explodes in WebKit
    });
    function detach() {
      textareaSpan.detach();
    }
    return;
  }

  var textareaManager = manageTextarea(textarea, {
    container: container,
    key: function(key, evt) {
      cursor.parent.bubble('onKey', key, evt);
    },
    text: function(text) {
      cursor.parent.bubble('onText', text);
    },
    cut: function(e) {
      if (cursor.selection) {
        setTimeout(function() {
          cursor.prepareEdit();
          cursor.parent.bubble('redraw');
          root.triggerSpecialEvent('render');
        });
      }

      e.stopPropagation();
      root.triggerSpecialEvent('render');
    },
    paste: function(text) {
      // FIXME HACK the parser in RootTextBlock needs to be moved to
      // Cursor::writeLatex or something so this'll work with
      // MathQuill textboxes
      if (text.slice(0,1) === '$' && text.slice(-1) === '$') {
        text = text.slice(1, -1);
      }

      cursor.writeLatex(text).show();
      root.triggerSpecialEvent('render');
    }
  });

  container.prepend(textareaSpan);

  //root CSS classes
  container.addClass('mathquill-editable');
  if (textbox)
    container.addClass('mathquill-textbox');

  //focus and blur handling
  textarea.focus(function(e) {
    root.blurred = false;
    if (!cursor.parent)
      cursor.appendTo(root);
    cursor.parent.jQ.addClass('hasCursor');
    if (cursor.selection) {
      cursor.selection.jQ.removeClass('blur');
      setTimeout(root.selectionChanged); //re-select textarea contents after tabbing away and back
    }
    else
      cursor.show();
  }).blur(function(e) {
    root.blurred = true;
    cursor.hide().parent.blur();
    if (cursor.selection)
      cursor.selection.jQ.addClass('blur');
  }).blur();

  container.bind('select_all', function(e) {
    cursor.prepareMove().appendTo(root);
    while (cursor.prev) cursor.selectLeft();
  })
  .bind('custom_paste', function(e, text) {
    if (text.slice(0,1) === '$' && text.slice(-1) === '$') {
      text = text.slice(1, -1);
    }

    cursor.writeLatex(text).show();
    root.triggerSpecialEvent('render');
  });
}

function elAtPt(clientX, clientY, root) {
  var el = document.elementFromPoint(clientX, clientY);
  return $.contains(root.jQ[0], el) ? $(el) : root.jQ;
}
function cachedClientRectFnForNewCache() {
  var cache = {};
  function elById(el, id) {
    return cache[id] || (cache[id] = el.getBoundingClientRect());
  };
  function cachedClientRect(node) { return elById(node.jQ[0], node.id); };
  cachedClientRect.elById = elById;
  return cachedClientRect;
}

var RootMathBlock = P(MathBlock, function(_, _super) {
  _.latex = function() {
    return _super.latex.call(this).replace(/(\\[a-z]+) (?![a-z])/ig,'$1');
  };
  _.text = function() {
    return this.foldChildren('', function(text, child) {
      return text + child.text();
    });
  };
  _.renderLatex = function(latex) {
    var all = Parser.all;
    var eof = Parser.eof;

    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);
    this.firstChild = this.lastChild = 0;
    if (block) {
      block.children().adopt(this, 0, 0);
    }

    var jQ = this.jQ;

    if (block) {
      var html = block.join('html');
      jQ.html(html);
      MathElement.jQize(jQ);
      this.focus().finalizeInsert();
    }
    else {
      jQ.empty();
    }

    this.cursor.parent = this;
    this.cursor.prev = this.lastChild;
    this.cursor.next = 0;
  };
  _.renderSliderLatex = function(latex) {
    function makeCmd(ch) {
      var cmd;
      var code = ch.charCodeAt(0);
      if ((65 <= code && code <= 90) || (97 <= code && code <= 122))
        cmd = Variable(ch);
      else {
        if (CharCmds[ch] || LatexCmds[ch])
          cmd = (CharCmds[ch] || LatexCmds[ch])(ch);
        else {
          cmd = VanillaSymbol(ch);
        }
      }
      return cmd;
    }

    // valid assignment left-hand-sides: https://github.com/desmosinc/knox/blob/27709c6066a544f160123a6bd775829ec8cd7080/frontend/desmos/public/assets/grapher/jison/latex.jison#L13-L15
    var matches = /^([a-z])(?:_([a-z0-9]|\{[a-z0-9]+\}))?=([-0-9.]+)$/i.exec(latex);

    pray('valid restricted slider LaTeX', matches);
    var letter = matches[1];
    var subscript = matches[2];
    var value = matches[3];

    this.firstChild = this.lastChild = 0;

    letter = Variable(letter);

    if (subscript) {
      var sub = LatexCmds._('_');
      var subBlock = MathBlock().adopt(sub, 0, 0);
      sub.blocks = [ subBlock ];
      if (subscript.length === 1) {
        makeCmd(subscript).adopt(subBlock, subBlock.lastChild, 0);
      }
      else {
        for (var i = 1; i < subscript.length - 1; i += 1) {
          makeCmd(subscript.charAt(i)).adopt(subBlock, subBlock.lastChild, 0);
        }
      }
    }

    letter.adopt(this, this.lastChild, 0);
    if (sub) sub.adopt(this, this.lastChild, 0);
    LatexCmds['=']('=').adopt(this, this.lastChild, 0);
    for (var i = 0, l = value.length; i < l; i += 1) {
      var ch = value.charAt(i);
      var cmd = makeCmd(ch);
      cmd.adopt(this, this.lastChild, 0);
    }

    var jQ = this.jQ;

    var html = this.join('html');
    jQ.html(html);
    MathElement.jQize(jQ);
    //this.finalizeInsert();

    this.cursor.parent = this;
    this.cursor.prev = this.lastChild;
    this.cursor.next = 0;
  };
  _.up = function() { this.triggerSpecialEvent('upPressed'); };
  _.down = function() { this.triggerSpecialEvent('downPressed'); };
  _.moveOutOf = function(dir) { this.triggerSpecialEvent(dir+'Pressed'); };
  _.onKey = function(key, e) {
    switch (key) {
    case 'Ctrl-Shift-Backspace':
    case 'Ctrl-Backspace':
      while (this.cursor.prev || this.cursor.selection) {
        this.cursor.backspace();
      }
      break;

    case 'Shift-Backspace':
    case 'Backspace':
      this.cursor.backspace();
      this.triggerSpecialEvent('render');
      break;

    // Tab or Esc -> go one block right if it exists, else escape right.
    case 'Esc':
    case 'Tab':
      var parent = this.cursor.parent;
      // cursor is in root editable, continue default
      if (parent === this.cursor.root) return;

      this.cursor.prepareMove();
      if (parent.next) {
        // go one block right
        this.cursor.prependTo(parent.next);
      } else {
        // get out of the block
        this.cursor.insertAfter(parent.parent);
      }
      break;

    // Shift-Tab -> go one block left if it exists, else escape left.
    case 'Shift-Tab':
    case 'Shift-Esc':
      var parent = this.cursor.parent;
      //cursor is in root editable, continue default
      if (parent === this.cursor.root) return;

      this.cursor.prepareMove();
      if (parent.prev) {
        // go one block left
        this.cursor.appendTo(parent.prev);
      } else {
        //get out of the block
        this.cursor.insertBefore(parent.parent);
      }
      break;

    // Prevent newlines from showing up
    case 'Enter': this.triggerSpecialEvent('enterPressed'); break;


    // End -> move to the end of the current block.
    case 'End':
      this.cursor.prepareMove().appendTo(this.cursor.parent);
      break;

    // Ctrl-End -> move all the way to the end of the root block.
    case 'Ctrl-End':
      this.cursor.prepareMove().appendTo(this);
      break;

    // Shift-End -> select to the end of the current block.
    case 'Shift-End':
      while (this.cursor.next) {
        this.cursor.selectRight();
      }
      break;

    // Ctrl-Shift-End -> select to the end of the root block.
    case 'Ctrl-Shift-End':
      while (this.cursor.next || this.cursor.parent !== this) {
        this.cursor.selectRight();
      }
      break;

    // Home -> move to the start of the root block or the current block.
    case 'Home':
      this.cursor.prepareMove().prependTo(this.cursor.parent);
      break;

    // Ctrl-Home -> move to the start of the current block.
    case 'Ctrl-Home':
      this.cursor.prepareMove().prependTo(this);
      break;

    // Shift-Home -> select to the start of the current block.
    case 'Shift-Home':
      while (this.cursor.prev) {
        this.cursor.selectLeft();
      }
      break;

    // Ctrl-Shift-Home -> move to the start of the root block.
    case 'Ctrl-Shift-Home':
      while (this.cursor.prev || this.cursor.parent !== this) {
        this.cursor.selectLeft();
      }
      break;

    case 'Left': this.cursor.moveLeft(); break;
    case 'Shift-Left': this.cursor.selectLeft(); break;
    case 'Ctrl-Left': break;
    case 'Meta-Left': break;

    case 'Right': this.cursor.moveRight(); break;
    case 'Shift-Right': this.cursor.selectRight(); break;
    case 'Ctrl-Right': break;
    case 'Meta-Right': break;

    case 'Up': this.cursor.moveUp(); break;
    case 'Down': this.cursor.moveDown(); break;

    case 'Shift-Up':
      if (this.cursor.prev) {
        while (this.cursor.prev) this.cursor.selectLeft();
      } else {
        this.cursor.selectLeft();
      }

    case 'Shift-Down':
      if (this.cursor.next) {
        while (this.cursor.next) this.cursor.selectRight();
      }
      else {
        this.cursor.selectRight();
      }

    case 'Ctrl-Up': break;
    case 'Meta-Up': break;
    case 'Ctrl-Down': break;
    case 'Meta-Down': break;

    case 'Ctrl-Shift-Del':
    case 'Ctrl-Del':
      while (this.cursor.next || this.cursor.selection) {
        this.cursor.deleteForward();
      }
      this.triggerSpecialEvent('render');
      break;

    case 'Shift-Del':
    case 'Del':
      this.cursor.deleteForward();
      this.triggerSpecialEvent('render');
      break;

    case 'Meta-A':
    case 'Ctrl-A':
      //so not stopPropagation'd at RootMathCommand
      if (this !== this.cursor.root) return;

      this.cursor.prepareMove().appendTo(this);
      while (this.cursor.prev) this.cursor.selectLeft();
      break;

    default:
      return false;
    }
    e.preventDefault();
    return false;
  };
  _.onText = function(ch) {
    this.cursor.write(ch);
    this.triggerSpecialEvent('render');
    return false;
  };

  //triggers a special event occured:
  //  1) pressed up and was at 'top' of equation
  //  2) pressed down and was at 'bottom' of equation
  //  3) pressed backspace and equation was empty
  //  4) the equation was rendered
  //  5) etc
  _.triggerSpecialEvent = function(eventName) {
    var jQ = this.jQ;
    setTimeout(function(){ jQ.trigger(eventName); }, 1);
  };
});

var RootMathCommand = P(MathCommand, function(_, _super) {
  _.init = function(cursor) {
    _super.init.call(this, '$');
    this.cursor = cursor;
  };
  _.htmlTemplate = '<span class="mathquill-rendered-math">&0</span>';
  _.createBlocks = function() {
    this.firstChild =
    this.lastChild =
      RootMathBlock();

    this.blocks = [ this.firstChild ];

    this.firstChild.parent = this;

    var cursor = this.firstChild.cursor = this.cursor;
    this.firstChild.onText = function(ch) {
      if (ch !== '$' || cursor.parent !== this)
        cursor.write(ch);
      else if (this.isEmpty()) {
        cursor.insertAfter(this.parent).backspace()
          .insertNew(VanillaSymbol('\\$','$')).show();
      }
      else if (!cursor.next)
        cursor.insertAfter(this.parent);
      else if (!cursor.prev)
        cursor.insertBefore(this.parent);
      else
        cursor.write(ch);

      return false;
    };
  };
  _.latex = function() {
    return '$' + this.firstChild.latex() + '$';
  };
});

var RootTextBlock = P(MathBlock, function(_) {
  _.renderLatex = function(latex) {
    var self = this
    var cursor = self.cursor;
    self.jQ.children().slice(1).remove();
    self.firstChild = self.lastChild = 0;
    cursor.show().appendTo(self);

    var regex = Parser.regex;
    var string = Parser.string;
    var eof = Parser.eof;
    var all = Parser.all;

    // Parser RootMathCommand
    var mathMode = string('$').then(latexMathParser)
      // because TeX is insane, math mode doesn't necessarily
      // have to end.  So we allow for the case that math mode
      // continues to the end of the stream.
      .skip(string('$').or(eof))
      .map(function(block) {
        // HACK FIXME: this shouldn't have to have access to cursor
        var rootMathCommand = RootMathCommand(cursor);

        rootMathCommand.createBlocks();
        var rootMathBlock = rootMathCommand.firstChild;
        block.children().adopt(rootMathBlock, 0, 0);

        return rootMathCommand;
      })
    ;

    var escapedDollar = string('\\$').result('$');
    var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);
    var latexText = mathMode.or(textChar).many();
    var commands = latexText.skip(eof).or(all.result(false)).parse(latex);

    if (commands) {
      for (var i = 0; i < commands.length; i += 1) {
        commands[i].adopt(self, self.lastChild, 0);
      }

      var html = self.join('html');
      MathElement.jQize(html).appendTo(self.jQ);

      this.finalizeInsert();
    }
  };
  _.onKey = RootMathBlock.prototype.onKey;
  _.onText = function(ch) {
    this.cursor.prepareEdit();
    if (ch === '$')
      this.cursor.insertNew(RootMathCommand(this.cursor));
    else
      this.cursor.insertNew(VanillaSymbol(ch));

    return false;
  };
});
/***************************
 * Commands and Operators.
 **************************/

var CharCmds = {}, LatexCmds = {}; //single character commands, LaTeX commands

var scale, // = function(jQ, x, y) { ... }
//will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,
//or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to
//increasing the fontSize to match the vertical Y scaling factor.

//ideas from http://github.com/louisremi/jquery.transform.js
//see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx

  forceIERedraw = noop,
  div = document.createElement('div'),
  div_style = div.style,
  transformPropNames = {
    transform:1,
    WebkitTransform:1,
    MozTransform:1,
    OTransform:1,
    msTransform:1
  },
  transformPropName;

for (var prop in transformPropNames) {
  if (prop in div_style) {
    transformPropName = prop;
    break;
  }
}

if (transformPropName) {
  scale = function(jQ, x, y) {
    jQ.css(transformPropName, 'scale('+x+','+y+')');
  };
}
else if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms
  forceIERedraw = function(el){ el.className = el.className; };
  scale = function(jQ, x, y) { //NOTE: assumes y > x
    x /= (1+(y-1)/2);
    jQ.css('fontSize', y + 'em');
    if (!jQ.hasClass('matrixed-container')) {
      jQ.addClass('matrixed-container')
      .wrapInner('<span class="matrixed"></span>');
    }
    var innerjQ = jQ.children()
    .css('filter', 'progid:DXImageTransform.Microsoft'
        + '.Matrix(M11=' + x + ",SizingMethod='auto expand')"
    );
    function calculateMarginRight() {
      jQ.css('marginRight', (innerjQ.width()-1)*(x-1)/x + 'px');
    }
    calculateMarginRight();
    var intervalId = setInterval(calculateMarginRight);
    $(window).load(function() {
      clearTimeout(intervalId);
      calculateMarginRight();
    });
  };
}
else {
  scale = function(jQ, x, y) {
    jQ.css('fontSize', y + 'em');
  };
}

var Style = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, tagName, attrs) {
    _super.init.call(this, ctrlSeq, '<'+tagName+' '+attrs+'>&0</'+tagName+'>');
  };
});

//fonts
LatexCmds.mathrm = bind(Style, '\\mathrm', 'span', 'class="roman font"');
LatexCmds.mathit = bind(Style, '\\mathit', 'i', 'class="font"');
LatexCmds.mathbf = bind(Style, '\\mathbf', 'b', 'class="font"');
LatexCmds.mathsf = bind(Style, '\\mathsf', 'span', 'class="sans-serif font"');
LatexCmds.mathtt = bind(Style, '\\mathtt', 'span', 'class="monospace font"');
//text-decoration
LatexCmds.underline = bind(Style, '\\underline', 'span', 'class="non-leaf underline"');
LatexCmds.overline = LatexCmds.bar = bind(Style, '\\overline', 'span', 'class="non-leaf overline"');

var SupSub = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, tag, text) {
    _super.init.call(this, ctrlSeq, '<'+tag+' class="non-leaf"><span class="non-leaf '+tag+'">&0</span></'+tag+'>', [ text ]);
  };
  _.finalizeTree = function() {
    //TODO: use inheritance
    pray('SupSub is only _ and ^',
      this.ctrlSeq === '^' || this.ctrlSeq === '_'
    );

    if (this.ctrlSeq === '_') {
      this.down = this.firstChild;
      this.firstChild.up = insertBeforeUnlessAtEnd;
    }
    else {
      this.up = this.firstChild;
      this.firstChild.down = insertBeforeUnlessAtEnd;
    }
  };
  function insertBeforeUnlessAtEnd(cursor) {
    // cursor.insertBefore(cmd), unless cursor at the end of block, and every
    // ancestor cmd is at the end of every ancestor block
    var cmd = this.parent, ancestorCmd = cursor;
    do {
      if (ancestorCmd.next) {
        cursor.insertBefore(cmd);
        return false;
      }
      ancestorCmd = ancestorCmd.parent.parent;
    } while (ancestorCmd !== cmd);
    cursor.insertAfter(cmd);
    return false;
  }
  _.latex = function() {
    if (this.ctrlSeq === '_' && this.respaced) return '';

    var latex = '';

    if (this.ctrlSeq === '^' && this.next.respaced) {
      var block = this.next.firstChild.latex();
      if (block.length === 1) latex += '_' + block;
      else latex += '_{' + block + '}';
    }

    var block = this.firstChild.latex();
    if (block.length === 1) latex += this.ctrlSeq + block;
    else latex += this.ctrlSeq + '{' + (block || ' ') + '}';

    return latex;
  };
  _.redraw = function() {
    if (this.prev)
      this.prev.respace();
    //SupSub::respace recursively calls respace on all the following SupSubs
    //so if prev is a SupSub, no need to call respace on this or following nodes
    if (!(this.prev instanceof SupSub)) {
      this.respace();
      //and if next is a SupSub, then this.respace() will have already called
      //this.next.respace()
      if (this.next && !(this.next instanceof SupSub))
        this.next.respace();
    }
  };
  _.respace = function() {
    if (
      this.prev.ctrlSeq === '\\int ' || (
        this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq
        && this.prev.prev && this.prev.prev.ctrlSeq === '\\int '
      )
    ) {
      if (!this['int']) {
        this['int'] = true;
        this.jQ.addClass('int');
      }
    }
    else {
      if (this['int']) {
        this['int'] = false;
        this.jQ.removeClass('int');
      }
    }

    this.respaced = this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq && !this.prev.respaced;
    if (this.respaced) {
      var fontSize = +this.jQ.css('fontSize').slice(0,-2),
        prevWidth = this.prev.jQ.outerWidth(),
        thisWidth = this.jQ.outerWidth();
      this.jQ.css({
        left: (this['int'] && this.ctrlSeq === '_' ? -.25 : 0) - prevWidth/fontSize + 'em',
        marginRight: .1 - min(thisWidth, prevWidth)/fontSize + 'em'
          //1px extra so it doesn't wrap in retarded browsers (Firefox 2, I think)
      });
    }
    else if (this['int'] && this.ctrlSeq === '_') {
      this.jQ.css({
        left: '-.25em',
        marginRight: ''
      });
    }
    else {
      this.jQ.css({
        left: '',
        marginRight: ''
      });
    }

    if (this.respaced) {
      if (this.ctrlSeq === '^') this.down = this.firstChild.down = this.prev.firstChild;
      else this.up = this.firstChild.up = this.prev.firstChild;
    }
    else if (this.next.respaced) {
      if (this.ctrlSeq === '_') this.up = this.firstChild.up = this.next.firstChild;
      else this.down = this.firstChild.down = this.next.firstChild;
    }
    else {
      if (this.ctrlSeq === '_') {
        delete this.up;
        this.firstChild.up = insertBeforeUnlessAtEnd;
      }
      else {
        delete this.down;
        this.firstChild.down = insertBeforeUnlessAtEnd;
      }
    }

    if (this.next instanceof SupSub)
      this.next.respace();

    return this;
  };

  _.onKey = function(key, e) {
    if (this.getCursor().parent.parent !== this) return;

    switch (key) {
    case 'Tab':
      if (this.next.respaced) {
        this.getCursor().prepareMove().prependTo(this.next.firstChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Shift-Tab':
      if (this.respaced) {
        this.getCursor().prepareMove().appendTo(this.prev.firstChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Left':
      if (!this.getCursor().prev && this.respaced) {
        this.getCursor().prepareMove().insertBefore(this.prev);
        return false;
      }
      break;
    case 'Right':
      if (!this.getCursor().next && this.next.respaced) {
        this.getCursor().prepareMove().insertAfter(this.next);
        return false;
      }
    }
  };
  _.getCursor = function() {
    var cursor;
    for (var ancestor = this.parent; !cursor; ancestor = ancestor.parent) {
      cursor = ancestor.cursor;
    }
    this.getCursor = function() { return cursor; };
    return this.getCursor();
  };
  _.expectedCursorYNextTo = function(clientRect) {
    // superscripts and subscripts are vertical-align-ed +/- 0.5em, so
    // their bottom or top edge almost perfectly aligns with the
    // cursor's center
    if (this.ctrlSeq === '_') return clientRect(this).top;
    else return clientRect(this).bottom;
  };
});

LatexCmds.subscript =
LatexCmds._ = bind(SupSub, '_', 'sub', '_');

LatexCmds.superscript =
LatexCmds.supscript =
LatexCmds['^'] = bind(SupSub, '^', 'sup', '**');

var BigSymbol = P(MathCommand, function(_, _super) {
  _.init = function(ch, html) {
    var htmlTemplate =
        '<span class="large-operator non-leaf">'
      +   '<span class="to"><span>&1</span></span>'
      +   '<big>'+html+'</big>'
      +   '<span class="from"><span>&0</span></span>'
      + '</span>'
    ;
    Symbol.prototype.init.call(this, ch, htmlTemplate);
  };
  _.placeCursor = function(cursor) {
    cursor.appendTo(this.firstChild).writeLatex('n=').show();
  };
  _.latex = function() {
    function simplify(latex) {
      return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';
    }
    return this.ctrlSeq + '_' + simplify(this.firstChild.latex()) +
      '^' + simplify(this.lastChild.latex());
  };
  _.parser = function() {
    var string = Parser.string;
    var optWhitespace = Parser.optWhitespace;
    var succeed = Parser.succeed;
    var block = latexMathParser.block;

    var self = this;
    var blocks = self.blocks = [ MathBlock(), MathBlock() ];
    for (var i = 0; i < blocks.length; i += 1) {
      blocks[i].adopt(self, self.lastChild, 0);
    }

    return optWhitespace.then(string('_').or(string('^'))).then(function(supOrSub) {
      var child = blocks[supOrSub === '_' ? 0 : 1];
      return block.then(function(block) {
        block.children().adopt(child, child.lastChild, 0);
        return succeed(self);
      });
    }).many().result(self);
  };
  _.finalizeTree = function() {
    this.down = this.firstChild;
    this.firstChild.up = insertAfterUnlessAtBeginning;
    this.up = this.lastChild;
    this.lastChild.down = insertAfterUnlessAtBeginning;
  };
  function insertAfterUnlessAtBeginning(cursor) {
    // cursor.insertAfter(cmd), unless cursor at the beginning of block, and every
    // ancestor cmd is at the beginning of every ancestor block
    var cmd = this.parent, ancestorCmd = cursor;
    do {
      if (ancestorCmd.prev) {
        cursor.insertAfter(cmd);
        return false;
      }
      ancestorCmd = ancestorCmd.parent.parent;
    } while (ancestorCmd !== cmd);
    cursor.insertBefore(cmd);
    return false;
  }
});
LatexCmds['\u2211'] = LatexCmds.sum = LatexCmds.summation = bind(BigSymbol,'\\sum ','&sum;');
LatexCmds['\u220F'] = LatexCmds.prod = LatexCmds.product = bind(BigSymbol,'\\prod ','&prod;');

var Fraction =
LatexCmds.frac =
LatexCmds.dfrac =
LatexCmds.cfrac =
LatexCmds.fraction = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\frac';
  _.htmlTemplate =
      '<span class="fraction non-leaf">'
    +   '<span class="numerator">&0</span>'
    +   '<span class="denominator">&1</span>'
    +   '<span style="display:inline-block;width:0;overflow:hidden">&nbsp;</span>'
    + '</span>'
  ;
  _.textTemplate = ['(', '/', ')'];
  _.finalizeTree = function() {
    this.up = this.lastChild.up = this.firstChild;
    this.down = this.firstChild.down = this.lastChild;
  };
  _.expectedCursorYNextTo = function(clientRect) {
    // vertical-align-ed -0.5em, so the top edge of the span that sets
    // the baseline almost perfectly aligns with the cursor's center
    return clientRect.elById(this.jQ[0].lastChild, this.id+.5).top;
  };
});

var LiveFraction =
LatexCmds.over =
CharCmds['/'] = P(Fraction, function(_, _super) {
  _.createBefore = function(cursor) {
    if (!this.replacedFragment) {
      var prev = cursor.prev;
      if (prev instanceof TextBlock || prev instanceof Fraction) {
        prev = prev.prev;
      }
      else {
        while (prev &&
          !(
            prev instanceof BinaryOperator ||
            prev instanceof TextBlock ||
            prev instanceof BigSymbol ||
            prev instanceof Fraction ||
            prev.ctrlSeq === ',' ||
            prev.ctrlSeq === ':' ||
            prev.ctrlSeq === '\\space '
          ) //lookbehind for operator
        )
          prev = prev.prev;

        if (prev instanceof BigSymbol && prev.next instanceof SupSub) {
          prev = prev.next;
          if (prev.next instanceof SupSub && prev.next.ctrlSeq != prev.ctrlSeq)
            prev = prev.next;
        }
      }

      if (prev !== cursor.prev) {
        this.replaces(MathFragment(prev.next || cursor.parent.firstChild, cursor.prev));
        cursor.prev = prev;
      }
    }
    _super.createBefore.call(this, cursor);
  };
});

var SquareRoot =
LatexCmds.sqrt =
LatexCmds['√'] = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\sqrt';
  _.htmlTemplate =
      '<span class="non-leaf">'
    +   '<span class="scaled sqrt-prefix">&radic;</span>'
    +   '<span class="non-leaf sqrt-stem">&0</span>'
    + '</span>'
  ;
  _.textTemplate = ['sqrt(', ')'];
  _.parser = function() {
    return latexMathParser.optBlock.then(function(optBlock) {
      return latexMathParser.block.map(function(block) {
        var nthroot = NthRoot();
        nthroot.blocks = [ optBlock, block ];
        optBlock.adopt(nthroot, 0, 0);
        block.adopt(nthroot, optBlock, 0);
        return nthroot;
      });
    }).or(_super.parser.call(this));
  };
  _.redraw = function() {
    var block = this.lastChild.jQ;
    scale(block.prev(), 1, block.innerHeight()/+block.css('fontSize').slice(0,-2) - .1);
  };
});


var NthRoot =
LatexCmds.nthroot = P(SquareRoot, function(_, _super) {
  _.htmlTemplate =
      '<sup class="nthroot non-leaf">&0</sup>'
    + '<span class="scaled">'
    +   '<span class="sqrt-prefix scaled">&radic;</span>'
    +   '<span class="sqrt-stem non-leaf">&1</span>'
    + '</span>'
  ;
  _.textTemplate = ['sqrt[', '](', ')'];
  _.latex = function() {
    return '\\sqrt['+this.firstChild.latex()+']{'+this.lastChild.latex()+'}';
  };
  _.onKey = function(key, e) {
    if (this.getCursor().parent.parent !== this) return;

    switch (key) {
    case 'Right':
      if (this.getCursor().next) return;
    case 'Tab':
      if (this.getCursor().parent === this.firstChild) {
        this.getCursor().prepareMove().prependTo(this.lastChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Left':
      if (this.getCursor().prev) return;
    case 'Shift-Tab':
      if (this.getCursor().parent === this.lastChild) {
        this.getCursor().prepareMove().appendTo(this.firstChild);
        e.preventDefault();
        return false;
      }
    }
  };
  _.getCursor = SupSub.prototype.getCursor;
  _.expectedCursorYNextTo = function(clientRect) {
    // superscripts are vertical-align-ed 0.5em, so their bottom edge
    // almost perfectly aligns with the cursor's center
    return clientRect.elById(this.jQ[0], this.id+.5).bottom;
  };
});

// Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)
var Bracket = P(MathCommand, function(_, _super) {
  _.init = function(open, close, ctrlSeq, end) {
    _super.init.call(this, '\\left'+ctrlSeq,
        '<span class="non-leaf">'
      +   '<span class="scaled paren">'+open+'</span>'
      +   '<span class="non-leaf">&0</span>'
      +   '<span class="scaled paren">'+close+'</span>'
      + '</span>',
      [open, close]);
    this.end = '\\right'+end;
  };
  _.jQadd = function() {
    _super.jQadd.apply(this, arguments);
    var jQ = this.jQ;
    this.bracketjQs = jQ.children(':first').add(jQ.children(':last'));
  };
  //When typed, auto-expand paren to end of block
  _.finalizeTree = function() {
    if (this.firstChild.isEmpty() && this.next) {
      var nextAll = MathFragment(this.next, this.parent.lastChild).disown();
      nextAll.adopt(this.firstChild, 0, 0);
      nextAll.jQ.appendTo(this.firstChild.jQ);
    }
  };
  _.placeCursor = function(cursor) {
    cursor.prependTo(this.firstChild);
  };
  _.latex = function() {
    return this.ctrlSeq + this.firstChild.latex() + this.end;
  };
  _.redraw = function() {
    var blockjQ = this.firstChild.jQ;

    var height = blockjQ.outerHeight()/+blockjQ.css('fontSize').slice(0,-2);

    scale(this.bracketjQs, min(1 + .2*(height - 1), 1.2), 1.05*height);
  };
});

LatexCmds.left = P(MathCommand, function(_) {
  _.parser = function() {
    var regex = Parser.regex;
    var string = Parser.string;
    var regex = Parser.regex;
    var succeed = Parser.succeed;
    var block = latexMathParser.block;
    var optWhitespace = Parser.optWhitespace;

    return optWhitespace.then(regex(/^(?:[([|]|\\\{)/))
      .then(function(open) {
        if (open.charAt(0) === '\\') open = open.slice(1);

        var cmd = CharCmds[open]();

        return latexMathParser
          .map(function (block) {
            cmd.blocks = [ block ];
            block.adopt(cmd, 0, 0);
          })
          .then(string('\\right'))
          .skip(optWhitespace)
          .then(regex(/^(?:[\])|]|\\\})/))
          .then(function(close) {
            if (close.slice(-1) !== cmd.end.slice(-1)) {
              return Parser.fail('open doesn\'t match close');
            }

            return succeed(cmd);
          })
        ;
      })
    ;
  };
});

LatexCmds.right = P(MathCommand, function(_) {
  _.parser = function() {
    return Parser.fail('unmatched \\right');
  };
});

LatexCmds.lbrace =
CharCmds['{'] = bind(Bracket, '{', '}', '\\{', '\\}');
LatexCmds.langle =
LatexCmds.lang = bind(Bracket, '&lang;','&rang;','\\langle ','\\rangle ');

// Closing bracket matching opening bracket above
var CloseBracket = P(Bracket, function(_, _super) {
  _.createBefore = function(cursor) {
    // if I'm replacing a selection fragment, just wrap in parens
    if (this.replacedFragment) return _super.createBefore.call(this, cursor);

    // elsewise, if my parent is a matching open-paren, then close it here,
    // i.e. move everything after me in the open-paren to after the parens
    var openParen = cursor.parent.parent;
    if (openParen.ctrlSeq === this.ctrlSeq) {
      if (cursor.next) {
        var nextAll = MathFragment(cursor.next, openParen.firstChild.lastChild).disown();
        nextAll.adopt(openParen.parent, openParen, openParen.next);
        nextAll.jQ.insertAfter(openParen.jQ);
        if (cursor.next.respace) cursor.next.respace();
      }
      cursor.insertAfter(openParen);
      openParen.bubble('redraw');
    }
    // or if not, make empty paren group and put cursor inside it
    // (I think this behavior is weird - Han)
    else {
      _super.createBefore.call(this, cursor);
      cursor.appendTo(this.firstChild); // FIXME HACK
    }
  };
  _.finalizeTree = noop;
  _.placeCursor = function(cursor) {
    this.firstChild.blur();
    cursor.insertAfter(this);
  };
});

LatexCmds.rbrace =
CharCmds['}'] = bind(CloseBracket, '{','}','\\{','\\}');
LatexCmds.rangle =
LatexCmds.rang = bind(CloseBracket, '&lang;','&rang;','\\langle ','\\rangle ');

var parenMixin = function(_, _super) {
  _.init = function(open, close) {
    _super.init.call(this, open, close, open, close);
  };
};

var Paren = P(Bracket, parenMixin);

LatexCmds.lparen =
CharCmds['('] = bind(Paren, '(', ')');
LatexCmds.lbrack =
LatexCmds.lbracket =
CharCmds['['] = bind(Paren, '[', ']');

var CloseParen = P(CloseBracket, parenMixin);

LatexCmds.rparen =
CharCmds[')'] = bind(CloseParen, '(', ')');
LatexCmds.rbrack =
LatexCmds.rbracket =
CharCmds[']'] = bind(CloseParen, '[', ']');

var Pipes =
LatexCmds.lpipe =
LatexCmds.rpipe =
CharCmds['|'] = P(Paren, function(_, _super) {
  _.init = function() {
    _super.init.call(this, '|', '|');
  }

  _.createBefore = function(cursor) {
    if (!cursor.next && cursor.parent.parent && cursor.parent.parent.end === this.end && !this.replacedFragment)
      cursor.insertAfter(cursor.parent.parent);
    else
      MathCommand.prototype.createBefore.call(this, cursor);
  };
  _.finalizeTree = noop;
});

// DISABLED in DCG
var TextBlock =
LatexCmds.text =
LatexCmds.textnormal =
LatexCmds.textrm =
LatexCmds.textup =
LatexCmds.textmd = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\text';
  _.htmlTemplate = '<span class="text">&0</span>';
  _.replaces = function(replacedText) {
    if (replacedText instanceof MathFragment)
      this.replacedText = replacedText.remove().jQ.text();
    else if (typeof replacedText === 'string')
      this.replacedText = replacedText;
  };
  _.textTemplate = ['"', '"'];
  _.parser = function() {
    // TODO: correctly parse text mode
    var string = Parser.string;
    var regex = Parser.regex;
    var optWhitespace = Parser.optWhitespace;
    return optWhitespace
      .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))
      .map(function(text) {
        var cmd = TextBlock();
        cmd.createBlocks();
        var block = cmd.firstChild;
        for (var i = 0; i < text.length; i += 1) {
          var ch = VanillaSymbol(text.charAt(i));
          ch.adopt(block, block.lastChild, 0);
        }
        return cmd;
      })
    ;
  };
  _.createBlocks = function() {
    //FIXME: another possible Law of Demeter violation, but this seems much cleaner, like it was supposed to be done this way
    this.firstChild =
    this.lastChild =
      InnerTextBlock();

    this.blocks = [ this.firstChild ];

    this.firstChild.parent = this;
  };
  _.finalizeInsert = function() {
    //FIXME HACK blur removes the TextBlock
    this.firstChild.blur = function() { delete this.blur; return this; };
    _super.finalizeInsert.call(this);
  };
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, this.cursor = cursor);

    if (this.replacedText)
      for (var i = 0; i < this.replacedText.length; i += 1)
        this.write(this.replacedText.charAt(i));
  };
  _.write = function(ch) {
    this.cursor.insertNew(VanillaSymbol(ch));
  };
  _.onKey = function(key, e) {
    //backspace and delete and ends of block don't unwrap
    if (!this.cursor.selection &&
      (
        (key === 'Backspace' && !this.cursor.prev) ||
        (key === 'Del' && !this.cursor.next)
      )
    ) {
      if (this.isEmpty())
        this.cursor.insertAfter(this);

      return false;
    }
  };
  _.onText = function(ch) {
    this.cursor.prepareEdit();
    if (ch !== '$')
      this.write(ch);
    else if (this.isEmpty())
      this.cursor.insertAfter(this).backspace().insertNew(VanillaSymbol('\\$','$'));
    else if (!this.cursor.next)
      this.cursor.insertAfter(this);
    else if (!this.cursor.prev)
      this.cursor.insertBefore(this);
    else { //split apart
      var next = TextBlock(MathFragment(this.cursor.next, this.firstChild.lastChild));
      next.placeCursor = function(cursor) { //FIXME HACK: pretend no prev so they don't get merged
        this.prev = 0;
        delete this.placeCursor;
        this.placeCursor(cursor);
      };
      next.firstChild.focus = function(){ return this; };
      this.cursor.insertAfter(this).insertNew(next);
      next.prev = this;
      this.cursor.insertBefore(next);
      delete next.firstChild.focus;
    }
    this.cursor.root.triggerSpecialEvent('render');
    return false;
  };
});

var InnerTextBlock = P(MathBlock, function(_, _super) {
  _.blur = function() {
    this.jQ.removeClass('hasCursor');
    if (this.isEmpty()) {
      var textblock = this.parent, cursor = textblock.cursor;
      if (cursor.parent === this)
        this.jQ.addClass('empty');
      else {
        cursor.hide();
        textblock.remove();
        if (cursor.next === textblock)
          cursor.next = textblock.next;
        else if (cursor.prev === textblock)
          cursor.prev = textblock.prev;

        cursor.show().parent.bubble('redraw');
      }
    }
    return this;
  };
  _.focus = function() {
    _super.focus.call(this);

    var textblock = this.parent;
    if (textblock.next.ctrlSeq === textblock.ctrlSeq) { //TODO: seems like there should be a better way to move MathElements around
      var innerblock = this,
        cursor = textblock.cursor,
        next = textblock.next.firstChild;

      next.eachChild(function(child){
        child.parent = innerblock;
        child.jQ.appendTo(innerblock.jQ);
      });

      if (this.lastChild)
        this.lastChild.next = next.firstChild;
      else
        this.firstChild = next.firstChild;

      next.firstChild.prev = this.lastChild;
      this.lastChild = next.lastChild;

      next.parent.remove();

      if (cursor.prev)
        cursor.insertAfter(cursor.prev);
      else
        cursor.prependTo(this);

      cursor.parent.bubble('redraw');
    }
    else if (textblock.prev.ctrlSeq === textblock.ctrlSeq) {
      var cursor = textblock.cursor;
      if (cursor.prev)
        textblock.prev.firstChild.focus();
      else
        cursor.appendTo(textblock.prev.firstChild);
    }
    return this;
  };
});


function makeTextBlock(latex, tagName, attrs) {
  return P(TextBlock, {
    ctrlSeq: latex,
    htmlTemplate: '<'+tagName+' '+attrs+'>&0</'+tagName+'>'
  });
}

LatexCmds.em = LatexCmds.italic = LatexCmds.italics =
LatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =
  makeTextBlock('\\textit', 'i', 'class="text"');
LatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =
  makeTextBlock('\\textbf', 'b', 'class="text"');
LatexCmds.sf = LatexCmds.textsf =
  makeTextBlock('\\textsf', 'span', 'class="sans-serif text"');
LatexCmds.tt = LatexCmds.texttt =
  makeTextBlock('\\texttt', 'span', 'class="monospace text"');
LatexCmds.textsc =
  makeTextBlock('\\textsc', 'span', 'style="font-variant:small-caps" class="text"');
LatexCmds.uppercase =
  makeTextBlock('\\uppercase', 'span', 'style="text-transform:uppercase" class="text"');
LatexCmds.lowercase =
  makeTextBlock('\\lowercase', 'span', 'style="text-transform:lowercase" class="text"');

// input box to type a variety of LaTeX commands beginning with a backslash
// DISABLED in DCG
var LatexCommandInput =
P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\';
  _.replaces = function(replacedFragment) {
    this._replacedFragment = replacedFragment.disown();
    this.isEmpty = function() { return false; };
  };
  _.htmlTemplate = '<span class="latex-command-input non-leaf">\\<span>&0</span></span>';
  _.textTemplate = ['\\'];
  _.createBlocks = function() {
    _super.createBlocks.call(this);
    this.firstChild.focus = function() {
      this.parent.jQ.addClass('hasCursor');
      if (this.isEmpty())
        this.parent.jQ.removeClass('empty');

      return this;
    };
    this.firstChild.blur = function() {
      this.parent.jQ.removeClass('hasCursor');
      if (this.isEmpty())
        this.parent.jQ.addClass('empty');

      return this;
    };
  };
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, cursor);
    this.cursor = cursor.appendTo(this.firstChild);
    if (this._replacedFragment) {
      var el = this.jQ[0];
      this.jQ =
        this._replacedFragment.jQ.addClass('blur').bind(
          'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?
          function(e) {
            $(e.target = el).trigger(e);
            return false;
          }
        ).insertBefore(this.jQ).add(this.jQ);
    }
  };
  _.latex = function() {
    return '\\' + this.firstChild.latex() + ' ';
  };
  _.onKey = function(key, e) {
    if (key === 'Tab' || key === 'Enter') {
      this.renderCommand();
      this.cursor.root.triggerSpecialEvent('render');
      e.preventDefault();
      return false;
    }
  };
  _.onText = function(ch) {
    if (ch.match(/[a-z]/i)) {
      this.cursor.prepareEdit();
      this.cursor.insertNew(VanillaSymbol(ch));
      return false;
    }
    this.renderCommand();
    if (ch === ' ' || (ch === '\\' && this.firstChild.isEmpty())) {
      this.cursor.root.triggerSpecialEvent('render');
      return false;
    }
  };
  _.renderCommand = function() {
    this.jQ = this.jQ.last();
    this.remove();
    if (this.next) {
      this.cursor.insertBefore(this.next);
    } else {
      this.cursor.appendTo(this.parent);
    }

    var latex = this.firstChild.latex(), cmd;
    if (!latex) latex = 'backslash';
    this.cursor.insertCmd(latex, this._replacedFragment);
  };
});

var Binomial =
LatexCmds.binom =
LatexCmds.binomial = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\binom';
  _.htmlTemplate =
      '<span class="paren scaled">(</span>'
    + '<span class="non-leaf">'
    +   '<span class="array non-leaf">'
    +     '<span>&0</span>'
    +     '<span>&1</span>'
    +   '</span>'
    + '</span>'
    + '<span class="paren scaled">)</span>'
  ;
  _.textTemplate = ['choose(',',',')'];
  _.redraw = function() {
    var blockjQ = this.jQ.eq(1);

    var height = blockjQ.outerHeight()/+blockjQ.css('fontSize').slice(0,-2);

    var parens = this.jQ.filter('.paren');
    scale(parens, min(1 + .2*(height - 1), 1.2), 1.05*height);
  };
  // vertical-align: middle, so
  _.expectedCursorYNextTo = Symbol.prototype.expectedCursorYNextTo;
});

var Choose =
LatexCmds.choose = P(Binomial, function(_) {
  _.createBefore = LiveFraction.prototype.createBefore;
});

var Vector =
LatexCmds.vector = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\vector';
  _.htmlTemplate = '<span class="array"><span>&0</span></span>';
  _.latex = function() {
    return '\\begin{matrix}' + this.foldChildren([], function(latex, child) {
      latex.push(child.latex());
      return latex;
    }).join('\\\\') + '\\end{matrix}';
  };
  _.text = function() {
    return '[' + this.foldChildren([], function(text, child) {
      text.push(child.text());
      return text;
    }).join() + ']';
  }
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, this.cursor = cursor);
  };
  _.onKey = function(key, e) {
    var currentBlock = this.cursor.parent;

    if (currentBlock.parent === this) {
      if (key === 'Enter') { //enter
        var newBlock = MathBlock();
        newBlock.parent = this;
        newBlock.jQ = $('<span></span>')
          .attr(mqBlockId, newBlock.id)
          .insertAfter(currentBlock.jQ);
        if (currentBlock.next)
          currentBlock.next.prev = newBlock;
        else
          this.lastChild = newBlock;

        newBlock.next = currentBlock.next;
        currentBlock.next = newBlock;
        newBlock.prev = currentBlock;
        this.bubble('redraw').cursor.appendTo(newBlock);

        e.preventDefault();
        return false;
      }
      else if (key === 'Tab' && !currentBlock.next) {
        if (currentBlock.isEmpty()) {
          if (currentBlock.prev) {
            this.cursor.insertAfter(this);
            delete currentBlock.prev.next;
            this.lastChild = currentBlock.prev;
            currentBlock.jQ.remove();
            this.bubble('redraw');

            e.preventDefault();
            return false;
          }
          else
            return;
        }

        var newBlock = MathBlock();
        newBlock.parent = this;
        newBlock.jQ = $('<span></span>').attr(mqBlockId, newBlock.id).appendTo(this.jQ);
        this.lastChild = newBlock;
        currentBlock.next = newBlock;
        newBlock.prev = currentBlock;
        this.bubble('redraw').cursor.appendTo(newBlock);

        e.preventDefault();
        return false;
      }
      else if (e.which === 8) { //backspace
        if (currentBlock.isEmpty()) {
          if (currentBlock.prev) {
            this.cursor.appendTo(currentBlock.prev)
            currentBlock.prev.next = currentBlock.next;
          }
          else {
            this.cursor.insertBefore(this);
            this.firstChild = currentBlock.next;
          }

          if (currentBlock.next)
            currentBlock.next.prev = currentBlock.prev;
          else
            this.lastChild = currentBlock.prev;

          currentBlock.jQ.remove();
          if (this.isEmpty())
            this.cursor.deleteForward();
          else
            this.bubble('redraw');

          e.preventDefault();
          return false;
        }
        else if (!this.cursor.prev) {
          e.preventDefault();
          return false;
        }
      }
    }
  };
  // vertical-align: middle, so
  _.expectedCursorYNextTo = Binomial.prototype.expectedCursorYNextTo;
});
/**********************************
 * Symbols and Special Characters
 *********************************/

var Variable = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<var>'+(html || ch)+'</var>');
  }
  _.createBefore = function(cursor) {
    //want the longest possible autocommand, so assemble longest series of letters (Variables) first
    var ctrlSeq = this.ctrlSeq;
    for (var i = 0, prev = cursor.prev; i < MAX_AUTOCMD_LEN - 1 && prev && prev instanceof Variable; i += 1, prev = prev.prev)
      ctrlSeq = prev.ctrlSeq + ctrlSeq;
    //then test if there's an autocommand here, starting with the longest possible and slicing
    while (ctrlSeq.length) {
      if (AutoCmds.hasOwnProperty(ctrlSeq)) {
        for (var i = 1; i < ctrlSeq.length; i += 1) cursor.backspace();
        cursor.insertNew(LatexCmds[ctrlSeq](ctrlSeq));
        return;
      }
      ctrlSeq = ctrlSeq.slice(1);
    }
    _super.createBefore.apply(this, arguments);
  };
  _.respace =
  _.finalizeTree = function() {
    //TODO: in better architecture, should be done in createBefore and backspace
    //respace is called too often, inefficient

    //want the longest possible autocommand, so assemble longest series of letters (Variables)
    var ctrlSeq = this.ctrlSeq;
    if (ctrlSeq.length > 1) return;
    for (var prev = this.prev; prev instanceof Variable && prev.ctrlSeq.length === 1; prev = prev.prev)
      ctrlSeq = prev.ctrlSeq + ctrlSeq;
    for (var next = this.next; next instanceof Variable && next.ctrlSeq.length === 1; next = next.next)
      ctrlSeq += next.ctrlSeq;

    //removeClass from all the things before figuring out what's an autocmd, if any
    MathFragment(prev.next || this.parent.firstChild, next.prev || this.parent.lastChild)
    .each(function(el) {
      el.jQ.removeClass('un-italicized last');
      delete el.isFirstLetter;
      delete el.isLastLetter;
    });

    //test if there's an autocommand here, going through substrings from longest to shortest
    outer: for (var i = 0, first = prev.next || this.parent.firstChild; i < ctrlSeq.length; i += 1, first = first.next) {
      for (var len = min(MAX_UNITALICIZED_LEN, ctrlSeq.length - i); len > 0; len -= 1) {
        if (UnItalicizedCmds.hasOwnProperty(ctrlSeq.slice(i, i + len))) {
          first.isFirstLetter = true;
          for (var j = 0, letter = first; j < len; j += 1, letter = letter.next) {
            letter.jQ.addClass('un-italicized');
            var last = letter;
          }
          last.isLastLetter = true;
          if (!(last.next instanceof SupSub || last.next instanceof Bracket))
            last.jQ.addClass('last');
          i += len - 1;
          first = last;
          continue outer;
        }
      }
    }
  };
  _.latex = function() {
    return (
      this.isFirstLetter ? '\\' + this.ctrlSeq :
      this.isLastLetter ? this.ctrlSeq + ' ' :
      this.ctrlSeq
    );
  };
  _.text = function() {
    var text = this.ctrlSeq;
    if (this.prev && !(this.prev instanceof Variable)
        && !(this.prev instanceof BinaryOperator))
      text = '*' + text;
    if (this.next && !(this.next instanceof BinaryOperator)
        && !(this.next.ctrlSeq === '^'))
      text += '*';
    return text;
  };
});

var UnItalicized = P(Symbol, function(_, _super) {
  _.init = function(fn) {
    this.ctrlSeq = fn;
  };
  _.createBefore = function(cursor) {
    cursor.writeLatex(this.ctrlSeq).show();
  };
  _.parser = function() {
    var fn = this.ctrlSeq;
    var block = MathBlock();
    for (var i = 0; i < fn.length; i += 1) {
      Variable(fn.charAt(i)).adopt(block, block.lastChild, 0);
    }
    return Parser.succeed(block.children());
  };
});

//backslashless commands, words where adjacent letters (Variables)
//that form them automatically are turned into commands
var UnItalicizedCmds = {
  ln: 1,
  log: 1,
  min: 1,
  nCr: 1,
  nPr: 1,
  gcd: 1,
  lcm: 1,
  mcm: 1,
  mcd: 1,
  ceil: 1,
  exp: 1,
  abs: 1,
  max: 1,
  mod: 1,
  gcf: 1,
  exp: 1,
  floor: 1,
  sign: 1,
  signum: 1,
  round: 1
}, MAX_UNITALICIZED_LEN = 9, AutoCmds = {
  sqrt: 1,
  nthroot: 1,
  sum: 1,
  prod: 1,
  pi: 1,
  phi: 1,
  tau: 1,
  gamma: 1,
  theta: 1/*,
  int: 1*/
}, MAX_AUTOCMD_LEN = 7;

(function() {
  var trigs = { sin: 1, cos: 1, tan: 1, sec: 1, cosec: 1, csc: 1, cotan: 1, cot: 1, ctg: 1 };
  for (var trig in trigs) {
    UnItalicizedCmds[trig] =
    UnItalicizedCmds['arc'+trig] =
    UnItalicizedCmds[trig+'h'] =
    UnItalicizedCmds['arc'+trig+'h'] = 1;
  }

  for (var fn in UnItalicizedCmds)
    LatexCmds[fn] = UnItalicized;
}());

var VanillaSymbol = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<span>'+(html || ch)+'</span>');
  };
});

CharCmds[' '] = bind(VanillaSymbol, '\\space ', ' ');

LatexCmds.prime = CharCmds["'"] = bind(VanillaSymbol, "'", '&prime;');

// does not use Symbola font
var NonSymbolaSymbol = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<span class="nonSymbola">'+(html || ch)+'</span>');
  };
});

LatexCmds['@'] = NonSymbolaSymbol;
LatexCmds['&'] = bind(NonSymbolaSymbol, '\\&', '&amp;');
LatexCmds['%'] = bind(NonSymbolaSymbol, '\\%', '%');

//the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html

//lowercase Greek letter variables
LatexCmds.alpha =
LatexCmds.beta =
LatexCmds.gamma =
LatexCmds.delta =
LatexCmds.zeta =
LatexCmds.eta =
LatexCmds.theta =
LatexCmds.iota =
LatexCmds.kappa =
LatexCmds.mu =
LatexCmds.nu =
LatexCmds.xi =
LatexCmds.rho =
LatexCmds.sigma =
LatexCmds.tau =
LatexCmds.chi =
LatexCmds.psi =
LatexCmds.omega = P(Variable, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this,'\\'+latex+' ','&'+latex+';');
  };
});

//why can't anybody FUCKING agree on these
LatexCmds.phi = //W3C or Unicode?
  bind(Variable,'\\phi ','&#981;');

LatexCmds.phiv = //Elsevier and 9573-13
LatexCmds.varphi = //AMS and LaTeX
  bind(Variable,'\\varphi ','&phi;');

LatexCmds.epsilon = //W3C or Unicode?
  bind(Variable,'\\epsilon ','&#1013;');

LatexCmds.epsiv = //Elsevier and 9573-13
LatexCmds.varepsilon = //AMS and LaTeX
  bind(Variable,'\\varepsilon ','&epsilon;');

LatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13
LatexCmds.varpi = //AMS and LaTeX
  bind(Variable,'\\varpi ','&piv;');

LatexCmds.sigmaf = //W3C/Unicode
LatexCmds.sigmav = //Elsevier
LatexCmds.varsigma = //LaTeX
  bind(Variable,'\\varsigma ','&sigmaf;');

LatexCmds.thetav = //Elsevier and 9573-13
LatexCmds.vartheta = //AMS and LaTeX
LatexCmds.thetasym = //W3C/Unicode
  bind(Variable,'\\vartheta ','&thetasym;');

LatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode
LatexCmds.upsi = //Elsevier and 9573-13
  bind(Variable,'\\upsilon ','&upsilon;');

//these aren't even mentioned in the HTML character entity references
LatexCmds.gammad = //Elsevier
LatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)
LatexCmds.digamma = //LaTeX
  bind(Variable,'\\digamma ','&#989;');

LatexCmds.kappav = //Elsevier
LatexCmds.varkappa = //AMS and LaTeX
  bind(Variable,'\\varkappa ','&#1008;');

LatexCmds.rhov = //Elsevier and 9573-13
LatexCmds.varrho = //AMS and LaTeX
  bind(Variable,'\\varrho ','&#1009;');

//Greek constants, look best in un-italicised Times New Roman
LatexCmds.pi = LatexCmds['\u03C0'] = bind(NonSymbolaSymbol,'\\pi ','&pi;');
LatexCmds.theta = LatexCmds['\u03B8'] = bind(NonSymbolaSymbol,'\\theta ','&theta;');
LatexCmds.lambda = bind(NonSymbolaSymbol,'\\lambda ','&lambda;');

//uppercase greek letters

LatexCmds.Upsilon = //LaTeX
LatexCmds.Upsi = //Elsevier and 9573-13
LatexCmds.upsih = //W3C/Unicode "upsilon with hook"
LatexCmds.Upsih = //'cos it makes sense to me
  bind(Symbol,'\\Upsilon ','<var style="font-family: serif">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(

//other symbols with the same LaTeX command and HTML character entity reference
LatexCmds.Gamma =
LatexCmds.Delta =
LatexCmds.Theta =
LatexCmds.Lambda =
LatexCmds.Xi =
LatexCmds.Pi =
LatexCmds.Sigma =
LatexCmds.Phi =
LatexCmds.Psi =
LatexCmds.Omega =
LatexCmds.forall = P(VanillaSymbol, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this,'\\'+latex+' ','&'+latex+';');
  };
});

// symbols that aren't a single MathCommand, but are instead a whole
// Fragment. Creates the Fragment from a LaTeX string
var LatexFragment = P(MathCommand, function(_) {
  _.init = function(latex) { this.latex = latex; };
  _.createBefore = function(cursor) { cursor.writeLatex(this.latex); };
  _.parser = function() {
    var frag = latexMathParser.parse(this.latex).children();
    return Parser.succeed(frag);
  };
});

// for what seems to me like [stupid reasons][1], Unicode provides
// subscripted and superscripted versions of all ten Arabic numerals,
// as well as [so-called "vulgar fractions"][2].
// Nobody really cares about most of them, but some of them actually
// predate Unicode, dating back to [ISO-8859-1][3], apparently also
// known as "Latin-1", which among other things [Windows-1252][4]
// largely coincides with, so Microsoft Word sometimes inserts them
// and they get copy-pasted into MathQuill.
//
// (Irrelevant but funny story: Windows-1252 is actually a strict
// superset of the "closely related but distinct"[3] "ISO 8859-1" --
// see the lack of a dash after "ISO"? Completely different character
// set, like elephants vs elephant seals, or "Zombies" vs "Zombie
// Redneck Torture Family". What kind of idiot would get them confused.
// People in fact got them confused so much, it was so common to
// mislabel Windows-1252 text as ISO-8859-1, that most modern web
// browsers and email clients treat the MIME charset of ISO-8859-1
// as actually Windows-1252, behavior now standard in the HTML5 spec.)
//
// [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts
// [2]: http://en.wikipedia.org/wiki/Number_Forms
// [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
// [4]: http://en.wikipedia.org/wiki/Windows-1252
LatexCmds['\u00b9'] = bind(LatexFragment, '^1');
LatexCmds['\u00b2'] = bind(LatexFragment, '^2');
LatexCmds['\u00b3'] = bind(LatexFragment, '^3');
LatexCmds['\u00bc'] = bind(LatexFragment, '\\frac14');
LatexCmds['\u00bd'] = bind(LatexFragment, '\\frac12');
LatexCmds['\u00be'] = bind(LatexFragment, '\\frac34');
LatexCmds['\u2152'] = bind(LatexFragment, '\\frac{1}{10}');
LatexCmds['\u2153'] = bind(LatexFragment, '\\frac13');
LatexCmds['\u2154'] = bind(LatexFragment, '\\frac23');


var BinaryOperator = P(Symbol, function(_, _super) {
  _.init = function(ctrlSeq, html, text) {
    _super.init.call(this,
      ctrlSeq, '<span class="binary-operator">'+html+'</span>', text
    );
  };
  _.createBefore = function(cursor) {
    var ctrlSeq = cursor.prev.ctrlSeq + this.ctrlSeq;
    if (ctrlSeq === '<=')
      cursor.backspace().insertNew(BinaryOperator('\\le ', '&le;'));
    else if (ctrlSeq === '>=')
      cursor.backspace().insertNew(BinaryOperator('\\ge ', '&ge;'));
    else
      _super.createBefore.apply(this, arguments);
  };
});

var PlusMinus = P(BinaryOperator, function(_) {
  _.init = VanillaSymbol.prototype.init;

  _.respace = function() {
    if (!this.prev) {
      this.jQ[0].className = '';
    }
    else if (
      this.prev instanceof BinaryOperator &&
      this.next && !(this.next instanceof BinaryOperator)
    ) {
      this.jQ[0].className = 'unary-operator';
    }
    else {
      this.jQ[0].className = 'binary-operator';
    }
    return this;
  };
});

LatexCmds['+'] = bind(PlusMinus, '+', '+');
//yes, these are different dashes, I think one is an en dash and the other is a hyphen
LatexCmds['\u2013'] = LatexCmds['\u2212'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');
LatexCmds['\u00B1'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =
  bind(PlusMinus,'\\pm ','&plusmn;');
LatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =
  bind(PlusMinus,'\\mp ','&#8723;');

CharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =
  bind(BinaryOperator, '\\cdot ', '&middot;');
//semantically should be &sdot;, but &middot; looks better

LatexCmds['='] = bind(BinaryOperator, '=', '=');
LatexCmds['<'] = bind(BinaryOperator, '<', '&lt;');
LatexCmds['>'] = bind(BinaryOperator, '>', '&gt;');

LatexCmds.notin =
LatexCmds.sim =
LatexCmds.cong =
LatexCmds.equiv =
LatexCmds.oplus =
LatexCmds.otimes = P(BinaryOperator, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this, '\\'+latex+' ', '&'+latex+';');
  };
});

LatexCmds.times = bind(BinaryOperator, '\\times ', '&times;', '[x]');

LatexCmds['\u00F7'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =
  bind(BinaryOperator,'\\div ','&divide;', '[/]');

LatexCmds['\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator,'\\ne ','&ne;');

LatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =
  bind(BinaryOperator,'\\ast ','&lowast;');
  //case 'there4 = // a special exception for this one, perhaps?
LatexCmds.therefor = LatexCmds.therefore =
  bind(BinaryOperator,'\\therefore ','&there4;');

LatexCmds.cuz = // l33t
LatexCmds.because = bind(BinaryOperator,'\\because ','&#8757;');

LatexCmds.prop = LatexCmds.propto = bind(BinaryOperator,'\\propto ','&prop;');

LatexCmds['\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator,'\\approx ','&asymp;');

LatexCmds.lt = bind(BinaryOperator,'<','&lt;');

LatexCmds.gt = bind(BinaryOperator,'>','&gt;');

LatexCmds['\u2264'] = LatexCmds.le = LatexCmds.leq = bind(BinaryOperator,'\\le ','&le;');

LatexCmds['\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(BinaryOperator,'\\ge ','&ge;');

LatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator,'\\in ','&isin;');

LatexCmds.ni = LatexCmds.contains = bind(BinaryOperator,'\\ni ','&ni;');

LatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =
  bind(BinaryOperator,'\\not\\ni ','&#8716;');

LatexCmds.sub = LatexCmds.subset = bind(BinaryOperator,'\\subset ','&sub;');

LatexCmds.sup = LatexCmds.supset = LatexCmds.superset =
  bind(BinaryOperator,'\\supset ','&sup;');

LatexCmds.nsub = LatexCmds.notsub =
LatexCmds.nsubset = LatexCmds.notsubset =
  bind(BinaryOperator,'\\not\\subset ','&#8836;');

LatexCmds.nsup = LatexCmds.notsup =
LatexCmds.nsupset = LatexCmds.notsupset =
LatexCmds.nsuperset = LatexCmds.notsuperset =
  bind(BinaryOperator,'\\not\\supset ','&#8837;');

LatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =
  bind(BinaryOperator,'\\subseteq ','&sube;');

LatexCmds.supe = LatexCmds.supeq =
LatexCmds.supsete = LatexCmds.supseteq =
LatexCmds.supersete = LatexCmds.superseteq =
  bind(BinaryOperator,'\\supseteq ','&supe;');

LatexCmds.nsube = LatexCmds.nsubeq =
LatexCmds.notsube = LatexCmds.notsubeq =
LatexCmds.nsubsete = LatexCmds.nsubseteq =
LatexCmds.notsubsete = LatexCmds.notsubseteq =
  bind(BinaryOperator,'\\not\\subseteq ','&#8840;');

LatexCmds.nsupe = LatexCmds.nsupeq =
LatexCmds.notsupe = LatexCmds.notsupeq =
LatexCmds.nsupsete = LatexCmds.nsupseteq =
LatexCmds.notsupsete = LatexCmds.notsupseteq =
LatexCmds.nsupersete = LatexCmds.nsuperseteq =
LatexCmds.notsupersete = LatexCmds.notsuperseteq =
  bind(BinaryOperator,'\\not\\supseteq ','&#8841;');

/*

//the canonical sets of numbers
LatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =
  bind(VanillaSymbol,'\\mathbb{N}','&#8469;');

LatexCmds.P =
LatexCmds.primes = LatexCmds.Primes =
LatexCmds.projective = LatexCmds.Projective =
LatexCmds.probability = LatexCmds.Probability =
  bind(VanillaSymbol,'\\mathbb{P}','&#8473;');

LatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =
  bind(VanillaSymbol,'\\mathbb{Z}','&#8484;');

LatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =
  bind(VanillaSymbol,'\\mathbb{Q}','&#8474;');

LatexCmds.R = LatexCmds.reals = LatexCmds.Reals =
  bind(VanillaSymbol,'\\mathbb{R}','&#8477;');

LatexCmds.C =
LatexCmds.complex = LatexCmds.Complex =
LatexCmds.complexes = LatexCmds.Complexes =
LatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =
  bind(VanillaSymbol,'\\mathbb{C}','&#8450;');

LatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =
  bind(VanillaSymbol,'\\mathbb{H}','&#8461;');

//spacing
LatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\quad ','    ');
LatexCmds.qquad = bind(VanillaSymbol,'\\qquad ','        ');
spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow
case ',':
  return VanillaSymbol('\\, ',' ');
case ':':
  return VanillaSymbol('\\: ','  ');
case ';':
  return VanillaSymbol('\\; ','   ');
case '!':
  return Symbol('\\! ','<span style="margin-right:-.2em"></span>');

//binary operators
LatexCmds.diamond = bind(VanillaSymbol, '\\diamond ', '&#9671;');
LatexCmds.bigtriangleup = bind(VanillaSymbol, '\\bigtriangleup ', '&#9651;');
LatexCmds.ominus = bind(VanillaSymbol, '\\ominus ', '&#8854;');
LatexCmds.uplus = bind(VanillaSymbol, '\\uplus ', '&#8846;');
LatexCmds.bigtriangledown = bind(VanillaSymbol, '\\bigtriangledown ', '&#9661;');
LatexCmds.sqcap = bind(VanillaSymbol, '\\sqcap ', '&#8851;');
LatexCmds.triangleleft = bind(VanillaSymbol, '\\triangleleft ', '&#8882;');
LatexCmds.sqcup = bind(VanillaSymbol, '\\sqcup ', '&#8852;');
LatexCmds.triangleright = bind(VanillaSymbol, '\\triangleright ', '&#8883;');
LatexCmds.odot = bind(VanillaSymbol, '\\odot ', '&#8857;');
LatexCmds.bigcirc = bind(VanillaSymbol, '\\bigcirc ', '&#9711;');
LatexCmds.dagger = bind(VanillaSymbol, '\\dagger ', '&#0134;');
LatexCmds.ddagger = bind(VanillaSymbol, '\\ddagger ', '&#135;');
LatexCmds.wr = bind(VanillaSymbol, '\\wr ', '&#8768;');
LatexCmds.amalg = bind(VanillaSymbol, '\\amalg ', '&#8720;');

//relationship symbols
LatexCmds.models = bind(VanillaSymbol, '\\models ', '&#8872;');
LatexCmds.prec = bind(VanillaSymbol, '\\prec ', '&#8826;');
LatexCmds.succ = bind(VanillaSymbol, '\\succ ', '&#8827;');
LatexCmds.preceq = bind(VanillaSymbol, '\\preceq ', '&#8828;');
LatexCmds.succeq = bind(VanillaSymbol, '\\succeq ', '&#8829;');
LatexCmds.simeq = bind(VanillaSymbol, '\\simeq ', '&#8771;');
LatexCmds.mid = bind(VanillaSymbol, '\\mid ', '&#8739;');
LatexCmds.ll = bind(VanillaSymbol, '\\ll ', '&#8810;');
LatexCmds.gg = bind(VanillaSymbol, '\\gg ', '&#8811;');
LatexCmds.parallel = bind(VanillaSymbol, '\\parallel ', '&#8741;');
LatexCmds.bowtie = bind(VanillaSymbol, '\\bowtie ', '&#8904;');
LatexCmds.sqsubset = bind(VanillaSymbol, '\\sqsubset ', '&#8847;');
LatexCmds.sqsupset = bind(VanillaSymbol, '\\sqsupset ', '&#8848;');
LatexCmds.smile = bind(VanillaSymbol, '\\smile ', '&#8995;');
LatexCmds.sqsubseteq = bind(VanillaSymbol, '\\sqsubseteq ', '&#8849;');
LatexCmds.sqsupseteq = bind(VanillaSymbol, '\\sqsupseteq ', '&#8850;');
LatexCmds.doteq = bind(VanillaSymbol, '\\doteq ', '&#8784;');
LatexCmds.frown = bind(VanillaSymbol, '\\frown ', '&#8994;');
LatexCmds.vdash = bind(VanillaSymbol, '\\vdash ', '&#8870;');
LatexCmds.dashv = bind(VanillaSymbol, '\\dashv ', '&#8867;');

//arrows
LatexCmds.longleftarrow = bind(VanillaSymbol, '\\longleftarrow ', '&#8592;');
LatexCmds.longrightarrow = bind(VanillaSymbol, '\\longrightarrow ', '&#8594;');
LatexCmds.Longleftarrow = bind(VanillaSymbol, '\\Longleftarrow ', '&#8656;');
LatexCmds.Longrightarrow = bind(VanillaSymbol, '\\Longrightarrow ', '&#8658;');
LatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\longleftrightarrow ', '&#8596;');
LatexCmds.updownarrow = bind(VanillaSymbol, '\\updownarrow ', '&#8597;');
LatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\Longleftrightarrow ', '&#8660;');
LatexCmds.Updownarrow = bind(VanillaSymbol, '\\Updownarrow ', '&#8661;');
LatexCmds.mapsto = bind(VanillaSymbol, '\\mapsto ', '&#8614;');
LatexCmds.nearrow = bind(VanillaSymbol, '\\nearrow ', '&#8599;');
LatexCmds.hookleftarrow = bind(VanillaSymbol, '\\hookleftarrow ', '&#8617;');
LatexCmds.hookrightarrow = bind(VanillaSymbol, '\\hookrightarrow ', '&#8618;');
LatexCmds.searrow = bind(VanillaSymbol, '\\searrow ', '&#8600;');
LatexCmds.leftharpoonup = bind(VanillaSymbol, '\\leftharpoonup ', '&#8636;');
LatexCmds.rightharpoonup = bind(VanillaSymbol, '\\rightharpoonup ', '&#8640;');
LatexCmds.swarrow = bind(VanillaSymbol, '\\swarrow ', '&#8601;');
LatexCmds.leftharpoondown = bind(VanillaSymbol, '\\leftharpoondown ', '&#8637;');
LatexCmds.rightharpoondown = bind(VanillaSymbol, '\\rightharpoondown ', '&#8641;');
LatexCmds.nwarrow = bind(VanillaSymbol, '\\nwarrow ', '&#8598;');

//Misc
*/
LatexCmds.space = bind(VanillaSymbol, '\\space ', '&nbsp;');
/*
LatexCmds.ldots = bind(VanillaSymbol, '\\ldots ', '&#8230;');
LatexCmds.cdots = bind(VanillaSymbol, '\\cdots ', '&#8943;');
LatexCmds.vdots = bind(VanillaSymbol, '\\vdots ', '&#8942;');
LatexCmds.ddots = bind(VanillaSymbol, '\\ddots ', '&#8944;');
LatexCmds.surd = bind(VanillaSymbol, '\\surd ', '&#8730;');
LatexCmds.triangle = bind(VanillaSymbol, '\\triangle ', '&#9653;');
LatexCmds.ell = bind(VanillaSymbol, '\\ell ', '&#8467;');
LatexCmds.top = bind(VanillaSymbol, '\\top ', '&#8868;');
LatexCmds.flat = bind(VanillaSymbol, '\\flat ', '&#9837;');
LatexCmds.natural = bind(VanillaSymbol, '\\natural ', '&#9838;');
LatexCmds.sharp = bind(VanillaSymbol, '\\sharp ', '&#9839;');
LatexCmds.wp = bind(VanillaSymbol, '\\wp ', '&#8472;');
LatexCmds.bot = bind(VanillaSymbol, '\\bot ', '&#8869;');
LatexCmds.clubsuit = bind(VanillaSymbol, '\\clubsuit ', '&#9827;');
LatexCmds.diamondsuit = bind(VanillaSymbol, '\\diamondsuit ', '&#9826;');
LatexCmds.heartsuit = bind(VanillaSymbol, '\\heartsuit ', '&#9825;');
LatexCmds.spadesuit = bind(VanillaSymbol, '\\spadesuit ', '&#9824;');

//variable-sized
LatexCmds.oint = bind(VanillaSymbol, '\\oint ', '&#8750;');
LatexCmds.bigcap = bind(VanillaSymbol, '\\bigcap ', '&#8745;');
LatexCmds.bigcup = bind(VanillaSymbol, '\\bigcup ', '&#8746;');
LatexCmds.bigsqcup = bind(VanillaSymbol, '\\bigsqcup ', '&#8852;');
LatexCmds.bigvee = bind(VanillaSymbol, '\\bigvee ', '&#8744;');
LatexCmds.bigwedge = bind(VanillaSymbol, '\\bigwedge ', '&#8743;');
LatexCmds.bigodot = bind(VanillaSymbol, '\\bigodot ', '&#8857;');
LatexCmds.bigotimes = bind(VanillaSymbol, '\\bigotimes ', '&#8855;');
LatexCmds.bigoplus = bind(VanillaSymbol, '\\bigoplus ', '&#8853;');
LatexCmds.biguplus = bind(VanillaSymbol, '\\biguplus ', '&#8846;');

//delimiters
LatexCmds.lfloor = bind(VanillaSymbol, '\\lfloor ', '&#8970;');
LatexCmds.rfloor = bind(VanillaSymbol, '\\rfloor ', '&#8971;');
LatexCmds.lceil = bind(VanillaSymbol, '\\lceil ', '&#8968;');
LatexCmds.rceil = bind(VanillaSymbol, '\\rceil ', '&#8969;');
LatexCmds.slash = bind(VanillaSymbol, '\\slash ', '&#47;');
LatexCmds.opencurlybrace = bind(VanillaSymbol, '\\opencurlybrace ', '&#123;');
LatexCmds.closecurlybrace = bind(VanillaSymbol, '\\closecurlybrace ', '&#125;');

//various symbols

LatexCmds.caret = bind(VanillaSymbol,'\\caret ','^');
LatexCmds.underscore = bind(VanillaSymbol,'\\underscore ','_');
LatexCmds.backslash = bind(VanillaSymbol,'\\backslash ','\\');
LatexCmds.vert = bind(VanillaSymbol,'|');
LatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\perp ','&perp;');
LatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\nabla ','&nabla;');
LatexCmds.hbar = bind(VanillaSymbol,'\\hbar ','&#8463;');

LatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =
  bind(VanillaSymbol,'\\text\\AA ','&#8491;');

LatexCmds.ring = LatexCmds.circ = LatexCmds.circle =
  bind(VanillaSymbol,'\\circ ','&#8728;');

LatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\bullet ','&bull;');

LatexCmds.setminus = LatexCmds.smallsetminus =
  bind(VanillaSymbol,'\\setminus ','&#8726;');

LatexCmds.not = //bind(Symbol,'\\not ','<span class="not">/</span>');
LatexCmds['¬'] = LatexCmds.neg = bind(VanillaSymbol,'\\neg ','&not;');

LatexCmds['…'] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =
LatexCmds.ellipsis = LatexCmds.hellipsis =
  bind(VanillaSymbol,'\\dots ','&hellip;');

LatexCmds.converges =
LatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =
  bind(VanillaSymbol,'\\downarrow ','&darr;');

LatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =
  bind(VanillaSymbol,'\\Downarrow ','&dArr;');

LatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =
  bind(VanillaSymbol,'\\uparrow ','&uarr;');

LatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\Uparrow ','&uArr;');

LatexCmds.to = bind(BinaryOperator,'\\to ','&rarr;');

LatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\rightarrow ','&rarr;');

LatexCmds.implies = bind(BinaryOperator,'\\Rightarrow ','&rArr;');

LatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\Rightarrow ','&rArr;');

LatexCmds.gets = bind(BinaryOperator,'\\gets ','&larr;');

LatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\leftarrow ','&larr;');

LatexCmds.impliedby = bind(BinaryOperator,'\\Leftarrow ','&lArr;');

LatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\Leftarrow ','&lArr;');

LatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =
  bind(VanillaSymbol,'\\leftrightarrow ','&harr;');

LatexCmds.iff = bind(BinaryOperator,'\\Leftrightarrow ','&hArr;');

LatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =
  bind(VanillaSymbol,'\\Leftrightarrow ','&hArr;');

LatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\Re ','&real;');

LatexCmds.Im = LatexCmds.imag =
LatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =
  bind(VanillaSymbol,'\\Im ','&image;');

LatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\partial ','&part;');

LatexCmds.inf = LatexCmds.infin = LatexCmds.infty = LatexCmds.infinity =
  bind(VanillaSymbol,'\\infty ','&infin;');

LatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =
  bind(VanillaSymbol,'\\aleph ','&alefsym;');

LatexCmds.xist = //LOL
LatexCmds.xists = LatexCmds.exist = LatexCmds.exists =
  bind(VanillaSymbol,'\\exists ','&exist;');
*/
LatexCmds.and = LatexCmds.land = LatexCmds.wedge =
  bind(VanillaSymbol,'\\wedge ','&and;');

LatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol,'\\vee ','&or;');
/*
LatexCmds.o = LatexCmds.O =
LatexCmds.empty = LatexCmds.emptyset =
LatexCmds.oslash = LatexCmds.Oslash =
LatexCmds.nothing = LatexCmds.varnothing =
  bind(BinaryOperator,'\\varnothing ','&empty;');

LatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\cup ','&cup;');

LatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =
  bind(BinaryOperator,'\\cap ','&cap;');

LatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'^\\circ ','&deg;');

LatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\angle ','&ang;');
*/
// Parser MathCommand
var latexMathParser = (function() {
  function commandToBlock(cmd) {
    var block = MathBlock();
    cmd.adopt(block, 0, 0);
    return block;
  }
  function joinBlocks(blocks) {
    var firstBlock = blocks[0] || MathBlock();

    for (var i = 1; i < blocks.length; i += 1) {
      blocks[i].children().adopt(firstBlock, firstBlock.lastChild, 0);
    }

    return firstBlock;
  }

  var string = Parser.string;
  var regex = Parser.regex;
  var letter = Parser.letter;
  var any = Parser.any;
  var optWhitespace = Parser.optWhitespace;
  var succeed = Parser.succeed;
  var fail = Parser.fail;

  // Parsers yielding MathCommands
  var variable = letter.map(Variable);
  var symbol = regex(/^[^${}\\_^]/).map(VanillaSymbol);

  var controlSequence =
    regex(/^[^\\]/)
    .or(string('\\').then(
      regex(/^[a-z]+/i)
      .or(regex(/^\s+/).result(' '))
      .or(any)
    )).then(function(ctrlSeq) {
      var cmdKlass = LatexCmds[ctrlSeq];

      if (cmdKlass) {
        return cmdKlass(ctrlSeq).parser();
      }
      else {
        return fail('unknown command: \\'+ctrlSeq);
      }
    })
  ;

  var command =
    controlSequence
    .or(variable)
    .or(symbol)
  ;

  // Parsers yielding MathBlocks
  var mathGroup = string('{').then(function() { return mathSequence; }).skip(string('}'));
  var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));
  var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);

  var optMathBlock =
    string('[').then(
      mathBlock.then(function(block) {
        return block.join('latex') !== ']' ? succeed(block) : fail();
      })
      .many().map(joinBlocks).skip(optWhitespace)
    ).skip(string(']'))
  ;

  var latexMath = mathSequence;

  latexMath.block = mathBlock;
  latexMath.optBlock = optMathBlock;
  return latexMath;
})();
/********************************************
 * Cursor and Selection "singleton" classes
 *******************************************/

/* The main thing that manipulates the Math DOM. Makes sure to manipulate the
HTML DOM to match. */

/* Sort of singletons, since there should only be one per editable math
textbox, but any one HTML document can contain many such textboxes, so any one
JS environment could actually contain many instances. */

//A fake cursor in the fake textbox that the math is rendered in.
var Cursor = P(function(_) {
  _.init = function(root) {
    this.parent = this.root = root;
    var jQ = this.jQ = this._jQ = $('<span class="cursor"><span class="line">&zwj;</span></span>');

    //closured for setInterval
    this.blink = function(){ jQ.toggleClass('blink'); }

    this.upDownCache = {};
  };

  _.prev = 0;
  _.next = 0;
  _.parent = 0;
  _.handle = 0;
  _.showHandle = function() {
    if (!this.handle) {
      this.handle = $('<span class="handle"></span>').appendTo(this.jQ);
    }
    return this;
  };
  _.hideHandle = function() {
    if (this.handle) {
      this.handle.remove();
      delete this.handle;
    }
    return this;
  };
  _.show = function(keepHandle) {
    if (!keepHandle) this.hideHandle();
    this.jQ = this._jQ.removeClass('blink');
    if ('intervalId' in this) //already was shown, just restart interval
      clearInterval(this.intervalId);
    else { //was hidden and detached, insert this.jQ back into HTML DOM
      if (this.next) {
        if (this.selection && this.selection.first.prev === this.prev)
          this.jQ.insertBefore(this.selection.jQ);
        else
          this.jQ.insertBefore(this.next.jQ.first());
      }
      else
        this.jQ.appendTo(this.parent.jQ);
      this.parent.focus();
    }
    this.intervalId = setInterval(this.blink, 500);
    return this;
  };
  _.hide = function() {
    if ('intervalId' in this)
      clearInterval(this.intervalId);
    delete this.intervalId;
    this.jQ.detach();
    this.jQ = $();
    return this;
  };
  _.insertAt = function(parent, prev, next) {
    var old_parent = this.parent;

    this.parent = parent;
    this.prev = prev;
    this.next = next;

    old_parent.blur(); //blur may need to know cursor's destination
  };
  _.insertBefore = function(el) {
    this.insertAt(el.parent, el.prev, el)
    this.parent.jQ.addClass('hasCursor');
    this.jQ.insertBefore(el.jQ.first());
    return this;
  };
  _.insertAfter = function(el) {
    this.insertAt(el.parent, el, el.next);
    this.parent.jQ.addClass('hasCursor');
    this.jQ.insertAfter(el.jQ.last());
    return this;
  };
  _.prependTo = function(el) {
    this.insertAt(el, 0, el.firstChild);
    this.jQ.prependTo(el.jQ);
    el.focus();
    return this;
  };
  _.appendTo = function(el) {
    this.insertAt(el, el.lastChild, 0);
    this.jQ.appendTo(el.jQ);
    el.focus();
    return this;
  };
  _.hopLeft = function() {
    this.jQ.insertBefore(this.prev.jQ.first());
    this.next = this.prev;
    this.prev = this.prev.prev;
    return this;
  };
  _.hopRight = function() {
    this.jQ.insertAfter(this.next.jQ.last());
    this.prev = this.next;
    this.next = this.next.next;
    return this;
  };
  _.moveLeftWithin = function(block) {
    if (this.prev) {
      // FIXME HACK: when moving right to left, want to go into NthRoot's body,
      // which is its lastChild.
      if (this.prev instanceof NthRoot) this.appendTo(this.prev.lastChild);
      else if (this.prev.up instanceof MathBlock) this.appendTo(this.prev.up);
      else if (this.prev.firstChild) this.appendTo(this.prev.firstChild)
      else this.hopLeft();
    }
    else {
      // unless we're at the beginning of the containing block, escape left
      if (this.parent !== block) this.insertBefore(this.parent.parent);
      else if (block.moveOutOf) block.moveOutOf('left', this);
    }
  };
  _.moveRightWithin = function(block) {
    if (this.next) {
      if (this.next.up instanceof MathBlock) this.prependTo(this.next.up);
      else if (this.next.firstChild) this.prependTo(this.next.firstChild)
      else this.hopRight();
    }
    else {
      // unless we're at the beginning of the containing block, escape left
      if (this.parent !== block) this.insertAfter(this.parent.parent);
      else if (block.moveOutOf) block.moveOutOf('right', this);
    }
  };
  _.moveLeft = function() {
    clearUpDownCache(this);

    if (this.selection)
      this.insertBefore(this.selection.first).clearSelection();
    else {
      this.moveLeftWithin(this.root);
    }
    this.root.triggerSpecialEvent('cursorMoved');
    return this.show();
  };
  _.moveRight = function() {
    clearUpDownCache(this);

    if (this.selection)
      this.insertAfter(this.selection.last).clearSelection();
    else {
      this.moveRightWithin(this.root);
    }
    this.root.triggerSpecialEvent('cursorMoved');
    return this.show();
  };

  /**
   * moveUp and moveDown have almost identical algorithms:
   * - first check next and prev, if so prepend/appendTo them
   * - else check the parent's 'up'/'down' property - if it's a function,
   *   call it with the cursor as the sole argument and use the return value.
   *
   *   Given undefined, will bubble up to the next ancestor block.
   *   Given false, will stop bubbling.
   *   Given a MathBlock,
   *     + moveUp will appendTo it
   *     + moveDown will prependTo it
   *
   */
  _.moveUp = function() { return moveUpDown(this, 'up'); };
  _.moveDown = function() { return moveUpDown(this, 'down'); };
  function moveUpDown(self, dir) {
    if (self.next[dir]) self.prependTo(self.next[dir]);
    else if (self.prev[dir]) self.appendTo(self.prev[dir]);
    else {
      var ancestorBlock = self.parent;
      do {
        var prop = ancestorBlock[dir];
        if (prop) {
          if (typeof prop === 'function') prop = ancestorBlock[dir](self);
          if (prop === false || prop instanceof MathBlock) {
            self.upDownCache[ancestorBlock.id] = { parent: self.parent, prev: self.prev, next: self.next };

            if (prop instanceof MathBlock) {
              var cached = self.upDownCache[prop.id];

              if (cached) {
                if (cached.next) {
                  self.insertBefore(cached.next);
                } else {
                  self.appendTo(cached.parent);
                }
              } else {
                var coords = self.jQ[0].getBoundingClientRect();
                var cachedClientRect = cachedClientRectFnForNewCache();
                prop.seek(self, coords.left, coords.bottom, prop, cachedClientRect);
              }
            }
            break;
          }
        }
        ancestorBlock = ancestorBlock.parent.parent;
      } while (ancestorBlock);
    }

    return self.clearSelection().show();
  }

  _.seek = function(target, clientX, clientY, clientRect, keepHandle) {
    clearUpDownCache(this);
    var cursor = this.clearSelection().show(keepHandle);

    var nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);
    if (!nodeId) {
      var targetParent = target.parent();
      nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);
    }
    var node = nodeId ? MathElement[nodeId] : cursor.root;
    pray('nodeId is the id of some Node that exists', node);

    node.seek(cursor, clientX, clientY, cursor.root, clientRect);

    return cursor;
  };
  function offset(self) {
    //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()
    //returns all 0's on inline elements with negative margin-right (like
    //the cursor) at the end of their parent, so temporarily remove the
    //negative margin-right when calling jQuery::offset()
    //Opera bug DSK-360043
    //http://bugs.jquery.com/ticket/11523
    //https://github.com/jquery/jquery/pull/717
    var offset = self.jQ.removeClass('cursor').offset();
    self.jQ.addClass('cursor');
    return offset;
  }
  _.writeLatex = function(latex) {
    var self = this;
    clearUpDownCache(self);
    self.show().deleteSelection();

    var all = Parser.all;
    var eof = Parser.eof;

    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);

    if (block && !block.isEmpty()) {
      block.children().adopt(self.parent, self.prev, self.next);
      var html = block.join('html');
      var jQ = MathElement.jQize(html);
      jQ.insertBefore(self.jQ);
      self.prev = block.lastChild;
      block.finalizeInsert();
      self.parent.bubble('redraw');
    }

    return this;
  };
  _.write =
  _.insertCh = function(ch) {
    //Hack by Eli: don't exponentiate if there's nothing before the cursor
    if ((ch == '^' || ch == '_') && !this.prev) return;

    //Hack #2 by Eli: if you type '+' or '-' or '=' in an exponent or subscript, break out of it
    if ((ch == '+' || ch == '=' || ch == '-' || ch == '<' || ch == '>') && (this.parent.parent.ctrlSeq === '^' || this.parent.parent.ctrlSeq === '_')
      && !this.next && this.prev
    ) {
      this.moveRight();
    }

    //Hack #3 by Eli: if you type "^" just after a superscript, behave as though you just pressed up
    if (ch === '^' && this.prev instanceof SupSub && 
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.prev.ctrlSeq === '^' || this.prev.prev.ctrlSeq === '^')) {
      this.moveUp();
      return;
    }
    
    //Hack #4 by Eli: if you type "^" just _before_ a superscript, behave as though you just pressed up
    if (ch === '^' && this.next instanceof SupSub && 
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.next.ctrlSeq === '^' || (this.next.next && this.next.next.ctrlSeq === '^'))) {
      this.moveUp();
      return;
    }
    
    
    if (ch === '_' && this.prev instanceof SupSub && 
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.prev.ctrlSeq === '_' || this.prev.prev.ctrlSeq === '_')) {
      this.moveDown();
      return;
    }

    clearUpDownCache(this);
    this.show();

    var cmd;
    if (ch.match(/^[a-z]$/i))
      cmd = Variable(ch);
    else if (cmd = CharCmds[ch] || LatexCmds[ch])
      cmd = cmd(ch);
    else
      cmd = VanillaSymbol(ch);

    if (this.selection) {
      this.prev = this.selection.first.prev;
      this.next = this.selection.last.next;
      cmd.replaces(this.selection);
      delete this.selection;
    }

    return this.insertNew(cmd);
  };
  _.insertNew = function(cmd) {
    cmd.createBefore(this);
    return this;
  };
  _.insertCmd = function(latexCmd, replacedFragment) {
    clearUpDownCache(this);
    this.show();

    var cmd = LatexCmds[latexCmd];
    if (cmd) {
      cmd = cmd(latexCmd);
      if (replacedFragment) cmd.replaces(replacedFragment);
      this.insertNew(cmd);
    }
    else {
      cmd = TextBlock();
      cmd.replaces(latexCmd);
      cmd.firstChild.focus = function(){ delete this.focus; return this; };
      this.insertNew(cmd).insertAfter(cmd);
      if (replacedFragment)
        replacedFragment.remove();
    }
    return this;
  };
  _.unwrapGramp = function() {
    var gramp = this.parent.parent;
    var greatgramp = gramp.parent;
    var next = gramp.next;
    var cursor = this;

    var prev = gramp.prev;
    gramp.disown().eachChild(function(uncle) {
      if (uncle.isEmpty()) return;

      uncle.children()
        .adopt(greatgramp, prev, next)
        .each(function(cousin) {
          cousin.jQ.insertBefore(gramp.jQ.first());
        })
      ;

      prev = uncle.lastChild;
    });

    if (!this.next) { //then find something to be next to insertBefore
      if (this.prev)
        this.next = this.prev.next;
      else {
        while (!this.next) {
          this.parent = this.parent.next;
          if (this.parent)
            this.next = this.parent.firstChild;
          else {
            this.next = gramp.next;
            this.parent = greatgramp;
            break;
          }
        }
      }
    }
    if (this.next)
      this.insertBefore(this.next);
    else
      this.appendTo(greatgramp);

    gramp.jQ.remove();

    if (gramp.prev)
      gramp.prev.respace();
    if (gramp.next)
      gramp.next.respace();
  };
  _.backspace = function() {
    clearUpDownCache(this);
    this.show();

    if (this.deleteSelection()); // pass
    else if (this.prev) {
      if (this.prev.isEmpty()) {
        if (this.prev.ctrlSeq === '\\le ') var ins = LatexCmds['<']('<');
        else if (this.prev.ctrlSeq === '\\ge ') var ins = LatexCmds['>']('>');
        this.prev = this.prev.remove().prev;
        if (ins) this.insertNew(ins);
      }
      else if (this.prev instanceof Bracket)
        return this.appendTo(this.prev.firstChild).deleteForward();
      else
        this.selectLeft();
    }
    else if (this.parent !== this.root) {
      if (this.parent.parent.isEmpty())
        return this.insertAfter(this.parent.parent).backspace();
      else if (this.next instanceof Bracket)
        return this.prependTo(this.next.firstChild).backspace();
      else
        this.unwrapGramp();
    }
    else this.root.triggerSpecialEvent('backspacePressed');

    if (this.prev)
      this.prev.respace();
    if (this.next)
      this.next.respace();
    this.parent.bubble('redraw');

    return this;
  };
  _.deleteForward = function() {
    clearUpDownCache(this);
    this.show();

    if (this.deleteSelection()); // pass
    else if (this.next) {
      if (this.next.isEmpty())
        this.next = this.next.remove().next;
      else
        this.selectRight();
    }
    else if (this.parent !== this.root) {
      if (this.parent.parent.isEmpty())
        return this.insertBefore(this.parent.parent).deleteForward();
      else
        this.unwrapGramp();
    }
    else this.root.triggerSpecialEvent('delPressed');

    if (this.prev)
      this.prev.respace();
    if (this.next)
      this.next.respace();
    this.parent.bubble('redraw');

    return this;
  };
  _.selectFrom = function(anticursor) {
    //find ancestors of each with common parent
    var oneA = this, otherA = anticursor; //one ancestor, the other ancestor
    loopThroughAncestors: do {
      for (var oneI = this; oneI !== oneA.parent.parent; oneI = oneI.parent.parent) //one intermediate, the other intermediate
        if (oneI.parent === otherA.parent) {
          left = oneI;
          right = otherA;
          break loopThroughAncestors;
        }

      for (var otherI = anticursor; otherI !== otherA.parent.parent; otherI = otherI.parent.parent)
        if (oneA.parent === otherI.parent) {
          left = oneA;
          right = otherI;
          break loopThroughAncestors;
        }

      if (oneA.parent.parent)
        oneA = oneA.parent.parent;
      if (otherA.parent.parent)
        otherA = otherA.parent.parent;
    } while (oneA.parent.parent || otherA.parent.parent);
    // the only way for this condition to fail is if A and B are in separate
    // trees, which should be impossible, but infinite loops must never happen,
    // even under error conditions.
    pray('cursor and anticursor are in the same tree', left && right);

    //figure out which is left/prev and which is right/next
    var left, right, leftRight;
    if (left.next !== right) {
      for (var next = left; next; next = next.next) {
        if (next === right.prev) {
          leftRight = true;
          break;
        }
      }
      if (!leftRight) {
        leftRight = right;
        right = left;
        left = leftRight;
      }
    }
    this.hide().selection = Selection(left.prev.next || left.parent.firstChild, right.next.prev || right.parent.lastChild);
    this.insertAfter(right.next.prev || right.parent.lastChild);
    this.root.selectionChanged();
  };
  _.selectLeft = function() {
    clearUpDownCache(this);
    if (this.selection) {
      if (this.selection.first === this.next) { //if cursor is at left edge of selection;
        if (this.prev) //then extend left if possible
          this.hopLeft().selection.extendLeft();
        else if (this.parent !== this.root) //else level up if possible
          this.insertBefore(this.parent.parent).selection.levelUp();
      }
      else { //else cursor is at right edge of selection, retract left if possible
        this.hopLeft();
        if (this.selection.first === this.selection.last) {
          this.clearSelection().show(); //clear selection if retracting to nothing
          return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
        }
        this.selection.retractLeft();
      }
    }
    else {
      if (this.prev)
        this.hopLeft();
      else //end of a block
        if (this.parent !== this.root)
          this.insertBefore(this.parent.parent);
        else
          return;

      this.hide().selection = Selection(this.next);
    }
    this.root.selectionChanged();
  };
  _.selectRight = function() {
    clearUpDownCache(this);
    if (this.selection) {
      if (this.selection.last === this.prev) { //if cursor is at right edge of selection;
        if (this.next) //then extend right if possible
          this.hopRight().selection.extendRight();
        else if (this.parent !== this.root) //else level up if possible
          this.insertAfter(this.parent.parent).selection.levelUp();
      }
      else { //else cursor is at left edge of selection, retract right if possible
        this.hopRight();
        if (this.selection.first === this.selection.last) {
          this.clearSelection().show(); //clear selection if retracting to nothing
          return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
        }
        this.selection.retractRight();
      }
    }
    else {
      if (this.next)
        this.hopRight();
      else //end of a block
        if (this.parent !== this.root)
          this.insertAfter(this.parent.parent);
        else
          return;

      this.hide().selection = Selection(this.prev);
    }
    this.root.selectionChanged();
  };

  function clearUpDownCache(self) {
    self.upDownCache = {};
  }

  _.prepareMove = function() {
    clearUpDownCache(this);
    return this.show().clearSelection();
  };

  _.prepareEdit = function() {
    clearUpDownCache(this);
    return this.show().deleteSelection();
  }

  _.clearSelection = function() {
    if (this.selection) {
      this.selection.clear();
      delete this.selection;
      this.root.selectionChanged();
    }
    return this;
  };
  _.deleteSelection = function() {
    if (!this.selection) return false;

    this.prev = this.selection.first.prev;
    this.next = this.selection.last.next;
    this.selection.remove();
    this.root.selectionChanged();
    return delete this.selection;
  };
});

var Selection = P(MathFragment, function(_, _super) {
  _.init = function() {
    var frag = this;
    _super.init.apply(frag, arguments);

    frag.jQwrap(frag.jQ);
  };
  _.jQwrap = function(children) {
    this.jQ = children.wrapAll('<span class="selection"></span>').parent();
      //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it
  };
  _.adopt = function() {
    this.jQ.replaceWith(this.jQ = this.jQ.children());
    return _super.adopt.apply(this, arguments);
  };
  _.clear = function() {
    this.jQ.replaceWith(this.jQ.children());
    return this;
  };
  _.levelUp = function() {
    var seln = this,
      gramp = seln.first = seln.last = seln.last.parent.parent;
    seln.clear().jQwrap(gramp.jQ);
    return seln;
  };
  _.extendLeft = function() {
    this.first = this.first.prev;
    this.first.jQ.prependTo(this.jQ);
  };
  _.extendRight = function() {
    this.last = this.last.next;
    this.last.jQ.appendTo(this.jQ);
  };
  _.retractRight = function() {
    this.first.jQ.insertBefore(this.jQ);
    this.first = this.first.next;
  };
  _.retractLeft = function() {
    this.last.jQ.insertAfter(this.jQ);
    this.last = this.last.prev;
  };
});
/*********************************************************
 * The actual jQuery plugin and document ready handlers.
 ********************************************************/

//The publicy exposed method of jQuery.prototype, available (and meant to be
//called) on jQuery-wrapped HTML DOM elements.
$.fn.mathquill = function(cmd, latex) {
  switch (cmd) {
  case 'focus':
  case 'blur':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block && block.textarea)
        block.textarea.children().trigger(cmd);
    });
  case 'onKey':
  case 'onText':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;

      if (cursor) {
        cursor.parent.bubble(cmd, latex, { preventDefault: noop });
        if (block.blurred) cursor.hide().parent.blur();
      }
    });
  case 'redraw':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        rootBlock = blockId && MathElement[blockId];
      if (rootBlock) {
        (function postOrderRedraw(el) {
          el.eachChild(postOrderRedraw);
          if (el.redraw) el.redraw();
        }(rootBlock));
      }
    });
  case 'revert':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block && block.revert)
        block.revert();
    });
  case 'sliderLatex':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block) {

        //fixes bug with highlighting everything and then setting state with latex
        //https://github.com/desmosinc/knox/issues/1115
        cursor = block && block.cursor;
        if (cursor) cursor.clearSelection();
        block.renderSliderLatex(latex);
        block.triggerSpecialEvent('render');
      }
    });
  case 'latex':
    if (arguments.length > 1) {
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId];
        if (block) {
          //fixes bug with highlighting everything and then setting state with latex
          //https://github.com/desmosinc/knox/issues/1115
          cursor = block && block.cursor;
          if (cursor) cursor.clearSelection();
          block.renderLatex(latex);
          block.triggerSpecialEvent('render');
        }
      });
    }

    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    return block && block.latex();
  case 'text':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    return block && block.text();
  case 'html':
    return this.children(':last').html().replace(/ ?hasCursor|hasCursor /, '')
      .replace(/ class=(""|(?= |>))/g, '')
      .replace(/<span class="?cursor( blink)?"?>.?<\/span>/i, '');
  case 'write':
    if (arguments.length > 1)
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

        if (cursor) {
          cursor.writeLatex(latex)
          if (block.blurred) cursor.hide().parent.blur();
        }
      });
  case 'cmd':
    if (arguments.length > 1)
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

        if (cursor) {
          if (/^\\[a-z]+$/i.test(latex)) {
            var selection = cursor.selection;
            if (selection) {
              cursor.prev = selection.first.prev;
              cursor.next = selection.last.next;
              delete cursor.selection;
            }
            cursor.insertCmd(latex.slice(1), selection);
          }
          else
            cursor.insertCh(latex);
          if (block.blurred) cursor.hide().parent.blur();
        }
      });
  case 'touchtap':
    var touchstartTarget = arguments[1], x = arguments[2], y = arguments[3];
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;
      if (cursor && touchstartTarget !== cursor.handle[0]) {
        var wasBlurred = block.blurred;
        block.textarea.children().focus();
        cursor.seek(elAtPt(x, y, block), x, y, cachedClientRectFnForNewCache(), true);
        if (!wasBlurred) cursor.showHandle();
      }
    });
  case 'ignoreNextMousedown':
    var time = arguments[1];
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block) {
        block.ignoreMousedownTimeout = setTimeout(function() {
          block.ignoreMousedownTimeout = undefined;
        }, time);
      }
    });
  case 'moveStart':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    if (block && block.cursor)
      block.cursor.prependTo(block);
    break;
  case 'moveEnd':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    if (block && block.cursor)
      block.cursor.appendTo(block);
    break;
  case 'isAtStart':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (cursor) return cursor.parent === cursor.root && !cursor.prev;
    break;
  case 'isAtEnd':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (cursor) return cursor.parent === cursor.root && !cursor.next;
    break;
  case 'selection':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (!cursor) return;
    return cursor.selection ? '$'+cursor.selection.latex()+'$' : '';
  case 'clearSelection':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;
      if (cursor) {
        cursor.clearSelection();
        if (block.blurred) cursor.hide().parent.blur();
      }
    });
  default:
    var textbox = cmd === 'textbox',
      editable = textbox || cmd === 'editable',
      RootBlock = textbox ? RootTextBlock : RootMathBlock;
    return this.each(function() {
      createRoot($(this), RootBlock(), textbox, editable);
    });
  }
};

//on document ready, mathquill-ify all `<tag class="mathquill-*">latex</tag>`
//elements according to their CSS class.
$(function() {
  $('.mathquill-editable:not(.mathquill-rendered-math)').mathquill('editable');
  $('.mathquill-textbox:not(.mathquill-rendered-math)').mathquill('textbox');
  $('.mathquill-embedded-latex').mathquill();
});


}());

define("mathquill", function(){});

define('template!expression_item', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) { 
;__p+='\n\n<div class="do-not-blur expressionitem shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
 } else { 
;__p+='\n\n<div class="do-not-blur expressionitem">\n  <div class=\'fade-container\'>\n\n    <div class="fadeout-left"></div>\n  \n    <span class="main">\n      <span class="transient-mathquill"></span>\n      <span class="template-mathquill"></span>\n    </span>\n\n    <span class="fadeout"></span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n\n    <div class="template-bottom"></div>\n  </div>\n\n  <span class="tab action-drag action-icon-touch"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="num variable-index"></span>\n    <span class="tab-interior action-icon-mouse">\n      <span class="template-expricon"></span>\n    </span>\n  </span>\n\n\n  <span class="exp-actions">\n    <span class="graphic" handleEvent="true"></span>\n    <nobr>\n      <span class="action-delete delete-btn tooltip" handleEvent="true" tooltip="'+
( t('Delete') )+
'"><i class=\'icon-remove\'></i></span>\n      <span class="action-duplicate duplicate-btn tooltip" handleEvent="true" tooltip="'+
( t('Duplicate') )+
'"><i class=\'icon-duplicate\'></i></span>\n      <span class="action-createtable tooltip" tooltip="'+
( t('Convert to Table') )+
'" handleEvent="true">\n        <i class=\'icon-table\'></i>\n      </span>\n    </nobr>\n  </span>\n</div>\n\n';
 } 
;__p+='\n';
}
return __p;
};});
define('expressions/abstractitem_view',['require','pjs','jquery','lib/underscore_view','undoredo'],function(require) {
  var P = require('pjs');
  var $ = require('jquery');
  var UnderscoreView = require('lib/underscore_view');
  var UndoRedo = require('undoredo');

  var AbstractItemView = P(UnderscoreView, function (view, _super) {
    view.init = function (model, listView) {
      _super.init.call(this);
      
      this.model = model;
      this.listView = listView;
      
      // do this now instead of letting renderSelected do this. If we wait
      // for renderSelected to do it, we'll end up calling rerender within a
      // already started render loop. That'll cause events to get bound twice
      // and other weird stuff will happen.
      if (this.model.selected) {
        this.model.renderShell = false;
      }
      
      this.model.observe('index.itemview', this.renderIndex.bind(this));
      this.model.observe('selected.itemview', this.renderSelected.bind(this));
      this.model.observe('renderShell.itemview', this.rerender.bind(this));
      this.model.observe('folder.itemview', this.renderFolder.bind(this));
      this.model.observe('inCollapsedFolder.itemview', this.renderCollapsedFolder.bind(this));
    };

    //triggered from list_view when projector mode is changed
    //override from the different item type views. right now, just text_view overrides
    view.onProjectorModeChange = function() {};

    view.destruct = function () {
      this.model.unobserve('.itemview');
      this.setProperty('transient', false);
    };
    
    view.getTemplateParams = function () {
      return {
        renderShell: this.model.renderShell,
        inCollapsedFolder: this.model.inCollapsedFolder
      };
    };

    view.renderIndex = function () {
      var index = this.model.index;
      this.$().attr('index', index);
      this.$('.variable-index').text(index+1);
    };

    view.renderFolder = function () {
      this.$().toggleClass('inFolder', !!this.model.folder);
    };

    view.renderCollapsedFolder = function(){
      this.$().toggleClass('inCollapsedFolder', !!this.model.inCollapsedFolder);
      // Redraw any child mathquills so they can update the size of things like parens.
      if (!this.model.inCollapsedFolder) this.$('.mathquill-rendered-math').mathquill('redraw');
    };

    view.renderSelected = function () {
      if (this.model.selected) {
        if (this.model.renderShell) {
          this.model.setProperty('renderShell', false);
        }
      }
      
      this.$().toggleClass('selected', !!this.model.selected);
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      var self = this;
      this.$().on('tap tapstart', function (evt) {
        // when using mouse, fire on 'tapStart' and when on touch we
        // fire on the 'tap' event.
        if (evt.type === 'tap' && evt.device === 'mouse') return;
        if (evt.type === 'tapstart' && evt.device === 'touch') return;
        
        self.onMouseSelect(evt);
      });
      
      this.$('.action-drag').on('tapstart', this.onDragPending.bind(this));
      this.$('.action-delete').on('tap', this.onDelete.bind(this));
      
      this.$().attr('expr-id', this.model.id);
      this.renderIndex();
      this.renderSelected();
      this.renderFolder();
      this.renderCollapsedFolder();
    };
  
    view.triggerDelete = function () {};
    view.triggerEnterPressed = function () {};
    view.triggerUpPressed = function () {};
    view.triggerDownPressed = function () {};
    view.triggerBackspacePressed = function () {};
    view.triggerDelPressed = function () {};
    view.onMouseSelect = function () {};

    view.sendTapToMathQuill = function(evt, mq) {
      // stop the mathquill from losing focus immediately. Only do this when
      // using mouse. When on ipad, this stops you from being able to put
      // cursor. And when on ipad, focus doesn't get lost anyways.
      if (evt.device === 'mouse') {
        evt.preventDefault();
      }
      
      /*
      * This will simualte a mousedown on the mathquill itself so that
      * you can start a mouse selection from outside of mathquill. But,
      * this doesn't make much sense for ipad because we don't do selection on
      * mousedown for ipad, we do it on click. That's because we want scroll
      * to work. We also don't want to pass the event into mathquill if it
      * originally started in mathquill.
      */
      if (evt.device === 'mouse') {
        
        // let mathquill handle the event
        if ($.contains(mq[0], evt.target)) return;
        
        // the event we're looking at is of type 'tapstart' and that means
        // nothing to mathquill. We need to turn this back into a 'mousedown'
        // so that it can handle it normally.
        var fakeEvent = $.event.fix(evt.originalEvent);
  
        // pass into mathquill so it can act like it happened within mathquill
        mq.triggerHandler(fakeEvent);
      }
      
      // on ipad, use MathQuill API
      else {
        var touch = evt.originalEvent.changedTouches[0];
        mq.mathquill('touchtap', touch.target, touch.clientX, touch.clientY)
                      .mathquill('ignoreNextMousedown', 1000);
      }
    };

    view.onDelete = function() {
      this.triggerDelete();
    };

    view.convertTo = function (cls, state) {
      
      var obj = cls(state);
      var index = this.model.index;
      
      var list = this.model.list;
      var folder = this.model.folder;

      obj.setProperty('list', list);

      UndoRedo.oneTransaction(function(){
        list.removeItemAt(index);
        list.insertItemAt(index, obj);
        if (folder) folder.addItem(obj);
      });
      
      return obj;
    };

    view.getBounds = function () {
      var dom = this.$();
      var offset = dom.offset();
      if (!offset) return null;

      var top = offset.top;
      var height = dom.height();

      return {
        top: top,
        bottom: top + height
      };
    };
    
    // override in subclass
    view.allowDragDrop = function () {
      return true;
    };
   
    view.onDragPending = function(evt) {
      
      // clear focus when clicking expression handle
      $(document.activeElement).blur();
      
      // don't start dragging if we're not allowed to
      if (!this.allowDragDrop()) return;
      var self = this;
      this.mouseMovedTo = null;
      
      //if timeout happens or mouse moves sufficiently far, we will start dragging
      //if mouseup, then this was a tap, and we should let it do its thing

      //Start after 500ms
      var dragStartTimeout = setTimeout(function(){
        $(document).off('.dragpending');
        self.onDragStart(evt);
      }, 500);

      //Start after moving
      $(document).on('tapmove.dragpending', function(new_evt){
        // mouse has moved since tapstart. record this in case we actually do start dragging
        self.mouseMovedTo = new_evt.touches[0];
        
        var dx = evt.touches[0].x - self.mouseMovedTo.x;
        var dy = evt.touches[0].y - self.mouseMovedTo.y;
        
        // must have moved more than 3px away from tapstart position to immediately trigger drag
        if (Math.sqrt(dx*dx+dy*dy) > 3) {
          clearTimeout(dragStartTimeout);
          $(document).off('.dragpending');
          self.onDragStart(evt);
        }
      });

      //Cancel on mouseup
      $(document).on('tapend.dragpending', function(new_evt){
        clearTimeout(dragStartTimeout);
        $(document).off('.dragpending');
      });
    };
 
    view.onDragStart = function(evt) {
      // don't start dragging if we're not allowed to
      if (!this.allowDragDrop()) return;
      this.listView.dragdrop_expressions.start(evt, this);
      
      // we've moved our mouse since the initial tapstart. drag the expression to that point
      if (this.mouseMovedTo) {
        this.listView.dragdrop_expressions.drag(this.mouseMovedTo.x, this.mouseMovedTo.y);
      }
    };

    view.hideContextMenu = function () {
      // TODO - temporary until we have a better popup menu manager
      if (window.opened_options_menu) {
        window.opened_options_menu.hideOptions();
      }
    };
    
    view.processMissedKeyEvent = function (evt) {};
    view.addFocus = function (where) {};
    view.isFocused = function () {return false};
  });

  return AbstractItemView;
});

//TODO: merge expression_view_tablet and expression_view_deskopt into this file
define('expressions/expression_view',['require','jquery','pjs','config','./expression_icon_view','expressions/evaluation','expressions/domain_view','expressions/slider_view','expressions/promptslider_view','./expression','graphing/columnmode','main/toast','./text','./table','mathquill','lib/keys','undoredo','lib/track_feature','template!expression_item','expressions/abstractitem_view'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var Config = require('config');
  var ExpressionIconView = require('./expression_icon_view');
  var EvaluationView = require('expressions/evaluation');
  var DomainView = require('expressions/domain_view');
  var SliderView = require('expressions/slider_view');
  var PromptSliderView = require('expressions/promptslider_view');
  var ExpressionObject = require('./expression');
  var COLUMNMODE = require('graphing/columnmode');
  var Toast = require('main/toast');

  //For convert-to text and convert-to-table
  var TextObject = require('./text');
  var TableObject = require('./table');

  require('mathquill');
  var Keys = require('lib/keys');
  var UndoRedo = require('undoredo');
  var Feature = require('lib/track_feature');

  var template = require('template!expression_item');
  
  var AbstractItemView = require('expressions/abstractitem_view');
  
  var ExpressionView = P(AbstractItemView, function(view, _super) {
    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      
      this.model.observe('formula.exprview', this.onFormulaChange.bind(this));
      this.model.observe('selected.exprview', this.onSelectedChange.bind(this));
      this.model.observe('latex.exprview', this.onLatexChange.bind(this));
      this.model.observe('dependent.exprview', this.renderDependent.bind(this));
      this.model.observe('isTableable.exprview', this.renderIsTableable.bind(this));
      
      this.observe('shouldExpand', this.observeShouldExpand.bind(this));
      this.observe('doAnimate', this.renderDoAnimate.bind(this));
      this.observe('expanded', this.renderExpanded.bind(this));

    };

    view.renderIsTableable = function(){
      this.$('.action-createtable').toggleClass('disabled', !this.model.isTableable);
    };
    
    view.destruct = function () {
      _super.destruct.call(this);
      
      this.model.unobserve('.exprview');
      
      if (this.iconView) {
        this.iconView.remove();
        this.iconView = null;
      }
         
      if (this.sliderView) {
        // Trigger our removal from the slider timer.
        this.sliderView.remove();
        this.sliderView = null;
      }
      
      if (this.promptSliderView) {
        this.promptSliderView.remove();
        this.promptSliderView = null;
      }
      
      if (this.domainView) {
        this.domainView.remove();
        this.domainView = null;
      }
      
      if (this.evaluationView) {
        this.evaluationView.remove();
        this.evaluationView = null;
      }
    };
    
    view.renderExpanded = function () {
      this.$().toggleClass('expanded', !!this.expanded);
    };
    
    view.renderDoAnimate = function () {
      this.$().toggleClass('do-animate', !!this.doAnimate);
    };

    view.onLatexChange = function() {
      if (this.sliderView && this.sliderView.slider.transient) {
        this.updateTransientValue();
        return;
      }

      var latex = this.model.latex;
      if (latex === '"' || latex === "'") {
        this.convertTo(TextObject, {selected:true});
        this.listView.getSelectedView().addFocus();
        return;
      }
      //call up to list_view, so that other listeners can listen
      this.listView.onLatexChange(latex);

      this.updateMathquill();
    };
    
    view.updateMathquill = function () {
      if (!this.mathquill) return;
      
      var latex = this.model.latex;
      
      if (latex !== undefined && this.mathquill.mathquill('latex') !== latex)
        this.mathquill.mathquill('latex', latex);
    };

    view.updateTransientValue = function () {
      this.$transientValue[0].innerHTML = (
        this.model.slider.computeSnappedValue(this.model.slider.value)
        .toString()
        .replace('-', '<span class="unary-operator">\u2212</span>')
      );
    };

    // OVERRIDE TO CREATE APPROPRIATE CHILD VIEW. IF NOT OVERRIDDEN, THE
    // VIEW WILL SIMPLY NOT BE CREATED AT RUNTIME.
    view.createIconView = function () {
      return ExpressionIconView(this);
    };
    view.createSliderView = function () {
      return SliderView(this.model.slider, this);
    };
    view.createPromptSliderView = function () {
      return PromptSliderView(this);
    };
    view.createDomainView = function () {
      return DomainView(this.model.domain);
    };
    view.createEvaluationView = function () {
      return EvaluationView(this);
    };
        
    view.onFormulaChange = function() {
      
      // Skip this while we are rendering shell. Without this catch, we'd
      // create the child views while rendring the shells and throw them
      // away when we render fully.
      if (this.model.renderShell) return;
      
      var formula = this.model.formula;
      
      var showSlider = formula.is_slidable;
      if (this.sliderView && !showSlider) {
        this.sliderView.slider.unobserve('.expressionView');
        this.sliderView.remove();
        this.sliderView = null;
        this.$().removeClass('hasSlider');
      } else if (!this.sliderView && showSlider) {
        this.sliderView = this.createSliderView();
        if (this.sliderView) {
          this.sliderView.appendTo(this.$('.template-bottom'));
          this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
          this.$().addClass('hasSlider');
          this.sliderView.slider.observe(
            'transient.expressionView',
            this.updateTransient.bind(this)
          );
        }
      }
      
      var promptCreateSlider = formula.variables.length > 0;
      if (this.promptSliderView && !promptCreateSlider) {
        this.promptSliderView.remove();
        this.promptSliderView = null;
      } else if (!this.promptSliderView && promptCreateSlider) {
        this.promptSliderView = this.createPromptSliderView();
        if (this.promptSliderView) {
          this.promptSliderView.appendTo(this.$('.template-bottom'));
        }
      }
      
      var showDomain = formula.is_parametric;
      if (this.domainView && !showDomain) {
        this.domainView.remove();
        this.domainView = null;
        this.$().removeClass('hasDomain');
      } else if (!this.domainView && showDomain) {
        this.domainView = this.createDomainView();
        if (this.domainView) {
          this.domainView.appendTo(this.$('.template-bottom'));
          this.$().addClass('hasDomain');
        }
      }
      
      var showEvaluation = formula.is_evaluable;
      if (this.evaluationView && !showEvaluation) {
        this.evaluationView.remove();
        this.evaluationView = null;
      } else if (!this.evaluationView && showEvaluation) {
        this.evaluationView = this.createEvaluationView();
        if (this.evaluationView) {
          this.evaluationView.appendTo(this.$('.template-bottom'));
          this.$().addClass('hasEvaluation');
          this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
        }
      }
      
      if (this.sliderView && !this.sliderView.slider.transient) {
        this.model.slider.setProperty('value', formula.simple_constant);
      }
      
      if (this.promptSliderView) {
       this.promptSliderView.setProperty('variables', formula.variables);
      }
      
      if (this.evaluationView) {
        this.evaluationView.setProperty('evaluations', formula.zero_values);
      }

      var shouldExpand = !!(this.evaluationView ||
                            this.promptSliderView ||
                            this.sliderView ||
                            this.domainView);
                            
      this.setProperty('shouldExpand', shouldExpand);
    };
    
    view.renderDependent = function () {
      if (this.sliderView) {
        this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
      }
      if (this.evaluationView) {
        this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
      }
    };
    
    // NOTE: this will get called once with model.renderShell = true and once
    // with model.renderShell = false. The first time, the template will
    // shortcircuit and render the bare minimum. The second time the entire
    // dom will get destroyed and rebuilt. We don't want to add any nested
    // views when model.renderShell = false because the views' dom elements will
    // get wiped out as soon as we render with model.renderShell = false. And,
    // the whole point of renderShell=true is that we want as little as
    // possible to happen at startup as possible.
    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell)  return;
     
      this.mathquill = this.$('.template-mathquill').mathquill('editable');
      this.$transientLhs =
        this.$('.transient-mathquill').mathquill('editable')
      ;
      this.$transientLhs.hide();
      this.$transientValue = $('<span>');
      
      this.mathquill.on(
        'render upPressed downPressed enterPressed backspacePressed delPressed keydown focusin focus',
        this.onMathquillEvent.bind(this)
      );
      this.$transientLhs.on('tapstart', this.onSelectTransient.bind(this));
      this.mathquill.mathquill('latex', this.model.latex || "");
      
      this.iconView = this.createIconView();
      if (this.iconView) {
        this.iconView.replace(this.$('.template-expricon'));
      }
      
      this.$('.action-duplicate').on('tap', this.onDuplicateWithoutFocus.bind(this));
      this.$('.action-createtable').on('tap', this.onCreateTable.bind(this));
      
      this.renderDoAnimate();
      this.renderExpanded();
      this.renderIsTableable();
      this.onFormulaChange();
    };


    view.onSelectedChange = function() {
      if (!this.model.selected && this.mathquill) {
        // take focus out of mathquill
        this.mathquill.mathquill('clearSelection').mathquill('blur');
      }
    };
    
    view.onSelectTransient = function () {
      this.stopTransient();
      this.mathquill.mathquill('focus');
    };
    
    view.onMathquillEvent = function(evt) {
      switch(evt.type) {
        case "render":
        this.model.setProperty('latex', this.mathquill.mathquill('latex'));
        return;

        case "focus":
        case "focusin":
          if (this.sliderView) this.sliderView.slider.setProperty('isPlaying', false);
          this.model.setProperty('selected', true);
          return;

        case "upPressed":
        this.triggerUpPressed();
        return;

        case "downPressed":
        this.triggerDownPressed();
        return;

        case "enterPressed":
        this.triggerEnterPressed();
        return;

        case "backspacePressed":
        if (!this.model.isEmpty()) return;
        this.triggerBackspacePressed();
        return;

        case "delPressed":
        if (!this.model.isEmpty()) return;
        this.triggerDelPressed();
        return;

        case "keydown":
        if (Keys.lookup(evt) === Keys.ESCAPE) $(document.activeElement).blur();
        return;
      }
    };

    view.createSliders = function (vars) {
      // build the list of states
      // this is important, because the first time, it will generate
      // an id for us automatically. If we undo then redo, we need to
      // reusue the generated ids.
      // set slider min/max so that they don't
      // get set automatically and messup undo/redo
      var var_states = [];
      for (var i=0; i<vars.length; i++) {
        var_states.push({
          latex: vars[i] + '=1',
          sliderMin: -10, // TODO - combine this lines into:
          sliderMax: 10,   // slider: {min: -10, max: 10}
          userRequestedGraphing: "never" //don't show a circle when we create an r= slider
        });
      }

      var index = this.model.index;
      var folder = this.model.folder;
      var next_index = index + 1;

      var list = this.model.list;
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,

        undo: function() {
          for (var i=0; i<vars.length; i++) {
            list.removeItemAt(next_index);
          }
        },

        redo: function() {
          for (var i = var_states.length - 1; i >= 0; i--) {
            var obj = ExpressionObject(var_states[i], list);
            var_states[i].id = obj.id; // store the generated id for next time
            list.insertItemAt(next_index, obj);
            if (folder) folder.addItem(obj);
          }
        }
      });
      this.tempDisableAnimate();
    };

    view.onDuplicate = function() {
      var obj = this.onDuplicateWithoutFocus();
      var view = this.listView.getItemView(obj.id);
      view.addFocus();
    };

    view.onDuplicateWithoutFocus = function() {
      var index = this.model.index;
      var state = this.model.getState();
      state.selected = false;
      delete state.id;

      var obj = ExpressionObject(state, this.model.list);
      this.model.list.insertItemAt(index + 1, obj);
      return obj;
    };

    view.onMouseSelect = function(evt) {
      if (this.listView.editListMode) return;

      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
      
      this.sendTapToMathQuill(evt, this.mathquill);
    };
    
    view.getDependentLabel = function () {
      var dependent = this.model.dependent;
      if (!dependent) return '';

      //reformat to add back in brackets if we have a subscript
      if (dependent.match(/(.*)_(.+)/)) {
        dependent = dependent.replace(/(.*)_(.+)/, "$1_{$2}");
      }

      // ask mathquill for an html version of itself
      // note: this will break for things like parentheses, which need to be
      // inserted into the dom to know their correct size we should probably
      // be passing around mathquill objects instead of strings, but this
      // works for uncomplicated mathquill
      dependent = $(
        "<span>" +
        dependent +
        "</span>"
      ).mathquill('editable').mathquill('html');

      // surround it in the right class so that it can pull in mathquill
      // stylings
      dependent = (
        "<span class='mathquill-rendered-math'>" +
        dependent +
        "</span>"
      );

      return dependent;
    };


    //the following three function determine the animation
    //and delay of the bottom area under expressions
    //that house sliders, evaluations, etc

    //temporarily disable animation on this expression
    //called after adding a slider from a button, for example
    view.tempDisableAnimate = function() {
      var self = this;
      self.setProperty('doAnimate', false);
      clearTimeout(self.restoreAnimationTimeout);
      self.restoreAnimationTimeout = setTimeout(function() {
        self.setProperty('doAnimate', true);
      }, 500);
    };

    view.observeShouldExpand = function() {
      var self = this;
      clearTimeout(self.animateTimeout);
      if (this.doAnimate) {
        self.animateTimeout = setTimeout(function() {
          self.setProperty('expanded', self.shouldExpand);
        }, 500);
      } else {
        //immediately expand/collapse when animation is disabled (initial load)
        self.setProperty('expanded', self.shouldExpand);
      }
    };

    var lhs = function (latex) {
      return latex.replace(RegExp("=[^=]+$"), "=");
    };

    view.startTransient = function () {
      this.setProperty('transient', true);
      this.updateTransientValue();
      this.$transientLhs.show();
      this.mathquill.hide();
      this.$transientLhs.mathquill('latex', lhs(this.model.latex));
      this.$transientLhs
        .children('.mathquill-root-block')
        .append(this.$transientValue)
      ;
    };

    view.stopTransient = function () {
      this.setProperty('transient', false);
      this.$transientValue.remove();
      this.$transientLhs.hide();
      this.mathquill.show();
      this.updateMathquill();
    };

    view.updateTransient = function () {
      if (this.sliderView.slider.transient) {
        this.startTransient();
      } else {
        this.stopTransient();
      }
    };
    
    view.isFocused = function () {
      return $(document.activeElement).closest(this.mathquill).length !== 0;
    };
    
    view.addFocus = function (where) {
      if (Config.get('no_focus')) return;
      if (!this.mathquill) return;
      
      this.mathquill.mathquill('focus');
      
      if (where === 'start') {
        this.mathquill.mathquill('moveStart');
      } else if (where === 'end') {
        this.mathquill.mathquill('moveEnd');
      }
    };

    view.onCreateTable = function () {
      var formula = this.model.formula;

      Feature.use("convert to table");

      if (!this.model.isTableable) return;

      var table_info = formula.table_info;
      var index = this.model.index;
      var state = {selected : true};

      var columnMode = COLUMNMODE.POINTS_AND_LINES;
      if (formula.is_point_list || this.model.userRequestedGraphing === "never")
        columnMode = COLUMNMODE.POINTS;

      var i;
      var independent_values = [];
      var dependent_values = [];
      if(table_info.values){
        for(i = 0; i < table_info.values.length; i++){
        independent_values.push(table_info.values[i][0]);
        dependent_values.push(table_info.values[i][1]);
        }
      }
      else{
        for(i = -2; i <=2; i++){
          independent_values.push(i);
          dependent_values.push('');
        }
      }

      state.columns = [{
                          latex:table_info.independent_variable,
                          values: independent_values
                        },{
                          latex:table_info.dependent_column,
                          color: this.model.color,
                          hidden: false,
                          columnMode: columnMode,
                          values: dependent_values
                        }];

      var list = this.model.list;
      var listView = this.listView;
      listView.setProperty('editListMode', false);
      UndoRedo.oneTransaction(function(){
        if (!table_info.by_reference) {
          list.removeItemAt(index);
          index--;
        }
        
        var obj = TableObject(state, list);
        list.insertItemAt(index+1, obj);
      });

      Toast.show("Table created.", function () {
        listView.setProperty('editListMode', true);
      });

    };
  });
  
  return ExpressionView;
});

define('template!text', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) { 
;__p+='\n\n<div class="do-not-blur expressionitem expressiontext shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
 } else { 
;__p+='\n\n<div class="do-not-blur expressiontext expressionitem">\n  <div class=\'fade-container\'>\n\n    <span class="main">\n      <textarea class="do-blur" placeholder="'+
( t('enter some text...') )+
'"></textarea>\n      <div class="displayTextarea"></div>\n    </span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="tab action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'num variable-index\'></span>\n    <div class=\'tab-interior\'></div>\n    <i class=\'icon-text\'></i>\n  </span>\n\n  <span class=\'exp-actions\'>\n    <span\n      class="action-delete delete-btn tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'icon-remove\'></i>\n    </span>\n  </span>\n\n</div>\n\n';
 } 
;__p+='';
}
return __p;
};});
define('expressions/text_view',['require','jquery','pjs','./abstractitem_view','lib/keys','template!text','lib/browser'],function(require) {
  var $ = require('jquery');
  var P = require('pjs');
  var AbstractItemView = require('./abstractitem_view');
  var Keys = require('lib/keys');
  var template = require('template!text');
  var Browser = require('lib/browser');

  var TextView = P(AbstractItemView, function(view, _super) {
    
    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      
      this.model.observe('selected.textview', this.onSelectedChange.bind(this));
      this.model.observe('text.textview', this.renderText.bind(this));
    };
    
    view.destruct = function () {
      this.model.unobserve('.textview');
    };

    view.onProjectorModeChange = function() {
      this.fitText();
    };
    
    view.renderText = function () {
      var textarea = this.$('textarea')[0];
      var $displayText = this.$('.displayTextarea');
      if (!textarea) return;
      
      textarea.value = this.model.text;
      $displayText.html(this.model.markedUpText());
      this.fitText();
      this.$().toggleClass('empty', this.model.isEmpty());
      setTimeout(this.fitText.bind(this), 1); //TODO - do we still need this?
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      if (this.model.renderShell) return;
      
      var $textarea = this.$('textarea');
      var $displayText = this.$('.displayTextarea');
      if (this.renderShell) return;

      $displayText.on('tap tapstart', function(evt) {
        // This would be tons easier with pointer-events, but alas IE9 is too picky
        // We are going to stop clicks on links and let the rest filter through to
        // the focus() handler below. In essence, this is an IE-friendly way of doing
        // 'pointer-events: none' on the div and 'pointer-events: auto' on all child <a> tags
        if (evt.target.tagName === "A") {
          evt.handle();
        }
      }.bind(this));

      $textarea.focus(function(){
        this.model.setProperty('selected', true);
      }.bind(this));

      $textarea.bind('keydown keypress keyup change cut paste', this.onTextareaEvent.bind(this));
      this.renderText();
    };
    
    view.onTextareaEvent = function (evt) {
      var ta = this.$('textarea')[0];
      var ta_is_active = ta && ta === document.activeElement;
      var ta_len = ta_is_active ? ta.value.length : 0;
      var key = ta_is_active && evt.type === 'keydown' ? Keys.lookup(evt) : '';

      // pressing enter inside textarea creates a new expression underneath
      if (key === Keys.ENTER) {
          
        evt.preventDefault();
        this.triggerEnterPressed();
        return;
        
      // pressing escape removes focus
      } else if (key === Keys.ESCAPE) {
        $(document.activeElement).blur();
        return;
           
      // pressing up while at start of textarea selects expression above
      } else if (key === Keys.UP) {

        if (ta.selectionStart === 0 && ta.selectionEnd === 0) {
          evt.preventDefault();
          this.triggerUpPressed();
        }
        return;
        
      // pressing down while at end of textarea selects expression below
      } else if (key === Keys.DOWN) {

        if (ta.selectionStart === ta_len && ta.selectionEnd === ta_len) {
          evt.preventDefault();
          this.triggerDownPressed();
        }
        return;

      // pressing backspace when completely empty should delete textarea
      } else if (key === Keys.BACKSPACE) {
          
        if (ta_len === 0) {
          evt.preventDefault();
          this.triggerBackspacePressed();
        }
        return;
         
      // pressing delete when completely empty should delete textarea
      } else if (key === Keys.DELETE) {
        
        if (ta_len === 0) {
          evt.preventDefault();
          this.triggerDelPressed();
        }
        return;
          
      }
      
      // if we made it down here, then we should update the stored text value
      this.model.setProperty('text', ta.value);
    };

    view.onSelectedChange = function() {
      var $textarea = this.$('textarea');
      if (!this.model.selected) {
        if ($textarea[0]) $textarea[0].blur();
      }
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
    };
    
    view.fitText = function () {
      var $textarea = this.$('textarea');
      var textarea = $textarea[0];
      if (!textarea) return;
      
      var rows=0;
        do {
          rows++;
          $textarea.attr('rows',rows);
      } while (textarea.clientHeight < textarea.scrollHeight);
    };
    
    view.isFocused = function () {
      return $(document.activeElement).closest(this.$()).length !== 0;
    };
    
    view.addFocus = function (where) {
      
      // Can't reliably focus textarea programatically from within iframe on ipad
      // see #3106
      if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        return;
      }
      
      var textarea = this.$('textarea')[0];
      if (!textarea) return;

      textarea.focus();
      if (where === 'end') {
        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
      } else if (where === 'start') {
        textarea.selectionStart = textarea.selectionEnd = 0;
      }
    };
        
  });

  return TextView;
});

define('template!table_icon', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="icon-box variable-errortooltip tipsy-sticky action-icon do-not-blur" \n      handleevent="true"\n      disablescroll="true"\n>\n  <span class="icon graph-icon variable-colorcss">\n    <i class=\'icon-hidden\'></i>\n\t</span>\n</span>';
}
return __p;
};});
define('template!table_column_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'table-column-menu options-menu\'>\n  <div class=\'triangle\'></div>\n  <div class=\'styles-div\'>\n    <div class=\'title\'>'+
( t('style:') )+
'</div>\n    <div>\n      <span class=\'columnmode-option graph-icon table-points variable-colorcss\' mode="POINTS"></span>\n      <span class=\'columnmode-option graph-icon table-lines variable-colorcss\' mode="LINES"></span>\n      <span class=\'columnmode-option graph-icon table-points-and-lines variable-colorcss\' mode="POINTS_AND_LINES"></span>\n    </div>\n  </div>\n  <div class=\'colors-div\'>\n    <div class=\'title\'>'+
( t('color:') )+
'</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>';
}
return __p;
};});
define('expressions/table_column_menu_view',['require','pjs','lib/underscore_view','template!table_column_menu','jquery','./color_menu_view'],function(require){
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var template = require('template!table_column_menu');
  var $ = require('jquery');
  var ColorMenuView = require('./color_menu_view');
    
  var TableColorMenuView = P(UnderscoreView, function (view, _super) {
    view.template = template;
    
    view.init = function (parentView, column) {
      _super.init.call(this);
      this.column = column;
      this.parentView = parentView;

      this.column.observe('color.columnmenuview', this.renderColorCSS.bind(this));
      this.column.observe('columnMode.columnmenuview', this.renderSelectedColumnMode.bind(this));
      this.column.observe('shouldGraph.columnmenuview', this.renderSelectedColumnMode.bind(this));
    };
    
    view.destruct = function () {
     this.column.unobserve('.columnmenuview');
    };
    
    view.renderColorCSS = function () {
      var color = this.column.color;
      this.$('.variable-colorcss').css({
        'border-color' : color,
        'background-color': color
      });
    };
    
    view.renderSelectedColumnMode = function () {
      this.$('.columnmode-option').removeClass('selected');
      
      if (this.column.shouldGraph) {
        var columnMode = this.column.columnMode;
        this.$('.columnmode-option[mode="'+columnMode+'"]').addClass('selected');
      }
    };
    
    view.didInsertElement = function () {
      this.$().on('tap tapstart', '.columnmode-option', this.onSelectColumnMode.bind(this));
      this.renderColorCSS();
      this.renderSelectedColumnMode();
      
      // this view has a nested template. We instantiate the color picker
      // and replace a placeholder element within the html.
      var colorsView = ColorMenuView(this.column);
      colorsView.replace(this.$('.template-colorsview'));
    };
    
    view.onSelectColumnMode = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;

      var columnMode = $(evt.target).closest('.columnmode-option').attr('mode');
      
      // the column is visible and we've clicked the same columnMode again; hide the column and return
      if (!this.column.hidden && this.column.columnMode === columnMode) {
        this.column.setProperty('hidden', true);
        return;
      }
     
      this.column.setProperty('columnMode', columnMode);
      this.column.setProperty('hidden', false);
      
      // making column visible should make folder visible
      var folder = this.column.table.folder;
      if (folder) {
        folder.setProperty('hidden', false);
      }
    };
    
  });
  
  return TableColorMenuView;
});

define('expressions/table_icon_view',['require','jquery','./abstract_icon','pjs','template!table_icon','graphing/columnmode','./table_column_menu_view'],function(require){
  var $ = require('jquery');
  var AbstractIconView = require('./abstract_icon');
  var P = require('pjs');
  var template = require('template!table_icon');
  var COLUMNMODE = require('graphing/columnmode');
  var TableColumnMenuView = require('./table_column_menu_view');
  
  var TableIconView = P(AbstractIconView, function (view, _super) {
    view.template = template;
    
    view.init = function (parentView) {
      _super.init.call(this, parentView);
      this.column = this.model;
      this.listView = parentView.tableView.listView;
      
      this.column.observe('color.iconview', this.renderColorCSS.bind(this));
      this.column.observe('error.iconview', this.onDisplayChange.bind(this));
      this.column.observe('columnMode.iconview', this.onDisplayChange.bind(this));
      this.column.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
    };
    
    view.destruct = function () {
      _super.destruct.call(this);
      
      this.column.unobserve('.iconview');
    };
    
    view.renderErrorShown = function () {
      this.$('.icon').toggleClass('error', !!this.errorShown);
      this.$().closest('.cell').toggleClass('error', !!this.errorShown);
    };
    
    view.renderColorCSS = function() {
      this.$('.variable-colorcss').css('border-color', this.column.color);
      this.$('.variable-colorcss').css('background', this.column.color);
    };
    
    view.toggleGraphShown = function() {
      if (!this.column.isGraphable) return;
      if (this.errorShown) return;

      // Trying to edit whether a graph is shown in a hidden folder should
      // show the folder.
      if (this.model.table.folder && this.model.table.folder.hidden) {
        this.model.table.folder.setProperty('hidden', false);
        return;
      }

      this.column.setProperty("hidden", !this.column.hidden);
    };
    
    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      var self = this;
      function handleIconTap (evt) {
        if (evt.wasHandled('dragdrop')) return;
        if (evt.wasLongheld()) return;
        
        if (self.optionsShown) {
          self.hideOptions();
          return;
        }
        
        if (self.listView.editListMode) {
          self.toggleOptions();
        } else {
          self.toggleGraphShown();
        }
      }
      
      function handleIconLongHold (evt) {
        if (self.optionsShown) return;
        self.toggleOptions(); // will create TableColumnMenuView
      }
      
      function handleIconTapStart (evt_orig) {
        if (self.optionsShown) return;
        if (evt_orig.touches.length !== 1) return;
        
        // if we lift up before moving, stop listening to moves
        $(document).on('tapend.dragdrop tapcancel.dragdrop', function () {
          $(document).off('.dragdrop');
        });
        
        $(document).on('tapmove.dragdrop', function (evt) {
          $(document).off('.dragdrop');

          if (evt.touches.length === 1 && !evt.wasLongheld()) {
            self.listView.dragdrop_columns.start(evt_orig, self.parentView);
          }
        });
      }
      
      this.$('.action-icon').on('tap', handleIconTap);
      this.$('.action-icon').on('longhold', handleIconLongHold);
      this.$('.action-icon').on('tapstart', handleIconTapStart);

      this.renderColorCSS();
      this.onDisplayChange();
      
      this.$icon = this.$('.icon');
    };
    
    view.createOptionsMenuView = function () {
      var optionsView = TableColumnMenuView(this, this.column);
       optionsView.appendTo('#main');
       
       // putting the column menu view at the topLeft of the .icon-box
       // it's up to the column menu view's css to position it beyond that
       var placeholder = this.$('.icon-box');
       var offset = placeholder.offset();
       optionsView.$().css({
         position: 'absolute',
         top: offset.top + 'px',
         left: offset.left + 'px',
         display: 'block' //wait until we know where it is to show it. fixes #3154
       });
       
       return optionsView;
    };

    view.onDisplayChange = function () {
      _super.onDisplayChange.call(this);
      if (!this.$icon) return;
      
      var shouldGraph = this.column.shouldGraph;
      var columnMode = this.column.columnMode;
      var isGraphable = this.column.isGraphable;
      var icon_class = '';
     
      if (this.error || !isGraphable) {
        icon_class = '';
      } else {

        if (!shouldGraph) {
          icon_class = 'graph-hidden';
        } else if (columnMode === COLUMNMODE.POINTS) {
          icon_class = 'table-points';
        } else if (columnMode === COLUMNMODE.LINES) {
          icon_class = 'table-lines';
        } else if (columnMode === COLUMNMODE.POINTS_AND_LINES) {
          icon_class = 'table-points-and-lines';
        }
        
      }
      
      // efficently changes the class of the icon
      if (this.rendered_icon_class === icon_class) return;
      if (this.rendered_icon_class) {
        this.$icon.removeClass(this.rendered_icon_class);
      }
      this.rendered_icon_class = icon_class;
      if (icon_class) {
        this.$icon.addClass(icon_class);
      }
      
    };
  });
  
  return TableIconView;
});

define('template!table', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) { 
;__p+='\n\n<div class="expressionitem expressiontable shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
 } else { 
;__p+='\n\n<div class="expressionitem expressiontable">\n    \n  <div class=\'fade-container disable-horizontal-scroll-to-cursor\'>\n    \n    <span class="main">\n      <div class="tabledata">\n           \n        ';
 _.each(columns, function (column, c) { 
;__p+='\n          <div class="column">\n             \n            ';
 
               print(templates.table_cell_header());
            
               _.each(columns[0].cells, function (junk, r) {
                 print(templates.table_cell_body())
               });
            
;__p+='\n        \n          </div>\n        ';
 }); 
;__p+='\n\n      </div>\n    </span>\n    \n    ';
 //covers up the right hand side of an overflowing table 
;__p+='\n    <span class="fadeout"></span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n  </div>\n  \n  <span class="tab action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'num variable-index\'></span>\n    <div class=\'tab-interior\'></div>\n  </span>\n\n  <span class=\'exp-actions\'>\n\n    <span\n      class="action-delete delete-btn tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'icon-remove\'></i></span>\n    </span>  \n</div>\n\n';
 } 
;__p+='\n';
}
return __p;
};});
define('template!table_cell_body', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="non-editable empty cell">\n  <div class="inner-border"></div>\n  <span class="error-indicator do-not-blur tipsy-sticky" handleevent="true">\n  </span>\n\n  <span class=\'mathquill-rendered-math\'></span>\n  <div class="empty-line"></div>\n</div>\n';
}
return __p;
};});
define('template!table_cell_header', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="editable cell header">\n  <div class="inner-border"></div>\n  <span class="template-icon"></span>\n  <span class="mathquill-rendered-math"></span>\n  <span class="fadeout"></span>\n  <span class="action-removecolumn icon-remove do-not-blur" handleevent="true"></span>\n  <div class="empty-line"></div>\n</div>\n';
}
return __p;
};});
define('expressions/table_view',['require','jquery','underscore','pjs','lib/underscore_view','undoredo','mathquill','lib/keys','./abstractitem_view','./table_icon_view','template!table','template!table_cell_body','template!table_cell_header'],function(require) {
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var UndoRedo = require('undoredo');
  require('mathquill');
  var Keys = require('lib/keys');

  var AbstractItemView = require('./abstractitem_view');
  var TableIconView = require('./table_icon_view');
  
  var templates = {};
  
  templates.table = require('template!table');
  templates.table_cell_body = require('template!table_cell_body');
  templates.table_cell_header = require('template!table_cell_header');
  
  var TableView = P(AbstractItemView, function(view, _super) {

    view.template = templates.table;

/* TODO - missing na observer to make this happen
 * Should work for both headings and cells
   
    onLatexChange: function () {
      this.hideContextMenu();
    }.observes('expression.headings.@each.latex'), */
   
    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      
      this.model.triggerRowRemoved = this.onRowRemoved.bind(this);
      this.model.triggerRowAdded = this.onRowAdded.bind(this);
      this.model.triggerColumnAdded = this.onColumnAdded.bind(this);
      this.model.triggerColumnRemoved = this.onColumnRemoved.bind(this);
      this.model.triggerColumnMoved = this.onColumnMoved.bind(this);
      
      this.model.observe('selectedCell.tableview', this.onSelectedCellChange.bind(this));
    };
    
    view.destruct = function () {
      this.model.unobserve('.tableview');
      
      //TODO - should delete this.model.triggerRowRemoved
      //TODO - should delete this.model.triggerRowAdded
      //TODO - should delete this.model.triggerColumnRemoved
      //TODO - should delete this.model.triggerColumnAdded
    };

    view.getTemplateParams = function () {
      return {
        columns: this.model.columns,
        renderShell: this.model.renderShell,
        templates: templates
      };
    };
    
    view.onRowRemoved = function (index) {
      if (!this.columnViews) return;
      
      // index starts at 0 for row under headers. columnViews starts at 0
      // including header. Make the adjustment here.
      var r = index+1;
      
      // remove the cells
      for (var c = 0; c < this.columnViews.length; c++) {
        var cellView = this.columnViews[c].splice(r, 1)[0];
        cellView.remove();
      }
      
      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };
    
    view.onRowAdded = function (index) {
      if (!this.columnViews) return;

      // index starts at 0 for row under headers. columnViews starts at 0
      // including header. Make the adjustment here.
      var r = index+1;
      var cell;
      var cellView;
      var columns = this.model.columns;
      var columnCount = this.columnViews.length;
      var $columns = this.$('.column');
      
      for (var c = 0; c < columnCount; c++) {
        cell = columns[c].cells[index];
        
        // insert new cells into columns to form a row
        cellView = CellView(cell, this);
        cellView.insertAfter($columns.eq(c).find('.cell:nth-of-type('+r+')'));
        
        this.columnViews[c].splice(r, 0, cellView);
      }
      
      this.syncRowHeight(r);

      this.listView.model.updateDrawOrder();
      
      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };
    
    view.onColumnRemoved = function (index) {
      if (!this.columnViews) return;
      
      // remove the cells and then the entire column
      var columnCellViews = this.columnViews.splice(index, 1)[0];
      for (var i=0; i < columnCellViews.length; i++) {
        columnCellViews[i].remove();
      }
      this.$('.column:nth-child('+(index+1)+')').remove();

      var cell = this.selectedCell;

      if (cell && cell.column > index) {
        // selection was after the deleted column, so decrease selected
        // column.
        this.setProperty('selectedCell', {row: cell.row, column: cell.column-1});
      } else if (cell && cell.column === index) {
        // deleted column was selected, so we need to try to select another
        // one.

        if (this.columns.length <= index) {
          // we just deleted the last column, so we have to select the one
          // to the left of where we just deleted
          this.selectCell(cell.row, cell.column-1);
        } else {
          // we can put focus back in the column that just slid into the
          // deleteded one's place.
          this.selectCell(cell.row, cell.column);
        }
      } else {
        // don't need to do anything because the deleted column was after the
        // selected column. Or, there was no selected column.
      }

      this.syncAllRowHeights();

      this.listView.model.updateDrawOrder();
      
      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };

    view.onColumnAdded = function (index) {
      if (!this.columnViews) return;

      var column = this.model.columns[index];
      var cells = column.cells;
      var i, views = [];
      
      // create header
      views.push(HeaderView(column, this));
      
      // create each cell for each row
      for (i=0; i<cells.length-1; i++) {
        views.push(CellView(cells[i], this));
      }
      
      // add bottom cell
      views.push(BottomCellView(cells[i], this));
      
      this.columnViews.splice(index, 0, views);
      
      // add a column to the table
      var $column = $('<div class="column"></div>').insertAfter(this.$('.column:nth-child('+index+')'));
      
      // add each cell view to the column
      views.forEach(function (view, i) {
        view.appendTo($column);
      });

      this.syncAllRowHeights();

      this.listView.model.updateDrawOrder();

      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };
    
    view.onColumnMoved = function (from, to) {
      if (!this.columnViews) return;
      var columnView = this.columnViews.splice(from, 1)[0];
      this.columnViews.splice(to, 0, columnView);
      
      // remove the column and insert somewhere else
      var $movedColumn = this.$('.column:nth-child('+(from+1)+')').detach();
      $movedColumn.insertAfter(this.$('.column:nth-child('+(to)+')'));
    };
    
    view.onProjectorModeChange = function () {
      
      // must collapse all cells first
      for (var i=0; i<this.columnViews.length; i++) {
        var views = this.columnViews[i];
        for (var j=0; j<views.length; j++) {
          views[j].collapseHeight();
        }
      }
      
      this.syncAllRowHeights();
    };
    
    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell) return;
      
      var self = this;
      this.$().on('focusin', function(){
        setTimeout(self.onFocusChange.bind(self),0);
      });
      this.$().on('keydown', this.onMathQuillKeydownEvent.bind(this));
      this.$().on(
        'upPressed downPressed leftPressed rightPressed enterPressed backspacePressed delPressed',
        this.onMathQuillSpecialEvent.bind(this)
      );
    
      this.columnViews = [];
    
      // all the cells are placed in the dom, but they aren't setup yet.
      // optimization: could walk through the table more efficiently to access
      // the cell's dom element rather than doing a this.findCell(r,c) every
      // time. Could walk left to right, top to bottom.
      var columns = this.model.columns;
      var columnCount = columns.length;
      var rowCount = columns[0].cells.length;
      var r,c,cell,cellView;
      
      // setup header cells
      for (c=0; c < columnCount; c++) {
        cell = columns[c];
        
        if (c+1 < columnCount) {
          cellView = HeaderView(cell, this);
        } else {
          cellView = RightHeaderView(cell, this);
        }
        
        cellView.setDomNode(this.findCell(0,c));
        this.columnViews[c] = [cellView];
      }
      
      // setup body cells
      var bottomRow = rowCount;
      
      for (r=1; r <= rowCount; r++) {
        for (c=0; c < columnCount; c++) {
          cell = columns[c].cells[r-1];
          
          if (r === bottomRow) {
            cellView = BottomCellView(cell, this);
          } else {
            cellView = CellView(cell, this);
          }

          cellView.setDomNode(this.findCell(r,c));
          
          this.columnViews[c].push(cellView);
        }
      }

      this.syncAllRowHeights();
      this.onSelectedCellChange();
    };
    
    view.measureRowHeight = function (row) {
      var maxCollapsedHeight = 0;
      
      for (var i=0; i<this.columnViews.length; i++) {
        var cellView = this.columnViews[i][row];
        
        // make sure we've measured this cell before. Newly created cells are collapsed but unmeasured
        if (cellView.collapsedHeight === undefined) {
          cellView.measureHeight();
        }
        
        if (cellView.collapsedHeight > maxCollapsedHeight) {
          maxCollapsedHeight = cellView.collapsedHeight;
        }
      }
      
      return maxCollapsedHeight;
    };
    
    view.setRowHeight = function (row, height) {
      for (var i=0; i<this.columnViews.length; i++) {
        var cellView = this.columnViews[i][row];
        cellView.setHeight(height);
        cellView.setMathquillTop();
      }
    };
    
    // is called when entire table needs updated    
    view.syncAllRowHeights = function () {
      var row;
      var rows = this.columnViews[0].length;
      var heights = [];
      
      for (row=0; row<rows; row++) {
        heights.push(this.measureRowHeight(row));
      }
      
      for (row=0; row<rows; row++) {
        this.setRowHeight(row, heights[row]);
      }
    };
    
    view.syncRowHeight = function (row) {
      this.setRowHeight(row, this.measureRowHeight(row));
    };
    
    view.onSelectedCellChange = function () {
      if (!this.columnViews) return;

      // could optimize by remembering what cell last had selected class
      this.$('.tabledata .selected').removeClass('selected');

      var cell = this.model.selectedCell;
      
      // TODO - set selectedCell = null at time the cell is deleted rather than
      // catch it here. This is a bit hacky.
      // make sure cell isn't out of range
      if (cell) {
        if (cell.column >= this.columnViews.length || cell.row >= this.columnViews[0].length) {
          this.model.selectedCell = null; //silently overwrite the property. won't fire observers
          return;
        }
      }
      
      if (cell) {
        var cellView = this.columnViews[cell.column][cell.row];
        cellView.$().addClass('selected');
      
        this.model.setProperty('selected', true);
      }
      
      // if the cell with focus isn't selected, then remove focus
      var caret = this.getCaretPosition();
      if (caret && !_.isEqual(caret, cell)) {
        if (document.activeElement) {
          document.activeElement.blur();
        }
      }
      
      // need to do this manually if the cell that's focused is not editable.
      // these handlers are what hide/show keypad.
      if (cell) {
        var input = this.findCellInput(cell.row, cell.column)[0];
        this.listView.onFocusIn({target: input});
      } else {
        this.listView.onFocusOut();
      }
      
      var no_faded_h = cell && cell.column+1 === this.model.columns.length;
      var no_faded_v = cell && cell.row === this.model.columns[0].cells.length;
      this.$().toggleClass('no-faded-h', !!no_faded_h);
      this.$().toggleClass('no-faded-v', !!no_faded_v);
      
      this.hideContextMenu();
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      // use .originalEvent.target to ignore the bounds-checking stuff that
      // touchtracking.js does, because the cursor handle can (and in fact
      // usually does) stick out of the td's bounding box
      var td = $(evt.originalEvent.target).closest('.cell');
      var editable = td.find('.mathquill-editable');
      if (editable.length) {
        this.sendTapToMathQuill(evt, editable);
        return;
      }
      
      var target = $(evt.target);
      var table = target.closest('.tabledata')[0];
      
      // if we're clicking on the table itself, we don't know which cell
      // we meant to click. We'll just act like we clicked the outer padding.
      // that's not terrible, because for us to reach this point, we must
      // have clicked in seemingly blank space anyways.
      if (table && evt.target === table) {
        table = null;
      }
      
      if (!table) {
        if (document.activeElement) {
          document.activeElement.blur();
        }
        
        this.model.setProperty('selectedCell', null);
        this.model.setProperty('selected', true);
        return;
      }

      //select the uneditable cell
      var cell = this.getNodesCellPosition(target);
      this.selectCell(cell.row, cell.column);
    };
    
    view.getNodesCellPosition = function (node) {
      var c = node.closest('.column').prevAll('.column').length;
      var r = node.closest('.cell').prevAll('.cell').length;
      return {row: r, column: c};
    };
    
    view.getCaretPosition = function () {
      if (this.$().find(document.activeElement).length) {
        return this.getNodesCellPosition($(document.activeElement));
      } else {
        return null;
      }
    };

    view.findCell = function (r ,c) {
      return this.$('.column:nth-child('+(c+1)+') .cell:nth-child('+(r+1)+')');
    };

    view.findCellInput = function (r, c) {
      return this.findCell(r,c).find('.mathquill-rendered-math');
    };
    
    view.selectCell = function (r, c, selectEnd) {
      if (r < 0 || c < 0) return;
            
      var mathquill = this.findCellInput(r, c);
      if (!mathquill.length) return;
      
      var newSelectedCell = {row: r, column: c};
      this.model.setProperty('selectedCell', newSelectedCell);
      
      if (mathquill.hasClass('mathquill-editable')) {
        mathquill.mathquill('focus');
        if (selectEnd) {
         mathquill.mathquill('moveEnd');
        } else {
          mathquill.triggerHandler('select_all');
        }
      } else {
        $(document.activeElement).blur();
      }
    };
    
    view.unfocus = function () {
      var active = document.activeElement;
      if (this.$().find(active).length) {
        active.blur();
      }
    };
    
    view.processMissedKeyEvent = function (evt) {
      this.doKeyAction(Keys.lookup(evt), evt);
    };
    
    view.onMathQuillKeydownEvent = function (evt) {
      var key = Keys.lookup(evt);
      if (key === Keys.Tab || key === Keys.ESCAPE) {
        this.doKeyAction(key, evt);
      }
    };
    
    view.onMathQuillSpecialEvent = function (evt) {
      var evt_type = evt.type;
      var key = evt_type.slice(0, -('Pressed'.length));
      key = key.charAt(0).toUpperCase() + key.slice(1);
      this.doKeyAction(key, evt);
    };
    
    view.doKeyAction = function (key, evt) {
      
      // it's possible this came from a fake key event (keypad for example)
      // just create a dumby event so that evt.preventDefault() is callable.
      if (!evt) evt = $.Event();
      
      var selectedCell = this.model.selectedCell;
      var r_orig = selectedCell ? selectedCell.row : -1;
      var c_orig = selectedCell ? selectedCell.column : -1;
      
      var columns = this.model.columns;
      var totalRows = columns[0].cells.length;
      var totalCols = columns.length;
      
      var _move = function (r, c) {
        
        // try to wrap it around up one row and to the very right.
        if (r === -1) {
          this.triggerUpPressed();
        } else if ( r > totalRows) {
          this.triggerDownPressed();
        } else {
          
          // wrap around the left side. goes up a row and to the far right.
          if (c === -1) {
            c = totalCols-1;
            r--;
           
          // wrap around the right side. goes down a row and to the far left.
          } else if (c === totalCols) {
            r++;
            c=0;
          }

          this.selectCell(r, c);
          evt.preventDefault();
        }
      }.bind(this);
      
      var _deleteRow = function (r) {
        
        // don't delete the last row
        if (totalRows <= 1) return;
          
        // remove the old row
        this.model.removeRow(r_orig-1);
          
        this.selectCell(r, c_orig);
        evt.preventDefault();
      }.bind(this);
      
      var _deleteColumn = function (c) {
        // don't delete the first col, and don't delete one of last two cols
        if ( c_orig === 0 || totalCols <= 2) return;

        // remove the old row
        this.model.removeColumn(c_orig);
          
        this.selectCell(r_orig, c);
        evt.preventDefault();
      }.bind(this);
      
      switch (key) {
        
        case Keys.LEFT:  _move(r_orig, c_orig-1);  break;
        case Keys.RIGHT:  _move(r_orig, c_orig+1); break;
        case Keys.UP:  _move(r_orig-1, c_orig);    break;
        case Keys.DOWN:  _move(r_orig+1, c_orig);  break;
        
        case Keys.ENTER:
          if (r_orig < totalRows) {
            this.model.insertRow(r_orig, this.model.getAutofillValues(r_orig));
            this.selectCell(r_orig+1, c_orig);
            
          // enter in bottom row creates a new row, but puts focus back in empty row
          } else {
            this.model.insertRow(r_orig-1, this.model.getAutofillValues(r_orig-1));
            this.selectCell(r_orig, c_orig);
          }
          break;
              
        case Keys.ESCAPE:
          $(document.activeElement).blur();
          this.model.setProperty('selectedCell', null);
          break;
        
        case Keys.TAB:
          
          // if focus isn't within the table, then prevent tab default.
          if ($(document.activeElement).closest(this.$()).length === 0) {
            evt.preventDefault();
            return;
          }
          break;
  
        case Keys.BACKSPACE:
          if (r_orig === 0) {
            if(c_orig === 0){ //backspace in empty top-left cell removes whole table
              this.triggerBackspacePressed();
              UndoRedo.triggerFlash();
            }
            
            // move left if you're the rightmost column or in only column after the first
            else if (c_orig === totalCols-1 || c_orig === 1 && totalCols === 3) {
              _move(0, c_orig-1);
            }

            else {
              _deleteColumn(c_orig-1);
            }
            
          } else if (c_orig !== 0) {
            _move(r_orig, c_orig-1);
          } else if (r_orig === totalRows) {
            // backspace in bottom row simply moves up a row.
            _move(r_orig-1, c_orig);
          } else {
            _deleteRow(r_orig-1);
          }
          break;
          
        case Keys.DELETE:
          if (r_orig === 0) {
            if(c_orig === 0){
              this.triggerDelPressed();
              UndoRedo.triggerFlash();
            }
            
            // only delete column if its not on the far right
            else if (c_orig < totalCols-1) {
              _deleteColumn(c_orig);
            }
            
          } else if (r_orig >= totalRows) {
            // can't delete last row
          } else {
            _deleteRow(r_orig);
          }
          break;
      }
    };
    
    view.onFocusChange = function() {
      if (!this.model) return;
      this.model.setProperty('selectedCell', this.getCaretPosition());
    };
    
    
    view.isFocused = function () {
      return !!this.model.selectedCell;
    };

    view.addFocus = function (where, r, c) {
      if (where === 'cell') {
        this.selectCell(r,c);
      }
      
      else if (where !== 'end') {
        this.selectCell(0,0);
      }
      
      else {
        this.selectCell(this.model.columns[0].cells.length, 0);
      }
    };

  });
  
  
  // a view that will be a cell within a div-based table. it contains machinery to measure and set the cell's
  // height. That's important for syncing the heights of all cells in a 'row'
  var DivCellView = P(UnderscoreView, function (divCellView, _super) {
    
    divCellView.init = function () {
      _super.init.call(this);
      
      this.collapsedHeight = undefined;
      this.renderedHeight = undefined;
      this.mathquillTop = 0;
    };
    
    // overridden by subclass
    divCellView.lookupCellPosition = function () {};
    
    divCellView.handleHeightUpdate = function () {
      this.collapseHeight();
      this.tableView.syncRowHeight(this.lookupCellPosition().row);
    };
    
    // removes the height style of the cell. It'll collapse down to the size of the contents
    // NOTE: this.collapsedHeight and this.renderedHeight will be invalid after this
    //       it's up to whomever calls this to make sure measureHeight is called
    //       at an appropriate time. The two have been split for potential performance reasons.
    divCellView.collapseHeight = function () {
      this.$().css('height', '');
      this.collapsedHeight = undefined;
      this.renderedHeight = undefined;
    };
    
    // measures the current height. It's assumed that the cell is collapsed; otherwise you 
    // could have just read this.renderedHeight directly
    divCellView.measureHeight = function () {
      this.collapsedHeight = this.$().outerHeight();
      this.renderedHeight = this.collapsedHeight;
    };

    // sets the new height of the cell
    divCellView.setHeight = function (height) {
      if (this.renderedHeight !== height) {
        this.renderedHeight = height;
        this.$().css('height', height);
      }
    };

    // moves mathquill to the bottom of the cell
    divCellView.setMathquillTop = function () {
      var mathquillTop = this.renderedHeight - this.collapsedHeight;
      if (mathquillTop !== this.mathquillTop) {
        this.mathquillTop = mathquillTop;
        this.$('.mathquill-rendered-math').css('top', mathquillTop);
      }
    };
  });
  
  var RightHeaderView = P(DivCellView, function(headerView, _super) {
    headerView.template = templates.table_cell_header;
    
    headerView.init = function (model, tableView) {
      _super.init.call(this);
      
      this.model = model;
      this.tableView = tableView;
    };
    
    headerView.lookupCellPosition = function () {
      return {
        row: 0,
        column: this.model.index
      };
    };
    
    headerView.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      // it's the right side
      this.$().addClass('right');
      this.$().append('<span class="fade-right"></span>');
      
      this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');

      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      this.$().on('render', '.mathquill-rendered-math', function () {
        var latex = $(this).mathquill('latex');
        if (!latex) return;

        // set latex back to blank
        $(this).mathquill('latex', '');
          
        var index = self.model.index;
        self.model.table.insertColumn(index , {latex: latex});
          
        // select the new cell and put focus at end
        self.tableView.selectCell(0, index, true);
      });
    };
    
  });
  
  var HeaderView = P(DivCellView, function(headerView, _super) {
    headerView.template = templates.table_cell_header;
    
    headerView.init = function (model, tableView) {
      _super.init.call(this);
      this.__renderedLatex = '';
      this.__renderedBefore = false;
      
      this.model = model;
      this.tableView = tableView;
      
      // TODO - get rid of a need to put index in html
      this.model.observe('index.headerview', this.updateIndex.bind(this));
      this.model.observe('latex.headerview', this.onLatexChange.bind(this));
      this.model.observe('selected.headerview', this.onSelectedChange.bind(this));
    };
    
    // it's possible to select the headers during trace, so we need
    // to make sure we focus the header too
    headerView.onSelectedChange = function () {
      if (this.model.selected) {
        var tableView = this.tableView;
        if (!tableView) return;
        
        tableView.selectCell(0, this.model.index);
      }
    };
    
    headerView.lookupCellPosition = function () {
      return {
        row: 0,
        column: this.model.index
      };
    };
    
    headerView.destruct = function () {
      this.model.unobserve('.headerview');
    };

    headerView.updateIndex = function () {
      this.$().attr('index', this.model.index);
    };
    
    headerView.onLatexChange = function () {
      if (!this.$mathquill) return;
      
      if (this.__renderedLatex !== this.model.latex) {
        this.__renderedLatex = this.model.latex;
        this.$mathquill.mathquill('latex', this.model.latex);
      }
      
      if (this.__renderedBefore) this.handleHeightUpdate();
      this.__renderedBefore = true;
    };
    
    headerView.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      if (this.model.index === 0) {
        this.$().addClass('left');
      }
      
      this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');
      // TODO - move these mathquill handlers up to the table view instead of
      // assigning them on each table cell individually
      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });
      this.$().on('tap', '.action-removecolumn', function () {
        self.model.table.removeColumn(self.model.index);
      });
      this.$().on('render', '.mathquill-rendered-math', function () {
        var oldLatex = self.model.latex;
        var newLatex = $(this).mathquill('latex');
        if (oldLatex === newLatex) return;
        
        self.__renderedLatex = newLatex;
        self.model.setProperty('latex', newLatex);
      });
      
      this.iconView = TableIconView(this);
      this.iconView.replace(this.$('.template-icon'));
      
      this.onLatexChange();
      this.updateIndex();
    };
    
  });
  
  
  var BaseCellView = P(DivCellView, function (cellView, _super) {
    cellView.template = templates.table_cell_body;
    
    cellView.init = function (model, tableView) {
      _super.init.call(this);
      
      this.model = model;
      this.tableView = tableView;
     
      this.__renderedDisabled = true;
      this.__renderedValue = '';
      this.__renderedError = '';
      this.__renderedBefore = false;
    };
    
    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      if (this.model.column === _.first(this.model.column.table.columns)) {
        this.$().addClass('left');
      }
      
      if (this.model.column === _.last(this.model.column.table.columns)) {
        this.$().addClass('right');
        this.$().append('<span class="fade-right"></span>');
      }
      
      if (this.model === _.last(this.model.column.cells)) {
        this.$().addClass('bottom');
        this.$().append('<span class="fade-bottom"></span>');
      }
    };
    
    cellView.lookupCellPosition = function () {
      var cells = this.model.column.cells;
      var cell = this.model;
      
      return {
        row: _.indexOf(cells, cell) + 1, //because there is a header above it
        column: this.model.column.index
      };
    };
   
    cellView.onValueChange = function () {
      var oldValue = this.model.getOldProperty('value');
      var value = this.model.value;
      this.$().toggleClass('empty', !value);

      if (!this.$mathquill) return;
      
      if (this.__renderedValue !== value) {
        this.__renderedValue = value;
        
        // disabled mathquill can only have simple numerical values. Just
        // set the text. Ideally .mathquill('latex', ...) would work for
        // non-editable mathquill, but it doesn't. So we can hack this
        // together by simply setting the inner contents directly.
        if (this.__renderedDisabled) {
          this.$mathquill.text(value);
        }
        
        else {
          this.$mathquill.mathquill('latex', value);
        }
      }
    
      // we were a single line and are still a single line if the oldValue and new value
      // are both (a simple number OR empty). If this has happened, we don't need to
      // update the height of this cell. It hasn't changed.
      var stillSingleLine = (!oldValue || isFinite(oldValue)) && (!value || isFinite(value));
      if (this.__renderedBefore && !stillSingleLine) this.handleHeightUpdate();
      this.__renderedBefore = true;
    };
    
    cellView.onDisabledChange = function () {
      var disabled = !!this.model.column.disabled;
      if (!this.$mathquill || this.__renderedDisabled === disabled) return;
      this.__renderedDisabled = disabled;
      
      this.$().toggleClass('non-editable', !!disabled);
      
      // revert mathquill to not editable
      if (disabled) {
        // Ideally we'd use .mathquill('revert') but that doesn't do what
        // you'd expect. It completely gets rid of mathquill. It doesn't turn
        // an editable mathquill back to non-editable. So, we destroy the
        // mathquill and replace it with an non-editable one.
        var $newMathquill = $('<span class="mathquill-rendered-math">'+ this.model.value +'</span>');
        this.$mathquill.replaceWith($newMathquill);
        this.$mathquill = $newMathquill;
        
        // created a new mathquill, so mark that it's not shifted down at all
        this.mathquillTop = 0;
      }
      
      // make mathquill editable
      else {
        
        // TODO - The empty underline is the wrong size if we make
        // mathquill editable in the same code loop as when the td
        // is added to the dom. Not sure how to fix that.
        this.$mathquill.mathquill('editable');
      }
    };
        
    cellView.onErrorChange = function () {
      var error = this.model.error ? this.model.error : '';

      if (!this.$error || this.__renderedError === error) return;
      this.__renderedError = error;
      
      this.$error.attr('tooltip', error);
      this.$().toggleClass('error', !!error);
    };
  });
  
  var BottomCellView = P(BaseCellView, function (cellView, _super) {

    cellView.init = function (model, tableView) {
      _super.init.call(this, model, tableView);
      
      this.model.column.observe('disabled.cellview', this.onDisabledChange.bind(this));
    };
    
    cellView.destruct = function () {
      this.model.column.unobserve('.cellview');
    };

    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      this.$mathquill = this.$('.mathquill-rendered-math');
    
      this.onDisabledChange();
    
      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      this.$().on('render', '.mathquill-rendered-math', function () {
        var latex = $(this).mathquill('latex');
        if (latex === '') return;
        
        // add a row
        $(this).mathquill('latex', '');
        var position = self.lookupCellPosition();
        
        var table = self.model.column.table;
        
        var rowValues = [];
        for (var i=0; i < table.columns.length; i++) {
          rowValues[i] = '';
        }
        
        rowValues[position.column] = latex;
        table.insertRow(position.row-1, rowValues);
        self.tableView.selectCell(position.row, position.column, true);
      });
    };
  });
  
  var CellView = P(BaseCellView, function (cellView, _super) {
    
    cellView.template = templates.table_cell_body;
    cellView.init = function (model, tableView) {
      _super.init.call(this, model, tableView);

      this.model.observe('value.cellview', this.onValueChange.bind(this));
      this.model.observe('error.cellview', this.onErrorChange.bind(this));
      this.model.column.observe('disabled.' + this.guid, this.onDisabledChange.bind(this));
    };
    
    cellView.destruct = function () {
      this.model.unobserve('.cellview');
      this.model.column.unobserve('disabled.' + this.guid);
    };
    
    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);
      
      this.$error = this.$('.error-indicator');
      this.$mathquill = this.$('.mathquill-rendered-math');

      this.onDisabledChange();
      this.onValueChange();
      this.onErrorChange();
            
      // TODO - move these mathquill handlers up to the table view instead of
      // assigning them on each table cell individually
      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      this.$().on('render', '.mathquill-rendered-math', function () {
        var oldValue = self.model.value;
        var newValue = $(this).mathquill('latex');
        if (oldValue === newValue) return;
        self.__renderedValue = newValue;
        
        var id = self.model.column.table.id;
        var position = self.lookupCellPosition();
        var list = self.tableView.listView.model; //TODO ick
        function getCell () {
          var table = list.getItemById(id);
          var column = table.columns[position.column];
          return column.cells[position.row-1];
        }
        
        UndoRedo.addTransaction({
          type: UndoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var cell = getCell();
            cell.setProperty('value', oldValue);
            cell.column.table.requestParse();
          },
          redo: function () {
            var cell = getCell();
            cell.setProperty('value', newValue);
            cell.column.table.requestParse();
          }
        });
        
      });
    };
  });

  return TableView;
});

define('template!folder', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
if (renderShell) { 
;__p+='\n\n<div class="do-not-blur expressionitem expressionfolder shell">\n  <div class="shell"></div>\n</div>\n\n';
 } else { 
;__p+='\n\n<div class="do-not-blur expressionfolder expressionitem">\n  <div class="fade-container">\n\n    <span class="main">\n      <div class=\'caret-container action-toggle-folder-collapsed do-not-blur\' handleEvent="true">\n        <i class="icon-caret-down" ></i>\n      </div>\n      <textarea class="do-blur title" placeholder="'+
( t('untitled folder...') )+
'"></textarea>\n    </span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="tab action-drag"\n        handleEvent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="num variable-index"></span>\n    <div class="tab-interior">\n    <span class="action-toggle-folder-hidden graph-icon folder icon">\n      <i class="icon-hidden"></i>\n      <i class="icon-folder"></i>\n    </span>\n    </div>\n  </span>\n\n  <span class="exp-actions">\n    <span\n      class="action-delete delete-btn tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'icon-remove\'></i></span>\n    </span>\n  </span>\n\n</div>\n\n';
 } 
;__p+='\n';
}
return __p;
};});
define('expressions/folder_view',['require','pjs','jquery','lib/keys','expressions/abstractitem_view','template!folder','lib/browser'],function (require) {
  var P = require('pjs');
  var $ = require('jquery');
  var Keys = require('lib/keys');
  var AbstractItemView = require('expressions/abstractitem_view');
  var template = require('template!folder');
  var Browser = require('lib/browser');

  var FolderView = P(AbstractItemView, function(view, _super) {
    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      this.model = model;
      model.observe('hidden.folderView', this.onHiddenChanged.bind(this));
      model.observe('collapsed.folderView', this.onCollapsedChanged.bind(this));
      model.observe('title.folderView', this.renderTitle.bind(this));
      model.observe('selected.folderView', this.onSelectedChange.bind(this));
      model.observe('count.folderView', this.onMemberIdsChange.bind(this));
    };
    
    view.destruct = function () {
      this.model.unobserve('.folderView');
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell) return;
      
      this.$title = this.$('.title');

      this.$('.action-toggle-folder-collapsed').on(
        'tap',
        this.toggleCollapsed.bind(this)
      );
      this.$('.action-toggle-folder-hidden').on(
        'tap',
        this.toggleHidden.bind(this)
      );
      this.$title.bind('keydown keypress keyup change cut paste', this.onTitleEvent.bind(this));
      this.renderTitle();
      this.onCollapsedChanged();
      this.onHiddenChanged();
      this.onMemberIdsChange();
    };
    
    view.onSelectedChange = function () {
      if (!this.selected && this.$title) {
        this.$title.blur();
      }
    };

    view.onMemberIdsChange = function () {
      this.$().toggleClass('has-items', this.model.count > 0);
    };

    view.onTitleEvent = function (evt) {
      var ta = this.$title[0];
      var ta_is_active = ta && ta === document.activeElement;
      var ta_len = ta_is_active ? ta.value.length : 0;
      var key = ta_is_active && evt.type === 'keydown' ?
        Keys.lookup(evt) : ''
      ;

      // pressing enter inside textarea creates a new expression underneath
      if (key === Keys.ENTER) {

        evt.preventDefault();
        this.triggerEnterPressed();
        return;

      // pressing escape removes focus
      } else if (key === Keys.ESCAPE) {
        $(document.activeElement).blur();
        return;

      // pressing up while at start of textarea selects expression above
      } else if (key === Keys.UP) {

        if (ta.selectionStart === 0 && ta.selectionEnd === 0) {
          evt.preventDefault();
          this.triggerUpPressed();
        }
        return;

      // pressing down while at end of textarea selects expression below
      } else if (key === Keys.DOWN) {

        if (ta.selectionStart === ta_len && ta.selectionEnd === ta_len) {
          evt.preventDefault();
          this.triggerDownPressed();
        }
        return;

      // pressing backspace when completely empty should delete textarea
      } else if (key === Keys.BACKSPACE) {

        if (ta_len === 0) {
          evt.preventDefault();
          this.triggerBackspacePressed();
        }
        return;

      // pressing delete when completely empty should delete textarea
      } else if (key === Keys.DELETE) {

        if (ta_len === 0) {
          evt.preventDefault();
          this.triggerDelPressed();
        }
        return;

      }

      // if we made it down here, then we should update the stored text value
      this.model.setProperty('title', ta.value);
    };

    view.renderTitle = function () {
      this.$title.attr('value', this.model.title);
      this.fitText();
    };
    
    view.onProjectorModeChange = function() {
      this.fitText();
    };
    
    view.fitText = function () {
      if (!this.$title) return;

      var title = this.$title[0];
      var rows=0;
      do {
          rows++;
          this.$title.attr('rows',rows);
      } while (title.clientHeight < title.scrollHeight);
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
    };

    view.toggleHidden = function () {
      this.model.setProperty('hidden', !this.model.hidden);
    };

    view.toggleCollapsed = function () {
      this.model.setProperty('collapsed', !this.model.collapsed);
    };

    view.onHiddenChanged = function () {
      this.$().toggleClass('hidden', !!this.model.hidden);
    };

    view.onCollapsedChanged = function () {
      this.$().toggleClass('collapsed', !!this.model.collapsed);
    };
    
    view.addFocus = function (where) {
      
      // Can't reliably focus input programatically from within iframe on ipad
      // see #3106
      if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        return;
      }

      if (!this.$title) return;
      
      var title = this.$title[0];
      title.focus();
      if (where === 'end') {
        title.selectionStart = title.selectionEnd = title.value.length;
      } else if (where === 'start') {
        title.selectionStart = title.selectionEnd = 0;
      }
    };
  });

  return FolderView;
});

define('template!list', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="exppanel-outer">\n  <div id="expression-top-bar">\n  \n    ';
 if (IS_TABLET) { 
;__p+='\n      <a class=\'hamburger-btn action-hamburger\'><i class=\'icon-hamburger\'></i></a>\n    ';
 } 
;__p+='\n    <a class=\'add-expression-btn action-add-expression tooltip do-not-blur\' handleEvent="true" tooltip="'+
( t('Add Item') )+
'"><i class=\'icon-plus\'></i><i class=\'icon-caret-down\'></i></a>\n    \n    <a class=\'btn-danger action-clearall\'>delete all</a>\n    <span class=\'center-aligned\'>\n      <a class=\'action-undo tooltip\' tooltip="'+
( t('Undo (ctrl+z)') )+
'"><i class=\'icon-undo\'></i></a>\n      <a class=\'action-redo tooltip\' tooltip="'+
( t('Redo (ctrl+y)') )+
'"><i class=\'icon-redo\'></i></a>\n    </span>    \n\n    <a class=\'resize-list-btn action-hideexpressions do-not-blur tooltip\' tooltip="'+
( t('Hide List') )+
'" handleEvent="true"><i class=\'icon-hide\'></i></a>\n    \n    <a \n      class=\'edit-list-btn action-toggleeditlistmode do-not-blur tooltip\' tooltip="'+
( t('Edit List') )+
'"\n      handleEvent="true">\n      <i class=\'icon-settings\' /></a>\n  \n  </div>\n  \n  <div class="exppanel-container">\n    <div id="exppanel" class="disable-horizontal-scroll-to-cursor">\n      <div class="expressionlist">\n        <span class="template-expressioneach"></span>\n        <div class="template-newexpression"></div>\n      </div>\n    </div>    \n  </div>\n  \n  <div id=\'show-expressions-tab\'>\n    <a class=\'resize-list-btn action-showexpressions\'>\n      <i class=\'icon-show\'></i>\n    </a>\n  </div>\n</div>\n';
}
return __p;
};});
define('expressions/list_view_desktop',['require','pjs','./list_view','tipsy','./expression_view','./text_view','./table_view','./folder_view','lib/keys','template!list'],function (require) {
  var P = require('pjs');
  var ListView = require('./list_view');
  require('tipsy');

  var ExpressionView = require('./expression_view');
  var TextView = require('./text_view');
  var TableView = require('./table_view');
  var FolderView = require('./folder_view');
  var Keys = require('lib/keys');

  var template = require('template!list');

  var ListViewDesktop = P(ListView, function (view, _super) {
    view.template = template;
    
    view.instantiateItemView = function (item) {
      if (item.isExpression) {
        return ExpressionView(item, this);
      } else if (item.isText) {
        return TextView(item, this);
      } else if (item.isTable) {
        return TableView(item, this);
      } else if (item.isFolder) {
        return FolderView(item, this);
      }
    };
        
    view.didInsertElement = function () {
      _super.didInsertElement.call(this);

      this.$().tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        delegate: '.tooltip'
      });
    };

    view.handleKeydown = function (evt) {
      // We only want to catch this when the user isn't 'doing anything'
      // e.g. in a field or such.
      if (evt.target.localName === 'body' && Keys.lookup(evt) === Keys.SPACEBAR) {
        this.toggleAllSliders();
      }
    };

  });
  
  return ListViewDesktop;
});

define('loadcss!css/keypad', function(){});
//from http://www.w3schools.com/js/js_cookies.asp
define('main/cookie',[],function () {
  function eraseCalculatorCookie(c_name) {
    document.cookie = c_name + "= ;path=/calculator;expires=Thu, 01 Jan 1970 00:00:01 GMT";
  }

  function getCookie(c_name) {
    // We were having problems with cookies being set on two paths: both
    // / and /calculator. This erases the cookie at /calculator before any
    // reads. Can delete this call (and the definition of eraseCalculatorCookie)
    // one month after it launches, so roughly May 1, 2013.
    eraseCalculatorCookie(c_name);

    var encoded_c_name = encodeURIComponent(c_name);
    var i,x,y,ARRcookies=document.cookie.split(";");
    for (i=0;i<ARRcookies.length;i++)
    {
      x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
      y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
      x=x.replace(/^\s+|\s+$/g,"");
      if (x==encoded_c_name) {
        return decodeURIComponent(y);
      }
    }
  }

  function setCookie(c_name, value, duration) {
    //set a javascript cookie
    var expires = new Date();
    expires.setDate(expires.getDate() + (duration || 30));
    document.cookie = (
      encodeURIComponent(c_name) +
      "=" + encodeURIComponent(value) +
      "; expires=" + expires.toUTCString() +
      "; path=/"
    );
  }

  return {
    getCookie: getCookie,
    setCookie: setCookie
  };
});

define('template!keypad', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'desmos-keypad\'>\n  <div class=\'keys-container retracted\'>\n    <div class=\'keys-background do-not-blur\'>\n      <div class=\'keys\'>\n\n        <div class=\'functions-popover popover top\' popover="true">\n          <div class=\'popover-interior\'>\n            <div class=\'header\'>\n              <table><tr>\n              ';
 _.each(popups.functionsPopup, function(contents, section) { 
;__p+='\n                <td>\n                  <span key="'+
(contents.tab.id)+
'" class="heading tappable btn btn-inverse'+
((section == "trig" ?  " selected":""))+
'">\n                    '+
( contents.tab.html )+
'\n                  </span>\n                </td>\n              ';
 }) 
;__p+='\n              </tr></table>\n            </div>\n\n            ';
 _.each(popups.functionsPopup, function(contents, section) { 
;__p+='\n              <table class=\'interior-buttons\' section=\''+
(section)+
'\'>\n                ';
 if (section == "trig") { 
;__p+='\n                  <tr class=\'section-headings\'>\n                    <td>trig</td>\n                    <td>inverse</td>\n                    <td>hyperb</td>\n                  </tr>\n                ';
 } 
;__p+='\n                <tr>\n\n                ';

                   var i = 0;
                    _.each(contents.funcs, function(func) {
                
;__p+='\n                  '+
((i%3 == 0 ? "</tr><tr>" : ""))+
'\n                  ';
 i++ 
;__p+='\n                  <td>\n                    <span\n                      class="option btn tappable'+
(func.aClass ? " " + func.aClass : "")+
' '+
(func.id)+
'-key"\n                      key="'+
(func.id)+
'"\n                    >\n                      '+
( func.html )+
'\n                    </span>\n                  </td>\n              ';
 }) 
;__p+='\n              </tr></table>\n            ';
 }) 
;__p+='\n          </div>\n          <div class=\'arrow\'></div>\n        </div>\n\n        <canvas class="handwriting-area"></canvas>\n\n        ';
 _.each(buttons, function(keypad, keypadID) { 
;__p+='\n         <div class="'+
(keypadID)+
'">\n           ';
 _.each(keypad, function(row) { 
;__p+='\n             <div class="row">\n               ';
 _.each(row['keys'], function(key) { 
;__p+='<div\n                   class="cell '+
(key.cellClass ? key.cellClass: "")+
'"\n                 >\n                   ';
 if (key.html) { 
;__p+='\n                     <a\n                       class="'+
(key.aClass ? key.aClass : "")+
' '+
(key.id)+
'-key"\n                       key="'+
(key.id)+
'"\n                     >\n                       '+
( key.html )+
'\n                     </a>\n                   ';
 } 
;__p+='\n                 </div>';
 }) 
;__p+='\n               <div style=\'clear:both\'></div>\n             </div>\n           ';
 }) 
;__p+='\n         </div>\n        ';
 }) 
;__p+='\n        <div style=\'clear:both\'></div>\n      </div>\n\n      ';
 if (userMinimizable) { 
;__p+='\n      <div class=\'minimize-keypad\'>\n        <i class=\'icon-keyboard minimize-keyboard-icon\'></i>\n        <i class=\'icon-caret-down\'></i>\n      </div>\n      ';
 } 
;__p+='\n    </div>\n  </div>\n  \n  ';
 if (userMinimizable) { 
;__p+='\n    <div class="show-keypad" class="do-not-blur">\n      <i class=\'icon-keyboard maximize-keyboard-icon\'></i>\n      <i class="icon-caret-up do-not-blur"></i>\n    </div>\n  ';
 } 
;__p+='\n  \n</div>\n';
}
return __p;
};});
define('text!data/keypad_keys.json',[],function () { return '{\n"trigFuncs":        ["sin","cos","tan","csc","sec","cot"],\n\n"oneArgFuncs":      ["ceil","floor","round","abs","ln","log","exp"],\n\n"twoArgFuncs":      ["min","max","lcm","gcd","mod", "nCr", "nPr"],\n\n"tabs":             ["trig","calc","misc"],\n\n"staticKeys": {\n  "unknown":          {"display":{"html":"?"},\n                      "action":{"cmd":"?"}},\n  "pi":               {"display":{"html":"&pi;"},\n                      "action":{"cmd":"\\\\pi"}},\n  "leftparen":        {"display":{"html":"("},\n                      "action":{"cmd":"("}},\n  "rightparen":       {"display":{"html":")"},\n                      "action":{"cmd":")"}},\n  "sqrt":             {"display":{"html":"&radic;"},\n                      "action":{"cmd":"\\\\sqrt"}},\n  "cuberoot":         {"display":{"html":"<sup>3</sup>&radic;", "noMQ": true},\n                      "action":{"custom":"cuberoot"}},\n  "lt":               {"display":{"html":"&lt;"},\n                      "action":{"cmd":"<"}},\n  "gt":               {"display":{"html":"&gt;"},\n                      "action":{"cmd":">"}},\n  "le":               {"display":{"html":"&le;"},\n                      "action":{"cmd":"\\\\le"}},\n  "ge":               {"display":{"html":"&ge;"},\n                      "action":{"cmd":"\\\\ge"}},\n\n  "squared":          {"display":{"aClass":"exponent", "html":"a^2"},\n                      "action":{"custom":"squared"}},\n\n  "exponent":         {"display":{"aClass":"exponent", "html":"a^b"},\n                      "action":{"cmd":"^"}},\n  "subscript":        {"display":{"html":"a_b"},\n                      "action":{"cmd":"_"}},\n  "fact":             {"display":{"html":"x!"},\n                      "action":{"cmd":"!"}},\n  "theta":            {"display":{"html":"&theta;"},\n                      "action":{"cmd":"\\\\theta"}},\n  "leftbrace":        {"display":{"html":"{", "noMQ":true},\n                      "action":{"cmd":"{"}},\n  "rightbrace":       {"display":{"html":"}", "noMQ":true},\n                      "action":{"cmd":"}"}},\n  "colon":            {"display":{"html":":"},\n                      "action":{"cmd":":"}},\n  "pipes":            {"display":{"html":"|a|"},\n                      "action":{"cmd":"|"}},\n  "comma":            {"display":{"html":","},\n                      "action":{"cmd":","}},\n\n  "times":            {"display":{"html":"&times;"},\n                      "action":{"cmd":"*"}},\n  "plus":             {"display":{"html":"+"},\n                      "action":{"cmd":"+"}},\n  "divide":           {"display":{"html":"&divide;"},\n                      "action":{"cmd":"/"}},\n  "minus":            {"display":{"html":"&ndash;"},\n                      "action":{"cmd":"-"}},\n  "equals":           {"display":{"html":"="},\n                      "action":{"cmd":"="}},\n  "decimal":          {"display":{"html":"."},\n                      "action":{"cmd":"."}},\n\n  "backspace":        {"display":{"aClass":"always-enabled", \n                                "html":"<span class=\\"backspace-img\\"></span><i class=\\"icon-delete\\"></i>"\n                               },\n                      "action":{"key":"Backspace"}},\n  "enter":            {"display":{"aClass":"always-enabled", "html":"ent<span>er</span>"},\n                      "action":{"key":"Enter"}},\n\n  "narrowToggleLetters":    {"display":{"aClass":"always-enabled toggle-btn", "html":"A B C"},\n                      "action":{"changeLayout": "letters"}},\n  "toggleLetters":    {"display":{"aClass":"always-enabled toggle-btn", "html":"A B C", "colspan":2},\n                      "action":{"changeLayout": "letters"}},\n  "toggleHandwriting":{"display":{"aClass":"always-enabled toggle-btn", "html":"<img src=\\"assets/img/handwriting.png\\"/>"},\n                      "action":{"changeLayout": "handwriting"}},\n  "toggleNumbers":    {"display":{"aClass":"always-enabled toggle-btn", \n                                "html":"1<span> </span>2<span> </span>3", \n                                "colspan":1\n                               },\n                      "action":{"changeLayout":"mainNumbers"}},\n\n  "popupFunctions":  {"display":{"aClass":"always-enabled toggle-btn", "html":"functions", "colspan":2},\n                      "action":{"popup": "functions"}},\n\n  "blank":            {"display":{},\n                      "action":{}},\n\n  "halfBlank":        {"display":{"colspan":0.5},\n                      "action":{}},\n\n  "left":             {"display":{"aClass":"always-enabled", "html":"&larr;"},\n                      "action":{"key":"Left"}},\n  "up":               {"display":{"aClass":"always-enabled", "html":"&uarr;"},\n                      "action":{"key":"Up"}},\n  "right":            {"display":{"aClass":"always-enabled", "html":"&rarr;"},\n                      "action":{"key":"Right"}},\n  "down":             {"display":{"aClass":"always-enabled", "html":"&darr;"},\n                      "action":{"key":"Down"}},\n\n  "toggleAltLeft":    {"display":{"aClass":"always-enabled toggle-btn", "html":"more", "colspan":2},\n                      "action":{"changeLayout": "altNumbers"}},\n  "toggleMainLeft":   {"display":{"aClass":"always-enabled toggle-btn active", "html":"more", "colspan":2},\n                      "action":{"changeLayout": "mainNumbers"}},\n  "loga":             {"display":{"html":"log_a"},\n                      "action":{"custom":"loga"}},\n  "ddx":              {"display":{"html":"d/dx"},\n                      "action":{"custom":"d/dx"}},\n  "sum":              {"display":{"html":"\\\\sum"},\n                      "action":{"cmd":"\\\\sum"}},\n  "prod":             {"display":{"html":"\\\\prod"},\n                      "action":{"cmd":"\\\\prod"}}\n  }\n}\n';});

define('main/keypad_keys',['require','jquery','underscore','mathquill','text!data/keypad_keys.json'],function(require){
  var $ = require('jquery');
  var _ = require('underscore');
  require('mathquill');
  var keypad_data = JSON.parse(require('text!data/keypad_keys.json'));
  var i;

  //Start with explicitly defined keys
  var keys = keypad_data.staticKeys;

  //Expand summary-form data from JSON to create input structure for keypad
  _.each(keypad_data.tabs, function(t){
    keys[t+'Tab'] = {display:{html:t}, action:{tab:t}};
  });

  _.each(keypad_data.oneArgFuncs, function (f) {
    keys[f] = {display:{html:f},action:{func:f}};
  });

  _.each(keypad_data.twoArgFuncs, function (f) {
    keys[f] = {display:{html:f},action:{func:f, args:2}};
  });

  _.each(keypad_data.trigFuncs, function (fn) {
    _.each([fn, 'arc'+fn,fn+'h'], function (f) {
      keys[f] = {display:{html:f},action:{func:f}};
    });
  });

  for (i = 0; i < 26; i++) { // a-f
    var ch = String.fromCharCode(97+i);
    keys[ch] = {display:{html:ch}, action:{cmd:ch}};
  }

  for (i = 0; i < 10; i++) { // 0-9
    var num = String.fromCharCode(48+i);
    keys[num] = {display:{html:num}, action:{cmd:num}};
  }

  var genButton = function (key, buttonId) {
    var display = key.display;
    var action = key.action;

    display.id = buttonId;
    
    if (!('cellClass' in display)) display.cellClass = '';

    if (!('aClass' in display)) display.aClass = '';

    if (display.colspan) {

      if (display.cellClass) display.cellClass += ' ';

      switch(display.colspan) {
        case 0.5:
        display.cellClass += 'halfwide';
        break;
        case 1.5:
        display.cellClass += 'oneandhalfwide';
        break;
        case 2:
        display.cellClass += 'twowide';
        break;
      }
    }

    if (display.html) {
      display.aClass = (display.aClass ? display.aClass + ' key' : 'key');
      
      if (display.actionOn == 'tapstart') {
        display.aClass += ' tapstartable';
      } else {
        display.aClass += ' tappable';
      }
    }

    if (
      !(action.tab || action.key || action.popup || action.changeLayout) &&
      !display.noMQ && display.html
    ) {
      display.mathquill = true;

      // ask mathquill for an html version of itself
      // note: this will break for things like parentheses with contents,
      // which need to be inserted into the dom to know their correct size.
      // but works for uncomplicated mathquill
      // WARNING - if run multiple times, this will modify this.keys in breaking ways
      display.html = $('<span>' + display.html + '</span>').mathquill().mathquill('html');
      display.aClass += ' mathquill-rendered-math';
    }
  };

  _.each(keys, genButton);

  return keys;
});

define('main/keypad_view',['require','loadcss!css/keypad','jquery','underscore','lib/browser','main/resize','main/cookie','template!keypad','lib/underscore_view','config','pjs','main/cookie','main/keypad_keys'],function (require) {
  require('loadcss!css/keypad');

  var $ = require('jquery');
  var _ = require('underscore');
  var Browser = require('lib/browser');
  var Resize = require('main/resize');
  var Cookie = require('main/cookie');
  var template = require('template!keypad');
  var UnderscoreView = require('lib/underscore_view');
  var Config = require('config');
  var P = require('pjs');

  require('main/cookie');
  var KEYS = require('main/keypad_keys');

  var KeypadView = P(UnderscoreView, function (view, _super){

    view.template = template;
    view.isOpen = false;
    // Flag for whether the user has minimized the keypad with the minimize
    // button. In this case, we keep it minimized unless the user opens it with
    // the open keypad button.
    view.userMinimized = false;

    view.init = function (expressionsView) {
      this.keys = KEYS;
      this.expressionsView = expressionsView;
      this.setupKeypad();
      this.setLayout('mainNumbers');
    };

    view.didCreateElement = function(){
      var self = this;
      self.setLayout(self.layout);
      
      //handles to the various buttons that we're going to use a lot
      self.$hideBtn = self.$('.minimize-keypad');
      self.$showBtn = self.$('.show-keypad');
      self.$funcPopover = self.$('.functions-popover');
      self.$container = self.$('.keys-container');
      self.$keys = self.$('.keys');
      self.$funcBtn = self.$('.popupFunctions-key');
      self.setTab('trig');
  
      self.$().on('tap', '.tappable', function (evt) {
        var button = $(evt.target).closest('.tappable');
        self.buttonClicked(button);
      });

      self.$().on('tapstart', '.tapstartable', function (evt) {
        var button = $(evt.target).closest('.tapstartable');
        self.buttonClicked(button);
      });

      self.expressionsView.observe('needFakeKeypad', function () {
        self.requestSetIsOpen(self.expressionsView.needFakeKeypad);
      });

      self.expressionsView.observe('editDisabled', function () {
        self.setKeysDisabled(self.expressionsView.editDisabled);
      });

      self.$showBtn.show();

      //initialize hide & show
      self.$hideBtn.on("tap", function () {
        self.userMinimized = true;
        Cookie.setCookie("keypadMinimized", "true");
        self._hideKeypad();
      });

      self.$showBtn.on("tap", function () {
        self.userMinimized = false;
        Cookie.setCookie("keypadMinimized", "false");
        self._showKeypad();

        //use currently selected expression if one is selected (no-op if it's also focused)
        var selected = self.expressionsView.getSelected();
        if (selected && selected.isExpression) {
          self.expressionsView.getItemView(selected.id).addFocus();
          return;
        }
        
        //if currently selected is a table, return early if it already has focus
        if (selected && selected.isTable && self.expressionsView.itemFocused) {
          return;
        }

        //if not, get the element at the top of the list
        var item = self.expressionsView.getFirstVisibleItem();

        //search downward until we find an expression that we can focus
        while (item && !item.isExpression) {
          item = self.expressionsView.getItemByIndex(item.index + 1);
        }
        
        //if we found an item: focus it!
        if (item) {
          self.expressionsView.getItemView(item.id).addFocus();
          return;
        }
        
        //append a blank expression at the bottom of the list, and focus that
        self.expressionsView.appendBlankExpression();
      });

      self.userMinimized = (Cookie.getCookie("keypadMinimized") === "true");
    };

    view._hideKeypad = function () {
      clearTimeout(this.__showHideTimeout);
      this.isOpen = false;
      var self = this;

      self.$container.addClass('retracted');

      if (Browser.IS_IE8 || Browser.IS_IE9) {
        // IE<10 doesn't support transitions, so we shouldn't fade the button 
        // in
        self.$showBtn.show();
      } else {
        self.$showBtn.fadeIn();
      }
      this.hidePopups();
      Resize.trigger();
    };

    view._showKeypad = function () {
      clearTimeout(this.__showHideTimeout);
      if (this.layout === 'letters' || this.layout === 'altNumbers') {
        this.setLayout("mainNumbers");
      }
      this.$showBtn.hide();
      this.isOpen = true;
      var self = this;
      this.__showHideTimeout = setTimeout(function () {
        self.$container.removeClass('retracted');
        Resize.waitForCSSAnimation(self.$container, /transform/);
      });
    };

    view.requestSetIsOpen = function (isOpen) {
      if (this.userMinimized  && !this.isOpen) return;
      if (isOpen === this.isOpen) return;

      if (isOpen) {
        this._showKeypad();
      } else {
        this._hideKeypad();
      }
    };
  
    view.setKeysDisabled = function (isDisabled) {
      this.$keys.toggleClass('keys-disabled', !!isDisabled);
    };

    view.getButton = function (buttonId) {
      if (!this.keys[buttonId])
        buttonId = "unknown";
      return this.keys[buttonId].display;
    };

    view.buttonArray = function (buttonsString) {
      return _.map(buttonsString.split(' '), this.getButton, this);
    };

    view.setupKeypad = function () {

      this.buttons = {
        mainNumbersLeft: [
          {keys: this.buttonArray('x y squared') },
          {keys: this.buttonArray('lt gt exponent') },
          {keys: this.buttonArray('leftparen rightparen comma') },
          {keys: this.buttonArray('toggleAltLeft sqrt') }
        ],

        altNumbersLeft: [
          {keys: this.buttonArray('r theta pi') },
          {keys: this.buttonArray('le ge pipes') },
          {keys: this.buttonArray('leftbrace rightbrace colon') },
          {keys: this.buttonArray('toggleMainLeft cuberoot') }
        ],

        numbersMiddle: [
          {keys: this.buttonArray('7 8 9 divide') },
          {keys: this.buttonArray('4 5 6 times') },
          {keys: this.buttonArray('1 2 3 minus') },
          {keys: this.buttonArray('0 decimal equals plus') }
        ],

        numbersRight: [
          {keys: this.buttonArray('popupFunctions backspace') },
          {keys: this.buttonArray('toggleLetters enter') },
          {keys: this.buttonArray('blank up blank') },
          {keys: this.buttonArray('left down right') }
        ],

        letters: [
          {keys: this.buttonArray('q w e r t y u i o p backspace') },
          {keys: this.buttonArray('halfBlank a s d f g h j k l halfBlank toggleNumbers') },
          {keys: this.buttonArray('blank z x c v b n m comma blank enter') },
          {keys: this.buttonArray(
            'halfBlank pi subscript leftparen rightparen plus minus times divide equals blank halfBlank'
          )}
        ],
      };

      this.popups = {
        functionsPopup: {
          trig: {
            tab:this.getButton('trigTab'),
            funcs: this.buttonArray(
              'sin arcsin sinh cos arccos cosh tan arctan tanh csc arccsc csch sec arcsec sech cot arccot coth'
            )
          },

          calc: {
            tab: this.getButton('calcTab'),
            funcs: this.buttonArray('exp ln log loga ddx sum prod fact e')
          },

          misc: {
            tab: this.getButton('miscTab'),
            funcs: this.buttonArray('ceil floor round abs min max lcm gcd mod nCr nPr fact')
          }
        }
      };
    };

    view.getTemplateParams = function(){
        return {buttons: this.buttons, popups: this.popups, userMinimizable: (!Config.get('tablet'))};
    };

    view.height = function () {
      return this.isOpen ? this.$container.height() : 0;
    };

    view.setLayout = function (newLayout) {
      this.layout = newLayout;
      this.$().removeClass('layout-letters layout-altNumbers layout-mainNumbers layout-handwriting')
              .addClass('layout-' + newLayout);
    };

    view.setTab = function (newTab) {
      var tabs = ['trig','calc','misc'];
      var self = this;
      _.each(tabs, function (tab) {
        self.$('[key=' + tab + 'Tab]').removeClass('selected');
        self.$('[section=' + tab + ']').hide();
      });
      this.$('[key=' + newTab + 'Tab]').addClass('selected');
      this.$('[section=' + newTab + ']').show();
    };

    view.hidePopups = function () {
      this.$funcBtn.removeClass("active");
      this.$funcPopover.hide();
    };

    view.setPopup = function (newPopup) {
      if (newPopup === 'functions') {
        //this just changes which direction the arrowhead is pointing
        if ($(window).height() < 525) {
          this.$funcPopover.removeClass("top").addClass("left");
        } else {
          this.$funcPopover.removeClass("left").addClass("top");
        }
        this.$funcBtn.toggleClass("active");
        this.$funcPopover.toggle();
      }
    };

    view.resize = function () {
      // no-op here; implemented in keypad_view_handwriting
    };

    view.buttonClicked = function (button) {
      var keyID        = this.$(button).attr('key'),
          buttonAction = this.keys[keyID].action;

      if (buttonAction.changeLayout) {
        this.hidePopups();
        this.setLayout(buttonAction.changeLayout);

        //if switched to handwriting layout, set canvas size
        if (buttonAction.changeLayout === 'handwriting') this.resize();

        return;
      }
      if (buttonAction.tab) {
        this.setTab(buttonAction.tab);
        return;
      }
      if (buttonAction.popup) {
        this.setPopup(buttonAction.popup);
        return;
      }
    
      //if we've clicked a button while in alt-layout, switch back to main
      if (this.layout === 'altNumbers') {
        this.setLayout('mainNumbers');
      }

      //hide popup when any button is pressed (Except a popup or tab button)
      this.hidePopups();

      var editor = this.expressionsView.getActiveMathquill();
      if (!editor.length) {
      
        // makes it so that the keypad works for the non-editable table cells.
        var selected = this.expressionsView.getSelected();
        if (selected && selected.isTable ) {
          if (selected.selectedCell) {
            var view = this.expressionsView.getItemView(selected.id);
            view.doKeyAction(buttonAction.key);
          }
        }
      
        return;
      }

      try {
          if (buttonAction.key) {
            editor.mathquill("onKey", buttonAction.key);
          } else if (buttonAction.cmd) {
            editor.mathquill('cmd', buttonAction.cmd);
          } else if (buttonAction.func) {
            var suffix = '\\left( \\right)';
            if (buttonAction.args === 2) {
              suffix = '\\left({},{}\\right)';
            }
            editor.mathquill('write', buttonAction.func + suffix);
              editor.mathquill('onKey', 'Left');
            if (buttonAction.args === 2) {
              editor.mathquill('onKey', 'Left');
            }
          
          } else if (buttonAction.custom) {
            switch (buttonAction.custom) {
              case 'loga':
                editor.mathquill('write','log_{}\\left( \\right)');
                editor.mathquill('onKey', 'Left');
                editor.mathquill('onKey', 'Left');
                editor.mathquill('onKey', 'Left');
                break;
              case 'cuberoot':
                editor.mathquill('write', '\\sqrt[3]{}');
                editor.mathquill('onKey', 'Left');
                break;
              case 'squared':
                //route as if typed the exponent button, so that we get the
                //nice behavior where exponentiating in an exponent is treated
                //as a backspace first
                editor.mathquill('cmd', '^');
                editor.mathquill('cmd', '2');
                editor.mathquill('onKey', 'Right');
                break;
              case 'cubed':
                editor.mathquill('write', '^{3}');
                break;
              case 'd/dx':
                editor.mathquill('write','\\frac{d}{dx}');
                break;
            }
          }

          // after everything is said and done, tell mathquill it rendered. This
          // will update the value stored for the expressions latex. And that
          // will cause this change to go into undo/redo.
          editor.trigger('render');
      } catch (e) {

      }
    };
  });

  return KeypadView;
});

define('main/keypad_view_handwriting',['require','pjs','jquery','./keypad_view'],function(require){
  var P = require('pjs');
  var $ = require('jquery');

  var Keypad = require('./keypad_view');

  var KeypadWithHandwriting = P(Keypad, function (view, _super){
    view.didCreateElement = function() {

      var self = this;
      _super.didCreateElement.call(self);

      var request = { abort: $.noop }, timeoutId;
      var strokes = [], currentStroke = { type: 'stroke', x:[], y:[] };
      var pxRatio = self.pxRatio = window.devicePixelRatio || 1;
      var canvas = self.$canvas = self.$('.handwriting-area');
      self.$keys.on('tapstart', function(evt) {
        if (self.layout !== 'handwriting' ||
          $(evt.target).closest('.tappable', this).length) return;

        request.abort();
        clearTimeout(timeoutId);

        var context = canvas[0].getContext('2d');
        context.strokeStyle = 'white';
        context.beginPath();

        var offsetTop = canvas.offset().top;
        function addPt(evt) {
          var coords = evt.originalEvent.touches ? evt.originalEvent.touches[0] : evt;
          var x = coords.pageX, y = coords.pageY - offsetTop;
          context.lineTo(pxRatio * x, pxRatio * y);
          currentStroke.x.push(x), currentStroke.y.push(y);
        }
        addPt(evt);

        $(document).on('tapmove.handwriting', function(evt) {
          addPt(evt);
          context.stroke();
        }).one('tapend', function() {
          $(this).off('tapmove.handwriting');
          strokes.push(currentStroke);
          currentStroke = { type: 'stroke', x:[], y:[] };

          // start request before timeout
          var request = $.post(
            'https://myscript-webservices.visionobjects.com/api/myscript/v2.0/equation/doSimpleRecognition.json',
            {
              apiKey: 'ec39c110-c7f3-4a37-9aee-fdb06dff0372',
              equationInput: JSON.stringify({
                userResources: [ 'desmos_custom' ],
                resultTypes: [ 'LATEX' ],
                components: strokes
              })
            },
            null,
            'json'
          );

          var mq = self.expressionsView.getActiveMathquill(); // get before timeout
          timeoutId = setTimeout(function() {
            request.done(function(data) {
              var result = data.result.results[0].value.toLowerCase(), i, c;
              context.clearRect(0, 0, canvas[0].width, canvas[0].height);
              if (result === '\\wedge ') {
                mq.mathquill('onText', '^');
              }
              else if (result.slice(0,3) === ' / ') {
                mq.mathquill('onText', '/').mathquill('write', result.slice(3))
                .mathquill('onKey', 'Right');
              } else if (result.slice(0,11) === '\\overline {') {
                for (i = 11, c = 1; c > 0 && i < result.length; i += 1) {
                  c += (result[i] === '}' ? -1 : (result[i] === '{' ? 1 : 0));
                }
                mq.mathquill('onText', '/').mathquill('write', result.slice(11, i-1))
                .mathquill('onKey', 'Right').mathquill('write', result.slice(i));
              } else if ('(){}[]√'.split('').indexOf(result) >= 0) {
                mq.mathquill('onText', result);
              } else {
                if (result.slice(0,11) === '\\vphantom {') {
                  for (i = 11, c = 1; c > 0 && i < result.length; i += 1) {
                    c += (result[i] === '}' ? -1 : (result[i] === '{' ? 1 : 0));
                  }
                  if (result.slice(i, i+11) !== '^{\\wedge } ') console.error(':(');
                  result = '^{' + result.slice(i+11) + '}';
                }
                else if (result.slice(0,7) === '\\wedge ') {
                  result = result.slice(7);
                  if (result.slice(0,2) !== '^{') {
                    result = '^{' + result + '}';
                  }
                }
                else if (result.charAt(0) === '=') {
                  mq.mathquill('onText', '='); // make '>=' => '≥' work
                  result = result.slice(1);
                }
                mq.mathquill('write', result);
              }
              mq.trigger('render');
              strokes = [];
            });
            timeoutId = undefined;
          }, 1000);
        });
      });
    };

    view.resize = function () {
      this.$canvas[0].width = this.pxRatio * parseInt(this.$canvas.width(), 10);
      this.$canvas[0].height = this.pxRatio * parseInt(this.$canvas.height(), 10);
    };

    view.setupKeypad = function() {
      _super.setupKeypad.call(this);

      //override buttons
      this.buttons.numbersRight[1] = {
        keys: this.buttonArray('narrowToggleLetters toggleHandwriting enter')
      };

      this.buttons.handwriting = [
        {keys: this.buttonArray('backspace') },
        {keys: this.buttonArray('toggleNumbers') },
        {keys: this.buttonArray('enter') }
      ];
    };

  });
  
  return KeypadWithHandwriting;
});

//Abstract out getState and setState functionality
//TODO - setState is still pretty gross, but this is better than copy/pasting that grossness

define('main/state_controller',['require','pjs','undoredo','expressions/colors'],function (require) {
  var P = require('pjs');
  var UndoRedo = require('undoredo');
  var Colors = require('expressions/colors');

  var StateController = P(function (proto) {
    
    var BLANK_STATE = {
      'graph': {
        'viewport': {
          'xmin': -10,
          'xmax': 10,
          'ymin': -10,
          'ymax': 10
        },
        'showLabels': true,
        'showGrid': true,
        'showAxes': true,
        'squareAxes': true,
        'labelXMode': '',
        'labelYMode':''
      },
      'expressions': {'list': [{'id': 1,'latex': '','selected' :true}]}
    };
    
    proto.init = function (graphController, expressionsModel, graphSettings, expressionsView) {
      this.graphController = graphController;
      this.expressionsModel = expressionsModel;
      this.graphSettings = graphSettings;
      this.isFirstSetState = true;
      this.expressionsView = expressionsView;
    };

    proto.getState = function (encoding) {
      /* jshint nonstandard: true */
      var obj = {
        graph: this.graphController.getState(),
        expressions: this.expressionsModel.getState()
      };
      if (encoding == 'escaped') {
        return escape(JSON.stringify(obj));
      } else {
        return obj;
      }
    };

    proto.setState = function (state, encoding) {
      /* jshint nonstandard: true */
      this.graphSettings.setProperty('POIs', false);
      this.expressionsView.setSelected(null);

      //don't set blank state more than once
      if (
        !this.isFirstSetState &&
        (state === null) &&
        this.expressionsModel.isEmpty()
      ) {
        return;
      }

      var self = this;
      var manipulator = function (state, encoding) {
        Colors.reset();
        if (!state) state = BLANK_STATE;
        if (encoding === 'escaped' || typeof state === 'string') {
          try {
            state = JSON.parse(unescape(state));
          } catch (e) {
            alert('invalid state!'); return;
          }
        }
        // Empty the evaluator and the graph so that when we switch to the new
        // viewport, we don't flash a rescaled version of the old state.
        if ('expressions' in state) {
          self.expressionsModel.setState({ list: [] });
        }

        self.graphController.manager.clear();
        self.graphController.manager.redrawGraphsLayer();

        if ('graph' in state) {
          if (!('degreeMode' in state.graph)) state.graph.degreeMode = false;

          self.graphController.setState(state.graph);
        }

        if ('expressions' in state) {
          self.expressionsModel.setState(state.expressions);
        }
      };

      //apply it this first time, but don't add to undo/redo
      if (this.isFirstSetState) {
        manipulator(state, encoding);
        this.isFirstSetState = false;
        return;
      }

      var curState = this.getState();
      UndoRedo.addTransaction({
        type: UndoRedo.CAUSE_OF_CHANGE,
        undo: function () { manipulator(curState); },
        redo: function () { manipulator(state, encoding); },

        // we stringify two json objects that come out of the same function.
        // If the objects are the same, then the stringified versions will be
        // exactly the same.
        ensureChangeOccured: function () {
          var newState = JSON.stringify(self.getState());
          var oldState = JSON.stringify(curState);

          return oldState === newState;
        }
      });
    };

    proto.setBlank = function () {
      this.setState(BLANK_STATE);
      UndoRedo.markAsSaved();
    };
  });

  return StateController;

});

// Listens to expressionsView and propagates selection changes to the grapher
// and evaluator.
//
// TODO this could be *much* simpler if we had a better model for expressing
// selection within a table.
define('main/propagate_selection',['require'],function (require) {
  function propagateSelection(expressionsView, grapher, evaluator) {
    var lastSelectedId;
    var lastSelectedModel;
    
    // Show pois for the currently selected equation.
    var onSelectedExpressionChange = function () {
      var selected = expressionsView.getSelected();
      // setups up a listener for changes in selection within tables. It's fine
      // that we add these observers for even non-tables.
      if (selected !== lastSelectedModel) {
        if (lastSelectedModel) {
          lastSelectedModel.unobserve('selectedCell.calcjs');
        }
        if (selected) {
          selected.observe('selectedCell.calcjs', onSelectedExpressionChange);
        }
        lastSelectedModel = selected;
      }
      
      var selectedId = (selected) ? selected.id : undefined;

      if (selected && selected.isTable) {
        var selectedCell = selected.selectedCell;
        if (selectedCell) {
          var selectedCol = selected.columns[selectedCell.column];
          selectedId = selectedCol ? selectedCol.id : undefined;
        } else {
          selectedId = undefined;
        }
      }

      var idChanged = (selectedId !== lastSelectedId);

      if (idChanged) {
        grapher.select(selectedId);
        var intersectIds = grapher.getOpenIntersectionIds();
        if (typeof selectedId !== "undefined") intersectIds[selectedId] = true;
        evaluator.setIntersectIds(intersectIds);
        // Causes a redraw that will update the grapher appearance.
        evaluator.updateIntersections(selectedId);
      }

      lastSelectedId = selectedId;
    };

    expressionsView.observe('selectedItem', onSelectedExpressionChange);
  }

  return propagateSelection;
});
define('lib/set_list_height',['require','main/resize'],function (require) {
  var Resize = require('main/resize');
  
  var init = function (expressionsView, keypadView) {
    var resize = function () {
      var keypad_height = keypadView.height();
      expressionsView.setBottom(keypad_height);
      expressionsView.ensureActiveChildIsVisible();
    };

    Resize.register(resize);
  };
  
  return {init: init};
});

define('template!settings_tablet_window', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="window-container">\n  <div class="settings-btn action-togglevisible">\n    <i class=\'icon-window\'></i>\n  </div>\n\n  <div class="settings-scrollable bottom" popover="true">\n    <div class="inner-bg">\n      <div class="popover-interior">\n        <div class="popover-title">\n          '+
( t('Window') )+
'\n        </div>\n        <div class="popover-content">\n          <div class="window desmos-input-container" id="x-window">\n            <table>\n              <tr>\n                <td>\n                  <span class=\'before-input\'></span>\n                    <input id="xmin" type="number" />\n                  <span class=\'after-input\'></span>\n                </td>\n                <td>&lt;&nbsp;<i>x</i>&nbsp;&lt;</td>\n                <td>\n                  <span class=\'before-input\'></span>\n                  <input id="xmax" type="number" />\n                  <span class=\'after-input\'></span>\n                </td>\n              </tr>\n            </table>\n          </div>\n\n          <div class="window desmos-input-container" id="y-window">\n            <table>\n              <tbody>\n                <tr>\n                  <td>\n                    <span class=\'before-input\'></span>\n                      <input id="ymin" type="number" />\n                    <span class=\'after-input\'></span>\n                  </td>\n                  <td>&lt;&nbsp;<i>y</i>&nbsp;&lt;</td>\n                  <td>\n                    <span class=\'before-input\'></span>\n                      <input id="ymax" type="number" />\n                    <span class=\'after-input\'></span>\n                  </td>\n                </tr>\n              </tbody>\n            </table>\n          </div>\n          <div class=\'buttons-container\'>\n            <div>\n              <button id="square-axes" class="btn disabled action-squareaxes">\n                '+
( t('equalize') )+
'\n              </button>\n            </div>\n            <div>\n              <button id="restore-default" class="btn action-zoomrestore">\n                '+
( t('restore to default') )+
'\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\'triangle\'>    \n    </div>\n  </div>\n</div>';
}
return __p;
};});
define('main/settings_view',['require','jquery','underscore','pjs','main/popover_view','graphing/viewport'],function(require){
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var Viewport = require('graphing/viewport');

  /*
  * view for the settings bar
  */
  var SettingsView = P(PopoverView, function (view, _super){
    view.viewport = new Viewport();
    
    view.init = function (graphController) {
      _super.init.call(this);
      
      this.graphController = graphController;
      this.grapher = graphController.manager;
      this.settings = this.grapher.settings;
    };
    
    view.closeCondition = function (evt) {
      return !$(evt.target).closest(this.openCloseBtn).length && !$(evt.target).closest("#settings-container").length;
    };
    
    view.didCreateElement = function () {
      _super.didCreateElement.call(this);
      
      var self = this;
      
      this.$('.action-squareaxes').on('tap', function (){
        self.settings.setProperty("squareAxes", true);
      });
      this.$('#show-labels').on('change', function () {
        self.settings.setProperty('showLabels', !!$(this).attr('checked'));
      });
      this.$('#show-grid').on('change', function () {
        self.settings.setProperty('showGrid', !!$(this).attr('checked'));
      });
      this.$('.action-polargrid').on('tap', function () {
        self.settings.setProperty('polarMode', !self.settings.getProperty('polarMode'));
      });
      this.$('#show-axes').on('change', function () {
        self.settings.setProperty('showAxes', !!$(this).attr('checked'));
      });
      
      this.$('#xmin, #xmax, #ymin, #ymax')
        .on('keydown keyup keypress', this.onInputKeyPress.bind(this))
        .on('focusout', this.onFocusOut.bind(this))
        .on('focusin', this.onFocusIn.bind(this));
        
      this.updateTextInputs();
    };
    
    view.addSettingsObserver = function (prop, func) {
      var f = func.bind(this);
      this.settings.observe(prop, f);
      f();
    };
    
    view.onInputKeyPress = function (evnt) {
      var xmin = parseFloat(this.$("#xmin").val());
      var xmax = parseFloat(this.$("#xmax").val());
      var ymin = parseFloat(this.$("#ymin").val());
      var ymax = parseFloat(this.$("#ymax").val());
      
      var tempViewport = new Viewport(xmin, xmax, ymin, ymax);
      this.$("#x-window").toggleClass("invalid", !tempViewport.isXValid());
      this.$("#y-window").toggleClass("invalid", !tempViewport.isYValid());
      this.settings.setProperty(
        'squareAxes',
        tempViewport.isSquare(this.grapher.screen)
      );
      this.setViewport(tempViewport);
    };
    
    view.renderProjectorMode = function () {
      var pmode = this.settings.projectorMode;
      this.$('#projector-mode').toggleClass('active', !!pmode);
    };
    
    view.renderXPiLabels = function () {
      var xpi = this.settings.xAxisPiLabels;
      this.$("#x-numlabels").toggleClass('active', !xpi);
      this.$("#x-pilabels").toggleClass('active', !!xpi);
    };
    
    view.renderYPiLabels = function () {
      var ypi = this.settings.yAxisPiLabels;
      this.$("#y-numlabels").toggleClass('active', !ypi);
      this.$("#y-pilabels").toggleClass('active', !!ypi);
    };
    
    view.renderDegreeMode = function () {
      var degrees = this.settings.degreeMode;
      this.$("#radians").toggleClass('active', !degrees);
      this.$("#degrees").toggleClass('active', !!degrees);
    };
    
    view.renderSquareAxes = function () {
      var square = this.settings.squareAxes;
      this.$("#square-axes")
          .toggleClass("disabled", !!square)
          .toggleClass("btn-success", !square);
    };
    
    view.renderShowLabels = function () {
      var checked = this.settings.showLabels;
      var checkbox = this.$('#show-labels');
      if (checked) {
        checkbox.attr('checked','checked');
      } else {
        checkbox.removeAttr('checked');
      }
    };
    
    view.renderShowGrid = function () {
      var checked = this.settings.showGrid;
      var checkbox = this.$('#show-grid');
      if (checked) {
        checkbox.attr('checked','checked');
      } else {
        checkbox.removeAttr('checked');
      }
    };
    
    view.renderPolarMode = function () {
      this.$('#cartesian-grid').toggleClass(
        'active',
        !this.settings.polarMode
      );
      this.$('#polar-grid').toggleClass('active', !!this.settings.polarMode);
      this.$('#x-pilabels, #x-numlabels, #y-pilabels, #y-numlabels').toggleClass(
        'disabled',
        !!this.settings.polarMode
      );
    };
    
    view.renderShowAxes = function () {
      var checked = this.settings.showAxes;
      var checkbox = this.$('#show-axes');
      if (checked) {
        checkbox.attr('checked','checked');
      } else {
        checkbox.removeAttr('checked');
      }
    };
    
    view.updateTextInputs = function() {
      var self = this;
      _.each(['xmin', 'xmax', 'ymin', 'ymax'], function(field) {
        if (parseFloat(self.$('#' + field).val()) !== self.viewport[field]) {
          self.$('#' + field).val(self.viewport[field]);
        }
      });
    };

    view.triggerViewportChanged = function () {};

    view.setViewport = function (newViewport) {
      if (newViewport.equals(this.viewport)) return;
      if (!newViewport.isValid()) return;
      
      this.viewport = newViewport.clone();

      // set lastChangedAxis
      var oldViewport = this.graphController.getViewport();
      if (oldViewport.ymax !== newViewport.ymax || oldViewport.ymin !== newViewport.ymin)
        this.settings.lastChangedAxis = 'y';
      if (oldViewport.xmax !== newViewport.xmax || oldViewport.xmin !== newViewport.xmin)
        this.settings.lastChangedAxis = 'x';
      
      this.updateTextInputs();
      this.graphController.setViewport(newViewport);
      
      this.triggerViewportChanged();
    };

    // FocusIn and FocusOut work together here to make sure the viewport is
    // set to an acceptable range after the viewport inputs are no longer
    // being edited.
    view.onFocusIn = function (evt) {
      clearTimeout(this.stopEditingTimeout);
    };

    view.onFocusOut = function (evt) {
      var self = this;

      this.stopEditingTimeout = setTimeout( function () {
        clearTimeout(self.stopEditingTimeout);
        self.updateTextInputs();
        
        //when we leave, reset the "error" class
        this.$("#x-window").toggleClass("invalid", !self.viewport.isXValid());
        this.$("#y-window").toggleClass("invalid", !self.viewport.isYValid());
      }, 1);
    };
    
  });

  return SettingsView;
});

/* on mobile, settings is split into two dropdowns, which both inherit from here
 * this has some common logic that's ported from subheader.js on desktop
 * for handling opening & closing of the menus
 */

define('main/settings_view_tablet',['require','pjs','./settings_view','main/focus'],function(require){
  var P = require('pjs');
  var SettingsView = require('./settings_view');
  var Focus = require('main/focus');

  /*
  * view for the options dropdowns on tablets
  * inherited by the window and options js files
  */
  var TabletSettingsView = P(SettingsView, function (view, _super){
    
    view.didCreateElement = function() {
      _super.didCreateElement.call(this);

      this.$('.action-togglevisible').on('tapstart', function (){
        // blur any textbox that has focus. On some devices, such as ipad
        // and nexus 7, (and qunit!) this doesn't happen automatically.
        Focus.takeFocus();
      });
      
      this.setupOpenButton(this.$('.action-togglevisible'), 'tapstart');
    };

    view.renderIsVisible = function () {
      this.$('.bottom').toggle(this.isVisible);
    };
  });

  return TabletSettingsView;
});

/* on mobile, settings is split into two dropdowns
 *   options and window (this file)
 */

define('main/settings_view_tablet_window',['require','pjs','template!settings_tablet_window','./settings_view_tablet'],function(require){
  var P = require('pjs');
  var template = require('template!settings_tablet_window');
  var SettingsViewTablet = require('./settings_view_tablet');

  /*
  * view for the settings bar
  */
  var SettingsViewTabletWindow = P(SettingsViewTablet, function (view, _super){
    view.template = template;
    view.name = 'settings_tablet_window';
    
    view.didCreateElement = function() {
      _super.didCreateElement.call(this);

      var self = this;
      this.$('.action-zoomrestore').on('tap', function (){
        self.graphController.zoom("default");
      });

      this.renderRestoreAxes();

      this.addSettingsObserver('squareAxes', this.renderSquareAxes);
    };
    
    view.triggerViewportChanged = function () {
      this.renderRestoreAxes();
    };
    
    view.renderRestoreAxes = function () {
      var isDefault = this.graphController.isZoomRestored();
      this.$('#restore-default').toggleClass('disabled', !!isDefault);
    };

  });

  return SettingsViewTabletWindow;
});

define('template!settings_tablet_options', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="options-container">\n  <div class="settings-btn action-togglevisible">\n    <i class=\'icon-wrench\'></i>\n  </div>\n  \n  <div class="bottom settings-scrollable" popover="true">\n   <div class="inner-bg">\n      <div class="popover-interior">\n       <div class="popover-title">'+
( t('View') )+
'</div>\n       <div class="popover-content">\n  \n         <div class=\'label action-projectormode\'>\n           '+
( t('Projector Mode') )+
'\n           <div class=\'toggle-on-off\' id=\'projector-toggle\'>\n             <span class=\'thumb\'>\n                <span class=\'off\'>'+
( t('off') )+
'</span><span class=\'on\'>'+
( t('on') )+
'</span>\n             </span>\n           </div>\n         </div>\n       </div>\n  \n  \n        <div class="popover-title">'+
( t('Graph Paper') )+
'</div>\n        <div class="popover-content">\n          <div class=\'label action-showlabels\'>\n            '+
( t('Labels') )+
'\n            <div class=\'toggle-on-off\' id=\'labels-toggle\'>\n              <span class=\'thumb\'>\n                 <span class=\'off\'>'+
( t('off') )+
'</span><span class=\'on\'>'+
( t('on') )+
'</span>\n              </span>\n            </div>\n          </div>\n  \n          <div class=\'label action-showgrid\'>\n          '+
( t('Grid Lines') )+
'\n            <div class=\'toggle-on-off\' id=\'grid-toggle\'>\n              <span class=\'thumb\'>\n                 <span class=\'off\'>'+
( t('off') )+
'</span><span class=\'on\'>'+
( t('on') )+
'</span>\n              </span>\n            </div>\n          </div>\n  \n          <div class=\'label action-showaxes\'>\n            '+
( t('Axes') )+
'\n            <div class=\'toggle-on-off\' id=\'axes-toggle\'>\n              <span class=\'thumb\'>\n                 <span class=\'off\'>'+
( t('off') )+
'</span><span class=\'on\'>'+
( t('on') )+
'</span>\n              </span>\n            </div>\n          </div>\n        </div>\n  \n  \n        <div class="popover-title interior-title">'+
( t('Trig Settings') )+
'</div>\n        <div class="popover-content trig-settings">\n          <table class="pi-labels">\n            <tbody>\n              <tr>\n                <td>\n                  '+
( t('<i>x</i>-axis labels:') )+
'\n                </td>\n                <td>\n                  <div class="toggle-group action-xpilabels" id="xpilabels-toggle">\n                    <div class=\'thumb\'></div>\n                    <span class=\'first-option\'>1, 2, 3</span>\n                    <span class=\'second-option\'>\n                      <font class="pi">π, 2π, 3π</font>\n                    </span>\n                  </div>\n                </td>\n              </tr>\n              <tr>\n                <td>\n                  '+
( t('<i>y</i>-axis labels:') )+
'\n                </td>\n                <td>\n                  <div class="toggle-group action-ypilabels" id="ypilabels-toggle">\n                    <div class=\'thumb\'></div>\n                    <span class=\'first-option\'>1, 2, 3</span>\n                    <span class=\'second-option\'>\n                      <font class="pi">π, 2π, 3π</font>\n                    </span>\n                  </div>\n                </td>\n              </tr>\n              <tr>\n                <td>\n                  '+
( t('Angles:') )+
'\n                </td>\n                <td>\n                  <div class="toggle-group action-radianmode" id="radian-toggle">\n                    <div class=\'thumb\'></div>\n                    <span class=\'first-option\'>'+
( t('degrees') )+
'</span>\n                    <span class=\'second-option\'>'+
( t('radians') )+
'</span>\n                  </div>\n                </td>\n  \n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n    \n    <div class="triangle">\n    </div>\n  \n  </div>\n</div>';
}
return __p;
};});
/* on mobile, settings is split into two dropdowns
 *   options (this file) and window
 */

define('main/settings_view_tablet_options',['require','pjs','template!settings_tablet_options','./settings_view_tablet'],function(require){
  var P = require('pjs');
  var template = require('template!settings_tablet_options');
  var SettingsViewTablet = require('./settings_view_tablet');

  /*
  * view for the settings bar
  */
  var SettingsViewTabletOptions = P(SettingsViewTablet, function (view, _super){
    view.template = template;
    view.name = 'settings_tablet_options';
    
    view.didCreateElement = function() {
      _super.didCreateElement.call(this);

      var self = this;

      //these feel better on tapstart here, even though it's better
      //on tap on desktop
      this.$('.action-showlabels').on('tapstart', function () {
        self.$('.action-showlabels .toggle-on-off').toggleClass('isOn');
        setTimeout(function() {
          self.settings.setProperty(
            'showLabels',
            !self.settings.showLabels
          );
        }, 100);
      });
      this.$('.action-showgrid').on('tapstart', function () {
        self.$('.action-showgrid .toggle-on-off').toggleClass('isOn');
        setTimeout(function() {
          self.settings.setProperty(
            'showGrid',
            !self.settings.showGrid
          );
        }, 100);
      });
      this.$('.action-polarmode').on('tapstart', function () {
        self.$('.action-polarmode .toggle-on-off').toggleClass('isOn');
        setTimeout(function() {
          self.settings.setProperty(
            'polarMode',
            !self.settings.polarMode
          );
        }, 100);
      });
      this.$('.action-showaxes').on('tapstart', function () {
        self.$('.action-showaxes .toggle-on-off').toggleClass('isOn');
        setTimeout(function() {
          self.settings.setProperty(
            'showAxes',
            !self.settings.showAxes
          );
        }, 100);
      });

      this.$('.action-projectormode').on('tapstart', function (){
        self.$('.action-projectormode .toggle-on-off').toggleClass('isOn');
        setTimeout(function() {
          self.settings.setProperty(
            'projectorMode',
            !self.settings.projectorMode
          );
        }, 100);
      });


      this.$('.action-xpilabels').on('tapstart', function (){
        if (self.settings.polarMode) return;
        
        self.$('.action-xpilabels').toggleClass('toggled');
        setTimeout(function() {
          self.settings.setProperty(
            'xAxisPiLabels',
            !self.settings.xAxisPiLabels
          );
        }, 100);
      });
      this.$('.action-ypilabels').on('tapstart', function (){
        if (self.settings.polarMode) return;
        
        self.$('.action-ypilabels').toggleClass('toggled');
        setTimeout(function() {
          self.settings.setProperty(
            'yAxisPiLabels',
            !self.settings.yAxisPiLabels
          );
        }, 100);
      });
      this.$('.action-radianmode').on('tapstart', function (){
        self.$('.action-radianmode').toggleClass('toggled');
        setTimeout(function() {
          self.settings.setProperty(
            'degreeMode',
            !self.settings.degreeMode
          );
        }, 100);
      });

      this.addSettingsObserver('projectorMode', this.renderProjectorMode);
      this.addSettingsObserver('xAxisPiLabels', this.renderXPiLabels);
      this.addSettingsObserver('yAxisPiLabels', this.renderYPiLabels);
      this.addSettingsObserver('degreeMode', this.renderDegreeMode);
      this.addSettingsObserver('showLabels', this.renderShowLabels);
      this.addSettingsObserver('showGrid', this.renderShowGrid);
      this.addSettingsObserver('polarMode', this.renderPolarMode);
      this.addSettingsObserver('showAxes', this.renderShowAxes);
    };
    
    //override the render functions
    view.renderShowLabels = function() {
      this.$('#labels-toggle').toggleClass(
        'isOn',
        !!this.settings.showLabels
      );
    };
    view.renderShowGrid = function() {
      this.$('#grid-toggle').toggleClass(
        'isOn',
        !!this.settings.showGrid
      );
    };
    view.renderPolarMode = function() {
      this.$('#polar-toggle').toggleClass(
        'isOn',
        !!this.settings.polarMode
      );
      
      this.$('#xpilabels-toggle, #ypilabels-toggle').toggleClass(
        'disabled',
        !!this.settings.polarMode
      );
    };
    view.renderShowAxes = function() {
      this.$('#axes-toggle').toggleClass(
        'isOn',
        !!this.settings.showAxes
      );
    };
    view.renderProjectorMode = function() {
      this.$('#projector-toggle').toggleClass(
        'isOn',
        !!this.settings.projectorMode
      );
    };

    view.renderDegreeMode = function () {
      var degrees = this.settings.degreeMode;
      this.$("#radian-toggle").toggleClass('toggled', !degrees);
    };
    view.renderXPiLabels = function () {
      var xpi = this.settings.xAxisPiLabels;
      this.$("#xpilabels-toggle").toggleClass('toggled', !!xpi);
    };
    view.renderYPiLabels = function () {
      var ypi = this.settings.yAxisPiLabels;
      this.$("#ypilabels-toggle").toggleClass('toggled', !!ypi);
    };



  });

  return SettingsViewTabletOptions;
});

define('template!zoom', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="zoom-pillbox">\n  <span\n    class="tooltip-e action-zoomin"\n    tooltip="'+
( t('Zoom In') )+
'"\n    tipsy-offset="15"\n  >\n    <i class="icon-plus"></i>\n  </span>\n  <span\n    class="tooltip-e action-zoomrestore"\n    tooltip="'+
( t('Restore Default Zoom') )+
'"\n    tipsy-offset="15"\n  >\n    <i class="icon-home"></i>\n  </span>\n  <span\n    class="tooltip-e action-zoomout"\n    tooltip="'+
( t('Zoom Out') )+
'"\n    tipsy-offset="15"\n  >\n    <i class="icon-minus"></i>\n  </span>\n</div>';
}
return __p;
};});
define('loadcss!css/zoom_pillbox', function(){});
define('main/zoom_view',['require','pjs','lib/underscore_view','lib/track_feature','template!zoom','loadcss!css/zoom_pillbox'],function (require) {
  var P = require('pjs');
  var UnderscoreView = require('lib/underscore_view');
  var Feature = require('lib/track_feature');
  var template = require('template!zoom');

  require('loadcss!css/zoom_pillbox');

  var ZoomView = P(UnderscoreView, function (view, _super) {
    view.init = function (graphController) {
      _super.init.call(this);
      this.template = template;
      this.graphController = graphController;
    };

    view.didCreateElement = function () {
      this.$('.action-zoomin').on('tap', this.zoomIn.bind(this));
      this.$('.action-zoomrestore').on('tap', this.zoomRestore.bind(this));
      this.$('.action-zoomout').on('tap', this.zoomOut.bind(this));
    };

    view.zoomIn = function() {
      Feature.use('Zoom In');
      this.graphController.zoom("in");
    };

    view.zoomRestore = function() {
      Feature.use('Zoom Restore');
      this.graphController.zoom("default");
    };

    view.zoomOut = function() {
      Feature.use('Zoom Out');
      this.graphController.zoom("out");
    };
  });

  return ZoomView;
});


// Defines a simple API used by our screenshot service.
define('lib/external_screenshot',['require','pjs'],function (require) {
  var P = require('pjs');

  var Screenshot = P(function (proto) {
    proto.init = function ($root, expressionsView, grapher, evaluator, stateController) {
      this.$root = $root;
      this.expressionsView = expressionsView;
      this.grapher = grapher;
      this.evaluator = evaluator;
      this.stateController = stateController;
    };

    proto.initialize = function (options, cb) {
      this.$root.addClass('external-screenshot');
      // Allow expression list to overflow for screenshoting.
      document.styleSheets[0].insertRule(
        '* {overflow: visible !important;}',
        document.styleSheets[0].cssRules.length
      );
      cb();
    };

    function getClipRect (elt) {
      var clientRect = elt.getBoundingClientRect();
      return {
        top: clientRect.top,
        left: clientRect.left,
        width: clientRect.width,
        height: clientRect.height
      };
    }

    function waitFor (pred, cb) {
      if (pred) {
        setTimeout(cb);
      } else {
        setTimeout(function () {
          waitFor(pred, cb);
        }, 100);
      }
    }

    proto.load = function (obj, cb) {
      this.stateController.setState(obj.state);

      var self = this;
      this.evaluator.notifyWhenSynced(function () {
        waitFor(function () {
          return self.expressionsView.$('.shell.expressionitem').length === 0;
        }, function () {
          // TODO, after jumping through all these hoops, still need an arbitrary timeout to wait
          // for the expression icons to load. Ugh.
          setTimeout(function () {
            cb({
              boxes: {
                expressions: getClipRect(self.expressionsView.$('.expressionlist')[0]),
                graphpaper: getClipRect(self.grapher.$[0])
              }
            });
          }, 100);
        });
      });
    };
  });

  return Screenshot;
});
define('lib/urlparser',['require'],function (require) {

  var UrlParser = {
    //from http://stackoverflow.com/questions/1403888/get-url-parameter-with-javascript-or-jquery
    getParameter: function(name) {
      return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)')
             .exec(location.search)||[,""])[1]
             .replace(/\+/g, '%20'))||null;
    }
  };

  return UrlParser;
});
define('loadcss!css/tour', function(){});
/*
 *  Modified (heavily) by Eli for the following reasons:
 *    - keep Trip out of the global namespace
 *    - work with our click events
 *    - pass jshint
 *    - get rid of unused methods
 *    - get rid of the other methods too
 *
 *  Trip.js - A jQuery plugin that can help you customize your tutorial trip easily
 *  Version : 1.2.2
 *
 *  Author : EragonJ <eragonj@eragonj.me> 
 *  Blog : http://eragonj.me
 */

 define('lib/trip',['require','jquery','pjs'],function (require) {
    var $ = require('jquery');
    var P = require('pjs');

    var Trip = P({

        init : function(settings) {
                var html = [
                    '<div class="trip-block">',
                        '<div class="trip-interior">',
                            '<a class="trip-close"><i class="icon-remove"></i></a>',
                            '<div class="trip-content"></div>',
                        '</div>',
                        '<div class="trip-arrow"></div>',
                    '</div>'
                ].join('');

                var that = this;
                var $tripBlock = this.$tripBlock = $(html);

                $tripBlock.css({top: '-100px'});

                $('body').append( $tripBlock );

                $tripBlock.find('.trip-close').on("tap", function(e) {
                    e.preventDefault();
                    that.stop();
                });

                this.bindKeyEvents();

                this.settings = settings;
        },

        cleanup : function() {
            this.unbindKeyEvents();

            this.hideTripBlock();
            return false;
        },

        bindKeyEvents : function() {
            var that = this;
            $(document).on({
                'keydown.Trip' : function(e) {
                    // `this` will be bound to #document DOM element here
                    that.keyEvent.call(that, e); 
                }
            });
        },

        unbindKeyEvents : function() {
            $(document).off('keydown.Trip');
        },

        keyEvent : function(e) {
            if ( e.which === 27 ) this.stop();  //ESC key
        },

        stop : function() {
            this.hideTripBlock();
            this.settings.onTripStop();
        },

        showTripBlock : function( o ) {
            if(typeof o.sel === 'string') {
                o.sel = $(o.sel);
            }

            var $tripBlock = this.$tripBlock;

            $tripBlock.find('.trip-content')
                      .html( o.content );

            var $sel = o.sel,
                selWidth = $sel.outerWidth(),
                selHeight = $sel.outerHeight(),
                blockWidth = $tripBlock.outerWidth(),
                blockHeight = $tripBlock.outerHeight(),
                arrowHeight = 10,
                arrowWidth = 10;

            // Take off e/s/w/n classes
            $tripBlock.removeClass('e s w n');

            var horizontalShift = 0;

            switch( o.position ) {
            case 'e':
                $tripBlock.addClass('e');
                $tripBlock.css({
                    left : $sel.offset().left + selWidth + arrowWidth,
                    top : $sel.offset().top - (( blockHeight - selHeight ) / 2)
                });
                break;
            case 's':
                $tripBlock.addClass('s');
                var left = $sel.offset().left + ((selWidth - blockWidth) / 2);
                $tripBlock.css({
                    left : left,
                    top : $sel.offset().top + selHeight + arrowHeight
                });

                if (left + blockWidth > $(window).width() - 1) {
                    horizontalShift = $(window).width() - 1 - left - blockWidth;
                }
                if (left < 1) {
                    horizontalShift = 1 - left;
                }

                break;
            case 'w':
                $tripBlock.addClass('w');
                $tripBlock.css({
                    left : $sel.offset().left - (arrowWidth + blockWidth),
                    top : $sel.offset().top - (( blockHeight - selHeight ) / 2)
                });
                break;
            case 'n':
            default: 
                $tripBlock.addClass('n');
                $tripBlock.css({
                    left : $sel.offset().left + ((selWidth - blockWidth) / 2),
                    top : $sel.offset().top - arrowHeight - blockHeight
                });

                break;
            }

            $tripBlock.find('.trip-interior')
                .css('transform', 'translate(' + horizontalShift + 'px, 0)');

            $tripBlock.css({
                display : 'inline-block'
            });
        },

        fadeInTripBlock : function () {
            var $tripBlock = this.$tripBlock;
            //need this on the next cycle so that the animation works
            setTimeout(function () {
                $tripBlock.addClass('is-loaded');
            }, 0);
        },

        hideTripBlock : function() {
            this.$tripBlock.removeClass('is-loaded');
        },
    });
    return Trip;
});

define('tours/base_tour',['require','pjs','jquery','underscore'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');

  return P(function(tour){

    tour.init = function (Calc) {
      this.Calc = Calc;

      // Legacy. New code should talk to the attached Calc object.
      this.expressionsView = this.Calc.expressions;
    };

    tour.expressionsVisible = function () {
      return this.expressionsView.getProperty('expressionsVisible');
    };

    tour.requireExpressionsVisible = function () {
      return {
        position: 'e',
        content: 'Click to show the list of expressions.',
        sel: $('.action-showexpressions')
      };
    };

    tour.resourcesOpen = function () {
      return $('body').hasClass('resources-open');
    };

    tour.requireResourcesNotOpen = function () {
      return {
        position: 'e',
        content: 'Click to return to this graph.',
        sel: $('.action-opendrawer')
      };
    };

    tour.editListMode = function () {
      return this.expressionsView.getProperty('editListMode');
    };

    tour.requireNotEditListMode = function () {
      return {
        position: 's',
        content: 'Click to return to your expressions.',
        sel: $('.action-toggleeditlistmode')
      };
    };

    tour.expressionCount = function () {
      return this.expressionsView.getItemsByIndexRange(0, Infinity).length;
    };

    //a few helper functions. Note: many of these require
    //the conic flag to be on

    tour.grapher = function() {
      return this.Calc.grapher;
    };

    tour.hasConic = function (conic) {
      return _.find(this.grapher().graphSketches, function(sketch, id) {
        return _.find(sketch.branches, function(branch) {
          return (branch.conic === conic);
        });
      });
    };
  });
});

define('tours/sliders',['require','pjs','jquery','underscore','./base_tour'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var BaseTour = require('./base_tour');

  return P(BaseTour, function(tour, _super){

    //state variables
    tour.sliderHasSlid = false;
    tour.sliderBtnsShown = false;

    tour.isExpAnimating = function (exps) {
      var animating = _.filter(exps, function(exp) {
        return (exp.slider && exp.slider.isPlaying);
      });
      return (animating.length);
    };

    tour.update = function() {

      var expressions = this.expressionsView.getItemsByIndexRange(0, Infinity);


      //End condition: there's a graphable function which depends on a slider that is playing
      //TODO - not enforcing graphable dependent function yet
      //graphability is easy to check (formula.is_graphable), but dependency tree isn't exported
      //from the worker.
      if(this.isExpAnimating(expressions)) return {
        final: true,
        position: 's',
        endingMsg: "You're a slider pro!",
        sel: $('.animate-pause').last(),
      };

      //need expressions open for the entirety of this tour
      if (!this.expressionsVisible()) {
        return this.requireExpressionsVisible();
      }

      if (this.resourcesOpen()) {
        return this.requireResourcesNotOpen();
      }

      if (this.editListMode()) {
        return this.requireNotEditListMode();
      }

      //If there's something playable, tell the user to play it
      var playButton = $('.animate-play').last();

      var graphableExps = _.filter(expressions, function(exp) {
        return exp && exp.formula && exp.formula.is_graphable;
      });

      if(playButton.length && graphableExps.length){

        var slidSliders = _.filter(expressions, function(exp) {
          return (exp && exp.slider && exp.slider.value !== 1);
        });

        if (this.sliderHasSlid || slidSliders.length > 0) {
          if ($('.thumb.depressed').length > 0) {
            return {doNotUpdate: true};
          }

          this.sliderHasSlid = true;
          return {
            position: 's',
            content: '<b>Go "Hands-free"</b><br>Press play to animate the slider.',
            sel: playButton
          };
        }

        return {
          position: 's',
          content: 'Drag the handle to change the value.',
          sel: $('.slider-container .thumb:visible').last()
        };
      }

      //If there's a slider ready to create, create it (prioritizing selected equation)
      var selected = this.expressionsView.getSelectedView();
      var createSliderBtn = [];
      if(selected) createSliderBtn = selected.$('.action-createslider .btn');
      if(!createSliderBtn.length) createSliderBtn = $('.action-createslider .btn');
      //need multiple buttons, or for the person to have done something interesting. 
      //for example, the 2nd one catches the situation where they've already created a slider
      //the goal of this "or" is to avoid the circumstance where they type "y=m" and it skips
      //to the next step
      if(createSliderBtn.length > 1 || (createSliderBtn.length && expressions.length > 1)) {
        //little timer so that we don't move too quickly
        if (this.sliderBtnsShown && (new Date() - this.sliderBtnsShown) > 600) {
          return {
            position: 's',
            content: 'Awesome! Now click here to add the sliders.',
            sel: createSliderBtn.last()
          };
        } else {
          if (!this.sliderBtnsShown) this.sliderBtnsShown = new Date();
          return {doNotUpdate: true};
        }
      }

      this.sliderBtnsShown = false;

      //If we're in an expression, make it need a slider
      if(selected){
        return {
          position: 'e',
          content: '<b>Let\'s make some sliders</b><br>Try typing <span class="italic">y=mx+b</span>',
          sel: selected.$()
        };
      }

      //Select an expression
      var firstItem = this.expressionsView.getFirstVisibleItem();
      var firstView = this.expressionsView.getItemView(firstItem.id);
      return {
        position: 'e',
        content: 'Click here to type in this expression',
        sel: firstView.$()
      };

      //Make sure expressions are visible
      
    };
  });
});

define('tours/scatter_plot',['require','pjs','jquery','underscore','./base_tour'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var BaseTour = require('./base_tour');

  return P(BaseTour, function(tour, _super){

    tour.hasChangedDisplayType = false;

    tour.update = function(){
      // Tour:
      // 1. Make a table from drop-down as a scatter-plot
      //      Complete when at least one data column length > 1
      //      filled in, and corresponding independent column filled in.
      // 2. Convert an expression into a table
      var expressions = this.expressionsView.getItemsByIndexRange(0, Infinity);
      var tables = _.filter(expressions, function(e){return e.hasOwnProperty('columns')});


      //need expressions open for the entirety of this tour
      if (!this.expressionsVisible()) {
        return this.requireExpressionsVisible();
      }

      if (this.resourcesOpen()) {
        return this.requireResourcesNotOpen();
      }

      if (this.editListMode()) {
        return this.requireNotEditListMode();
      }

      //Click add expression to show create table button
      if (tables.length === 0) {
        var newTable = $('.action-newtable:visible');
        if (newTable.length === 0) return {
          position: 'e',
          content: '<b>Let\'s make a scatter plot</b><br>' +
                   'Click here to add a new item.',
          sel: $('.add-expression-btn')
        };

        //If there are no tables but we can see create table button, create a table
        return {
          position: 'e',
          content: '... and select the "table" option.',
          sel: newTable
        };
      }

      //See what columns have been made so far
      var dataColumns = [];
      var expressionColumns = [];
      var table, tableView;
      for(var i = 0; i < tables.length; i++){
        table = tables[i];
        for(var j = 1; j < table.columns.length - 1; j++){ //Skip first and last column
          //expression columns are called disabled in table.js
          //because you can't type in them
          tableView = this.expressionsView.getItemView(table.id);
          var columnView = tableView.columnViews[j];
          if(table.columns[j].disabled)
            expressionColumns.push({ model: table.columns[j], view: columnView, tableView: tableView });
          else
            dataColumns.push({ model: table.columns[j], view: columnView, tableView: tableView });
        }
      }

      //TODO: I think we can clean up the above logic a bunch now that
      //we've separated the tours
      //////////////// Scatter-plot tour ////////////////

      if (dataColumns.length === 0) return {
        position: 'e',
        content: 'Type <var>y</var> here to create a data column.',
        sel: '.editable.right.header:first'
      };

      //guide through the process of filling in this table
      table = dataColumns[0].model.table;
      tableView = this.expressionsView.getItemView(table.id);
      var focused = table.selectedCell;
      var rows = table.columns[0].cells.length;

      //check if the table's all filled up.
      var filledRows = 0;
      for (i = 0 ; i < rows && i < 3 ; i++) {
        if (
          table.columns[0].cells[i].value &&
          !table.columns[0].cells[i].error &&
          table.columns[1].cells[i].value &&
          !table.columns[1].cells[i].error
        ) filledRows++;
      }

      //Table's filled! proceed through changing the display type
      if (filledRows === 3) {
        var isConnected = (table.columns[1].columnMode === "POINTS_AND_LINES");
        var menuOpen = ($('.table-column-menu').length > 0);

        //all done -- connected dots
        if (isConnected && !menuOpen) return {
          final: true,
          position: 'e',
          endingMsg: 'You\'re a scatter plot whiz!',
          sel: tableView.$()
        };

        //we're almost done, just need to exit edit list mode
        if (isConnected) return {
          position: 'e',
          content: 'Click anywhere to close the drawing options.',
          sel: tableView.$()
        };
        
        //need to enter edit list mode to click the open button
        if (!menuOpen) return {
          content: ['<b>Last trick!</b><br>',
                    'Click and hold on this icon until the options menu opens up.'].join(''),
          position: 'e',
          sel: tableView.columnViews[1][0].$('.graph-icon')
        };

        //if the menu isn't open, open it
        return {
          content: 'Click to connect the dots',
          position: 'e',
          sel: '.table-points-and-lines'
        };
      }

      //
      //table's there and ready to filled. let's fill 'er up!
      //

      //Step 1: correct any errors if they exist
      var row, col;
      for (row = 0 ; row < rows ; row++) {
        for (col = 0 ; col < 2 ; col++) {
          if (table.columns[col].cells[row].error) {
            return {
              position: 'e',
              content: 'Uh-oh! type a valid number here.',
              sel: tableView.columnViews[col][row+1].$()
            };
          }
        }
      }

      if (!focused) {
        return {
          position: 'e',
          content: 'Click back to continue editing',
          sel: tableView.columnViews[1][rows-1].$()
        };
      }

      //this is a special case. You're in the top row and it's filled in
      //we teach going down a row.
      if (rows === 2 && filledRows === 1 && focused && focused.row === 1) {
        return {
          position: 'e',
          content: 'Go down to the next row to add more data.',
          sel: tableView.columnViews[1][focused.row].$()
        };
      }

      //a few special cases for creating new rows.
      if (rows === 3 && filledRows === 2 && focused) {
        return {
          position: 'e',
          content: '<b>Awesome!</b><br>Now try pressing Enter',
          sel: tableView.columnViews[1][focused.row].$()
        };
      }

      //fill in whatever cell is empty
      for (row = 0 ; row < rows ; row++) {
        for (col = 0 ; col < 2 ; col++) {
          if (!table.columns[col].cells[row].value) {

            var msg = 'Fill in this whole row';
            if (row === 2 && col === 1) {
              msg = 'Just fill in one more...';
            }
            if (row === 0 && col === 1) {
              msg = '<b>Fill it in</b><br>Type any number here.';
            }

            return {
              position: 'e',
              content: msg,
              sel: tableView.columnViews[1][row+1].$()
            };
          }
        }
      }

      //shouldn't ever get here.
      return;
    };
  });
});

define('tours/function_table',['require','pjs','jquery','underscore','./base_tour'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var BaseTour = require('./base_tour');

  return P(BaseTour, function(tour, _super){

    tour.hasChangedDisplayType = false;

    tour.update = function(){
      // Tour:
      // 2. Convert an expression into a table
      var expressions = this.expressionsView.getItemsByIndexRange(0, Infinity);
      var tables = _.filter(expressions, function(e){return e.hasOwnProperty('columns')});

      //need expressions open for the entirety of this tour
      if (!this.expressionsVisible()) {
        return this.requireExpressionsVisible();
      }

      if (this.resourcesOpen()) {
        return this.requireResourcesNotOpen();
      }

      //See what columns have been made so far
      var dataColumns = [];
      var expressionColumns = [];
      for(var i = 0; i < tables.length; i++){
        var table = tables[i];
        for(var j = 1; j < table.columns.length - 1; j++){ //Skip first and last column
          //expression columns are called disabled in table.js
          //because you can't type in them
          var tableView = this.expressionsView.getItemView(table.id);
          var columnView = tableView.columnViews[j];
          if(table.columns[j].disabled)
            expressionColumns.push({ model: table.columns[j], view: columnView, tableView: tableView });
          else
            dataColumns.push({ model: table.columns[j], view: columnView, tableView: tableView });
        }
      }
  
      //////////////// Convert an expression into a table ////////////////
      if (expressionColumns.length === 0) {
        var graphable = _.find(expressions, function(expr) { return expr.isGraphable; });
        if (!graphable || graphable.latex === 'x') {
          var expr = _.find(expressions, function(expr) {
            return !expr.hasOwnProperty('columns') && expr.hasOwnProperty('latex');
          });
          if (!expr) return {
            position: 'e',
            content: 'Let\'s try a Function Table. First: click here to create a new blank expression.',
            sel: '.new-math-div'
          };
          return {
            position: 'e',
            content: ['Try typing <var>x</var><sup>2</sup>.<br>',
                      '<i><b>hint:</b> type x^2',
                      ' or click the a<sup>2</sup> button below</i>'].join(''),
            sel: this.expressionsView.getItemView(expr.id).$()
          };
        }

        if ($('.EDIT-LIST-MODE').length === 0) return {
          position: 's',
          content: '<b>Convert this to a table</b><br>' +
                   'Click the \"Edit List\" button.',
          sel: '.edit-list-btn'
        };

        return {
          position: 'e',
          content: 'Click here to convert the expression to a table.',
          sel: '.action-createtable'
        };
      }

      return {
        final: true,
        position: 'e',
        content: '<b>You\'re a table wizard!</b><br>This message will now self destruct...',
        sel: expressionColumns[0].tableView.$()
      };
    };
  });
});

define('tours/mathart',['require','underscore','jquery','pjs','./base_tour'],function(require){
  var _ = require('underscore');
  var $ = require('jquery');
  var P = require('pjs');
  var BaseTour = require('./base_tour');

  return {

    mathart_intro: P(BaseTour, function(tour){

      //this will represent the string that the student typed
      tour.graphedLine = null;
      tour.graphedParabola = null;

      tour.graphedLineIsRestricted = function () {
        if (!this.graphedLine) return false;
        if (!this.expressionsView.getItemById(this.graphedLine.id)) return false;

        var sketch = this.grapher().graphSketches[this.graphedLine.id];
        if (!sketch || !sketch.branches || !sketch.branches[0] || !sketch.branches[0].compiled) return false;
        var fn = sketch.branches[0].compiled.fn;

        return (isNaN(fn(-100)) && isNaN(fn(100)));
      };


      tour.graphedParabolaIsRestricted = function () {
        if (!this.graphedParabola) return false;
        if (!this.expressionsView.getItemById(this.graphedParabola.id)) return false;

        var sketch = this.grapher().graphSketches[this.graphedParabola.id];
        if (!sketch || !sketch.branches || !sketch.branches[0] || !sketch.branches[0].compiled) return false;
        var fn = sketch.branches[0].compiled.fn;

        return (isNaN(fn(100)));
      };

      tour.graphedParabolaIsShifted = function () {
        if (!this.graphedParabola) return false;
        if (!this.expressionsView.getItemById(this.graphedParabola.id)) return false;

        var sketch = this.grapher().graphSketches[this.graphedParabola.id];
        if (!sketch || !sketch.branches || !sketch.branches[0] || !sketch.branches[0].compiled) return false;
        var fn = sketch.branches[0].compiled.fn;

        return (fn(0) !== 0);
      };

      tour.getFirstExp = function () {
        var exps = this.expressionsView.getItemsByIndexRange(0, Infinity);
        return _.find(exps, function(exp) {
          return !exp.hasOwnProperty('columns') && exp.hasOwnProperty('latex');
        });
      };

      //Line Tour -- Phase 1!
      tour.restrictedLineTour = function () {
        //we're done -- go to the parabola tour
        if (this.graphedLineIsRestricted()) {
          //ask the user to click on the "blank expression" button. Once they do, it'll be blank
          if (
            !this.expressionsView.getSelected() ||
            this.expressionsView.getSelected().latex
          ) return {
              position: 'e',
              content: '<b>Brilliant!</b><br>Click here to create a new expression',
              sel: '.new-math-div'
          };

          this.phaseOn++;
          return this.update();
        }

        //if they mess up the graphedLine -- unset it, take them back a step
        if (this.graphedLine && !this.expressionsView.getItemById(this.graphedLine.id)) {
          this.graphedLine = null;
        }

        //record the last successful non-constant line
        var selectedExp = this.expressionsView.getSelected();
        if (selectedExp) {
          if (
            this.grapher().graphSketches[selectedExp.id] &&
            this.grapher().graphSketches[selectedExp.id].branches[0].conic === 'line' &&
            !isFinite(selectedExp.formula.simple_constant)
          ) {
            this.graphedLine = {id: selectedExp.id};
          }
        }

        if (this.graphedLine) return {
            position: 'e',
            content: [
                      '<b>Awesome!</b><br>',
                      'Restrict the domain of this line by making it<br> <code>',
                      'y=2x{1&lt;x&lt;2}</code><br>',
                      '<i>Hint: press the \'more\' button on the keypad to find the { } buttons</i>'].join(''),
            sel: this.expressionsView.getItemView(this.graphedLine.id).$()
        };

        var $sel = this.expressionsView.getSelectedView();
        if (!$sel && this.getFirstExp()) {
          $sel = this.expressionsView.getItemView(this.getFirstExp().id);
        }

        if ($sel) return {
          position: 'e',
          content: ['<b>Let\'s get started!</b><br>',
                    'Try graphing a straight line, like <code>y=2x</code>'].join(''),
          sel: $sel.$()
        };

        return {
          position: 'e',
          content: 'Click here to make a new blank expression',
          sel: '.new-math-div'
        };
      };

      //Tour part 2: restricting a parabola
      tour.restrictedParabolaTour = function () {

        if (this.graphedParabolaIsRestricted()) {
          //Next activity! change color.
          this.phaseOn++;
          return this.update();
        }

        var $sel = this.expressionsView.getSelectedView();


        //record the last successful non-constant line
        if ($sel) {
          var selectedExp = $sel.model;
          if (
            this.grapher().graphSketches[selectedExp.id] &&
            this.grapher().graphSketches[selectedExp.id].branches[0].conic === 'parabola'
          ) {
            this.graphedParabola = {id: selectedExp.id};
          }
        }


        //if they mess up the graphedParabola -- unset it, take them back a step
        if (this.graphedParabola && !this.expressionsView.getItemById(this.graphedParabola.id)) {
          this.graphedParabola = null;
        }

        if (this.graphedParabola) {
          var item = this.expressionsView.getItemById(this.graphedParabola.id);
          //special warning if they've just typed "x^2" without the y=
          if (!item.isGraphable) return {doNotUpdate: true};

          if (item.dependent !== 'y') return {
            position: 'e',
            content: [
                      '<b>Don\'t forget the "y="!</b><br>',
                      'Try typing all of <code>y=x<sup>2</sup></code>'
                     ].join(''),
            sel: this.expressionsView.getItemView(this.graphedParabola.id).$()
          };

          if (this.graphedParabolaIsShifted()) return {
            position: 'e',
            content: [
                      '<b>Nice!</b><br>Now let\'s restrict the range. Change this to:<br>',
                      '<code>y=x<sup>2</sup>-2{y&lt;4}</code>'
                     ].join(''),
            sel: this.expressionsView.getItemView(this.graphedParabola.id).$()
          };

          return {
            position: 'e',
            content: [
                      '<b>Move the parabola.</b><br>',
                      'Change this equation to <code>y=x<sup>2</sup>-2</code>'
                      ].join(''),
            sel: this.expressionsView.getItemView(this.graphedParabola.id).$()
          };
        }

        if ($sel) return {
          position: 'e',
          content: [
                      'Now graph: <code>y=x<sup>2</sup></code><br>',
                      '<i>Hint: you can type y=x^2,',
                      ' or use the a<sup>2</sup> button on the keypad below</i>'
                   ].join(''),
          sel: $sel.$()
        };

        return {
          position: 'e',
          content: 'Click here to make a new blank expression',
          sel: '.new-math-div'
        };
      };

      tour.colorWasChanged = false;

      tour.changeColorTour = function () {
        //bind observers
        var self = this;
        _.each(this.expressionsView.getItemsByIndexRange(0, Infinity), function(exp) {
          exp.unobserve('color.tour');
          exp.observe('color.tour', function() {
            self.colorWasChanged = true;
          });
        });

        if (this.colorWasChanged) {
          if ($('.options-menu').length) return {
            position: 'e',
            content: '... and click anywhere to close the color menu.',
            sel: '#exppanel-outer'
          };

          return {
            final: true,
            position: 'e',
            endingMsg: 'Great job! Now to complete your mission: make a face. Good luck!',
            sel: '#exppanel-outer'
          };
        }

        if ($('.options-menu').length) return {
          position: 'e',
          content: '<b>Last step...</b><br>Change the color!',
          sel: '.options-menu'
        };

        var exp = this.expressionsView.getSelected() || this.getFirstExp();
        var $exp = this.expressionsView.getItemView(exp.id);
        return {
          position: 'e',
          content: '<b>Great!</b><br>Click and hold to open the secret drawing menu.',
          sel: $exp.iconView.$icon
        };
      };

      //manage state of which of the 3 steps we're on
      tour.phaseOn = 0;
      tour.phases = [tour.restrictedLineTour, tour.restrictedParabolaTour, tour.changeColorTour];
      tour.update = function(){
        return this.phases[this.phaseOn].call(this);
      };
    })
  };
});

define('tours/tour_manager',['require','underscore','jquery','pjs','lib/urlparser','loadcss!css/tour','lib/trip','tours/sliders','tours/scatter_plot','tours/function_table','tours/mathart'],function(require) {
  var _ = require('underscore');
  var $ = require('jquery');
  var P = require('pjs');
  var UrlParser = require('lib/urlparser');
  require('loadcss!css/tour');
  var Trip = require('lib/trip');

  //Specific tours
  var SlidersTour = require('tours/sliders');
  var TableTour = require('tours/scatter_plot');
  var FunctionTableTour = require('tours/function_table');
  var MathArtTours = require('tours/mathart');

  var Tour = P(function (proto, _super) {

    proto.init = function () {
      this.tripManager = new Trip({onTripStop: this.stopTour.bind(this)});
      this.currentStep = undefined;
      this.currentTour = undefined;
      this.TOURS = {
        sliders: SlidersTour,         //Animate a graph
        tables: TableTour,            //Make a scatterplot
        functiontable: FunctionTableTour
      };
      _.extend(this.TOURS, MathArtTours);
    };

    proto.startFromUrl = function (Calc) {

      //don't start until the expressions are loaded
      if ($('.expressionitem').length < 2) {
        setTimeout(this.startFromUrl.bind(this, Calc), 100);
        return;
      }

      var tourName = UrlParser.getParameter('tour');
      if (tourName && this.TOURS[tourName]){
        var tour = this.TOURS[tourName](Calc);
        this.startTour(tour);
      }
    };

    proto._tripLoop = function () {
      clearTimeout(this.__tripLoopTimeout);
      
      if (!this.running) return;
      //try {
        var tourStep = this.currentTour.update();
        //doNotUpdate set when you're pointing at something
        //that the user's moving, i.e. a slider handle
        if (tourStep && !tourStep.doNotUpdate) {
          this.currentStep = tourStep; // Cache current step for testing purposes.

          if (tourStep.final) {
            this.finishTour(tourStep, 5);
            return;
          }
          this.tripManager.showTripBlock(tourStep);
        }
      //} catch (ex) {
      //  this.tripManager.stop();
      //}
      this.__tripLoopTimeout = setTimeout(this._tripLoop.bind(this), 300);
    };

    // Used by testing code to short-circuit the loop timeout.
    proto.updateNow = proto._tripLoop;

    proto.startTour = function (tour) {
      if(this.running) return;
      this.currentTour = tour;
      this.running = true;
      this._tripLoop();
      this.tripManager.fadeInTripBlock();
    };

    proto.finishTour = function (tourStep, timer) {
      this.running = false;
      var self = this;

      if (timer < 0) {
        self.tripManager.stop();
        return;
      }

      if (tourStep.endingMsg) {
        tourStep.content = ['<b>' + tourStep.endingMsg + '</b><br>',
                           'This message will self-destruct in ' + timer + '...'].join('');
      }
      self.tripManager.showTripBlock(tourStep);

      setTimeout(function() {
        self.finishTour(tourStep, timer - 1);
      }, 1000);
    };

    proto.stopTour = function () {
      this.running = false;
      this.currentStep = undefined;
      this.currentTour = undefined;
      clearTimeout(this.finishTimeout);
    };
  });

  return Tour;
});

/*
 * The ipad has some quirky scrolling behavior. This module fixes them.
 * NOTE: this module is only for vertical scrolling. Horizontal page scroll
 *       can be turned off by an html setting. If we want, we can enable
 *       this module to monitor horizontal scrolling as well.
 *
 * On the ipad you can scroll an entire page by:
 *     a) Sliding your finger on a non scrollable object.
 *     b) Sliding your finger on a scrollable object in a direction
 *        that the scrollable object is already maxed out.
 *
 * You can preventDefault() the 'touchMove' event and that will prevent
 *  the ipad from scrolling the entire page. The only problem is that this
 *  also prevents any scrollable area from scrolling.
 *
 * The solution is to monitor the 'touchStart' event to predict what will
 *  happen when the user moves their finger. It predicts both movements up
 *  and down. If it predicts that the entire page will be scrolled, it
 *  makes that movement as invalid. If it predicts that a scrollable area
 *  will be scrolled, it makes the movement as valid.
 *
 * On 'touchMove', this module looks up the prediction for the direction the
 *  user moved. If the movement was valid, it lets the movement continue on
 *  and scroll the scrollable area. If the movement was invalid, it does a
 *  preventDefault() on the 'touchMove' event to prevent the entire page from
 *  scrolling.
 *
 * Also important to know is that once you grab a scrollable area and start
 *  scrolling, you're safe. The page won't scroll even if you max the
 *  scrollable area out and keep dragging in that direction.
 *
 * The prediction routine runs up the ancestors of the evt.target and finds
 * the first that:
 *
 *  1) has overflow and overflow-y properties that allow scrolling
 *                 AND
 *    2) has scrollTop != 0 (can be scrolled downward)
 *                          AND/OR
 *    3) has scrollTop that can be incremented (can be scrolled upward)
 */
 
/* global jQuery */
;(function ($) {
  /* jshint bitwise: false */

  //some constants
  var NONE = 0;
  var UP = 1;
  var DOWN = 2;

  //holds the state
  var validMoveDirections = NONE;
  var startTouches = null;

  //decides which directions an element can be scrolled
  $(document).bind('touchstart', function(evt) {

    var dom = $(evt.target);
    validMoveDirections = NONE;

    while (validMoveDirections === NONE && dom.length) {

      //mobile safari throws error if you try to do normal
      //.css() on the top most element
      if (dom[0].tagName === undefined) {
        break;
      }

      //some elements (like the slider) can disable scrolling on tapStart
      if (dom.closest('[disablescroll]').length) {
        validMoveDirections = NONE;
        return;
      }
      
      var overflow = dom.css('overflow');
      var overflow_y = dom.css('overflow-y');

      //check if overflow allows it to be scrolled
      if (overflow !== "hidden" && overflow !== "visible" &&
          overflow_y !== "hidden" && overflow_y !== "hidden" ) {

        //can be scrolled downward if it isn't scrolled to the very top
        var scrollTop = dom.scrollTop();
        if (scrollTop !== 0) {
          validMoveDirections = DOWN;
        }

        //can be scrolled upward if we try to scroll it upward and
        //it succeeds
        dom.scrollTop(scrollTop+1);
        if (dom.scrollTop() !== scrollTop) {
          
          //mark up as a valid scroll
          validMoveDirections = UP | validMoveDirections;
          
          //move it back to where it was
          dom.scrollTop(scrollTop);
        }
      }

      dom = dom.parent();
    }

    //if any scroll is valid, lets save the original touchStart event
    //so that we can compare it with the touchMove event later to decide
    //which direction the user scrolled.
    if (validMoveDirections !== NONE) {
      startTouches = [];

      //We must clone the original touchStart event instead of simply
      //saving a reference to it. For some reason, the original touchStart
      //event updates it's pageY, screenY, etc properties as you scroll.
      //That means that touchStart.screenY will always equal the
      //touchMove.screenY event when you compare them.
      var origTouches = evt.originalEvent.touches;
      for (var i=0; i<origTouches.length; i++) {
        var clonedTouch = {};
        for (var j in origTouches[i] ) {
          if (origTouches[i].hasOwnProperty(j)) {
            clonedTouch[j] = origTouches[i][j];
          }
        }
        startTouches.push( clonedTouch );
      }
    }
  });

  //decides if the the movement is in a valid direction.
  $(document).bind('touchmove', function(evt) {

    //makes sure this is the first touchmove after touchstart
    if (startTouches) {

      //get positions of the touch and move events
      var startTouch = startTouches[0];
      var moveTouch = evt.originalEvent.touches[0];

      //find the direction we moved our finger
      //var deltaX = moveTouch.screenX - startTouch.screenX;
      var deltaY = moveTouch.screenY - startTouch.screenY;

      //check if any of the movements weren't allowed
      //and if not, say that NO move is allowed. Will
      //get caught later at bottom of the function.
      if (deltaY > 0 && !(validMoveDirections & DOWN)) {
        validMoveDirections = NONE;
      } else if (deltaY < 0 && !(validMoveDirections & UP)) {
        validMoveDirections = NONE;
      }

      //first touchmove has been processed
      if (deltaY) {
        startTouches = null;
      }
    }
    
    //don't scroll the entire screen
    if (validMoveDirections === NONE) {
      evt.preventDefault();
    }
  });

  //resets the state
  $(document).bind('touchend', function() {
    validMoveDirections = NONE;
    startTouches = null;
  });

})(jQuery);


define("lib/ipad.scrollfix", function(){});

define('main/calc_embed',['require','jquery','underscore','pjs','config','main/evaluator','graphing/grapher','graphing/poicontroller','graphing/graphcontroller','main/graph_settings','graphing/viewport','main/timermodules','expressions/list','expressions/list_view_desktop','main/focus','undoredo','main/keypad_view_handwriting','main/keypad_view','main/state_controller','main/propagate_selection','lib/set_list_height','lib/browser','main/settings_view_tablet_window','main/settings_view_tablet_options','main/zoom_view','main/resize','lib/external_screenshot','tours/tour_manager','lib/ipad.scrollfix'],function (require) {
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var Config = require('config');
  var Evaluator = require('main/evaluator');
  var Grapher = require('graphing/grapher');
  var POIController = require('graphing/poicontroller');
  var GraphController = require('graphing/graphcontroller');
  var GraphSettings = require('main/graph_settings');
  var Viewport = require('graphing/viewport');
  var timerModules = require('main/timermodules');
  var ExpressionList = require('expressions/list');
  var ExpressionListView = require('expressions/list_view_desktop');
  var Focus = require('main/focus');
  var UndoRedo = require('undoredo');
  var KeypadWithHandwriting = require('main/keypad_view_handwriting');
  var KeypadWithoutHandwriting = require('main/keypad_view');
  var StateController = require('main/state_controller');
  var propagateSelection = require('main/propagate_selection');
  var setListHeight = require('lib/set_list_height');
  var Browser = require('lib/browser');
  var WindowView = require('main/settings_view_tablet_window');
  var OptionsView = require('main/settings_view_tablet_options');
  var ZoomView = require('main/zoom_view');
  var Resize = require('main/resize');
  var Screenshot = require('lib/external_screenshot');
  var TourManager = require('tours/tour_manager');

  require('lib/ipad.scrollfix');

  var Calc = P(function (proto) {
    proto.init = function (elt) {
      var expressionsModel = ExpressionList();
      var expressionsView = ExpressionListView(expressionsModel);
      var evaluator = Evaluator(Config.get('workerURL'));
      var graphSettings = GraphSettings();
      var keypadView;

      var containerClasses = ['embed-container'];
      if (!Config.get('menus')) containerClasses.push('no-menus');
      if (!Config.get('zoomButtons')) containerClasses.push('no-zoom');
      var $embedContainer = $('<div class="' + containerClasses.join(' ') + '">');
      var $graphpaper = $('<div class="grapher">');



      $graphpaper.appendTo($embedContainer);
      if (Config.get('keypad')) {
        keypadView = Config.get('handwriting') ?
          KeypadWithHandwriting(expressionsView) :
          KeypadWithoutHandwriting(expressionsView)
        ;
        setListHeight.init(expressionsView, keypadView);
        keypadView.appendTo($embedContainer);
      } else {
        // When you have the keypad, you need the .new-expression area because
        // expression list padding is tied to it. For now, just tie keypad
        // and .new-expression options together.
        $('.new-expression').hide();
      }
      if (Config.get('nographpaper')) {
        $embedContainer.addClass('no-graphpaper');
      }
      $embedContainer.appendTo(elt);
      var grapher = new Grapher($graphpaper, graphSettings);
      // Warning, order matters here because both of these bind touch event
      // handlers, and we need tracing (poiController) to get priority over
      // dragging (graphController).
      var poiController = new POIController(grapher);
      var graphController = GraphController(grapher);

      var optionsView = OptionsView(graphController);
      var windowView = WindowView(graphController);
      var $settingsTrack = $('<div id="settings-track">'); // TODO id here is bad
      optionsView.appendTo($settingsTrack);
      windowView.appendTo($settingsTrack);
      $settingsTrack.appendTo($embedContainer);

      graphSettings.registerCallbacks(graphController, expressionsView);
      
      graphSettings.observe('degreeMode', function(){
        evaluator.setDegreeMode(graphSettings.degreeMode);
      });

      var zoomView = ZoomView(graphController);
      zoomView.appendTo($embedContainer);

      var stateController = StateController(
        graphController,
        expressionsModel,
        graphSettings,
        expressionsView
      );

      this.Screenshot = Screenshot($embedContainer, expressionsView, grapher, evaluator, stateController);

      // redrawSlowly isn't as cool in the API.
      grapher.redrawSlowly = grapher.redrawAllLayers;

      graphController.triggerViewportStable = function () {
        var projection = grapher.createProjection();
        evaluator.setViewState({
          viewport: projection.viewport.toObject(),
          screen: projection.screen
        });

        // if we've set it back to square, keep it square on changes
        if (grapher.viewport.isSquare(grapher.screen)) {
          grapher.settings.setProperty('squareAxes', true);
        }

        windowView.setViewport(graphController.getViewport());
      };

      evaluator.triggerStatusChange = function (changes) {
        expressionsView.onChange(changes);
      };
      evaluator.triggerGraphComputed = function (id, graphData) {
        grapher.updateSketch(id, graphData);
      };

      evaluator.triggerRemove = function (id) { grapher.hide(id); };

      evaluator.triggerUpdateIntersections = function (id, intersections) {
        grapher.updateIntersections(id, intersections);
        grapher.redrawPOILayer();
      };

      evaluator.triggerRender = function () {
        poiController.handleTraceUpdate(); //Needed for updating trace with animation
        grapher.redrawContentLayers();
      };
      evaluator.triggerRenderSlowly = function () { grapher.redrawSlowly(); };

      expressionsModel.triggerAddExp = function (obj) {
        if (!obj) return;
        // if we've completely erased the contents of this expression, then
        // we need to act like it's a new expression. We remove the old sketch
        // so that we don't remember POI information.
        if (obj.latex === '' && this.type !== 'table') {
          grapher.removeGraphSketch(obj.id);
        }

        evaluator.addStatement(obj);
      };

      expressionsModel.triggerRemoveExp = function (id) {
        evaluator.removeStatement(id);
      };
      expressionsModel.triggerRemoveExps = function (ids) {
        evaluator.removeStatements(ids);
      };

      expressionsModel.observe('drawOrder', function(){
        grapher.setSketchOrder(expressionsModel.getProperty('drawOrder'));
      });

      expressionsModel.batchEvaluation = evaluator.batch.bind(evaluator);

      expressionsView.triggerClearGraph = function () {
        stateController.setBlank();
      };

      propagateSelection(expressionsView, grapher, evaluator);

      Resize.register(function () {
        grapher.screen.width = grapher.$.width();
        grapher.screen.height = grapher.$.height();
        graphController.enforceSquareAxes();
        grapher.redrawAllLayers();
        if (keypadView) keypadView.resize();
      });

      poiController.triggerStartTracingBranch = function(id) {
        expressionsView.setSelected(expressionsModel.getItemById(id));
      };
      
      poiController.triggerEmptyTouchStart = function () {
        expressionsView.setSelected(null);
      };

      poiController.triggerStartMovingPoint = function (id) {
        expressionsView.onStartMovingPoint(id);
      };

      poiController.triggerMovePoint = function (id, values) {
        // Batch updates so that sliders corresponding to both coordinates are
        // updated togther
        evaluator.batch(function () { expressionsView.onMovePoint(id, values); });
      };

      poiController.triggerStopMovingPoint = function (id) {
        expressionsView.onStopMovingPoint(id);
      };
      
      poiController.triggerPointSelected = function (id) {
        expressionsView.setSelected(expressionsView.getItemView(id));
      };

      Focus.takeFocus = function () {
        expressionsView.setSelected(null);
      };

      expressionsView.appendTo($embedContainer);

      //Pulling these to the top level for increased visibility.
      //Would ideally like to get rid of these
      timerModules.load('expressions.renderviewport', expressionsView, grapher);

      Resize.init();

      //Setup undo-redo listeners
      $(document).bind('keydown', UndoRedo.handleKeydown.bind(UndoRedo));

      this.expressions = expressionsView;
      this.grapher = grapher;
      this.graphController = graphController;
      this.evaluator = evaluator;
      this.setState = stateController.setState.bind(stateController);
      this.setBlank = stateController.setBlank.bind(stateController);
      this.getState = stateController.getState.bind(stateController);
      this.tourManager = TourManager();
      this.setViewport = function (bounds) {
        grapher.viewport = new Viewport(
          bounds[0], bounds[1], bounds[2], bounds[3]
        );
        graphController.triggerViewportStable();
      };
      this.resize = function () {
        Resize.trigger();
      };

      this.interceptTouch = function () {
        var elts = $graphpaper;
        elts = elts.add(expressionsView.$('#expression-top-bar'));
        if (keypadView) elts = elts.add(keypadView.$());
        // Don't allow legacy scrolling or legacy clicks on the graphpaper or keypad
        elts.on('touchstart', function (evt) {
          evt.preventDefault();
        });
        // Since we're preventing default, we need to take responsibility for closing
        // the system keypad, and fixing scroll.
        elts.on('touchend', Resize.defocusMobile);
      };

      this.setOptions = function (options) {
        var needsResize = false;
        if (options.hasOwnProperty('solutions')) {
          $embedContainer.toggleClass('no-solutions', !options.solutions);
        }
        if (options.hasOwnProperty('menus')) {
          $embedContainer.toggleClass('no-menus', !options.menus);
          needsResize = true;
        }
        if (options.hasOwnProperty('graphpaper')) {
          $embedContainer.toggleClass('no-graphpaper', !options.graphpaper);
          needsResize = true;
        }
        if (options.hasOwnProperty('zoomButtons')) {
          $embedContainer.toggleClass('no-zoom', !options.zoomButtons);
        }
        if (options.hasOwnProperty('keypad')) {
          console.warn(
            'Bad option {keypad: ' +
            options.keypad +
            '}. The keypad can only be added or removed at load time, not at runtime.'
          );
        }
        if (needsResize) Resize.trigger();
      };

      stateController.setBlank();
    };
  });

  return Calc;
});


if (!window.Desmos) window.Desmos = {};

define('api/abstract_api',['require','pjs','expressions/colors'],function (require) {
  var P = require('pjs');
  var Colors = require('expressions/colors');

  function _parseExpression (expression) {
    var obj;
    
    if (typeof expression === 'string') {
      obj = { latex: expression };
    } else if (expression.headings !== undefined) {
      obj = expression;
      obj.headings = obj.headings.map(function (heading) {
        return (typeof heading === 'string') ? { latex: heading } : heading;
      });
    } else {
      obj = expression;
    }
    
    return obj;
  }

  var AbstractAPI = P(function (proto) {
    // Subclasses pass in the implementation of Calc they want to use.
    proto.init = function (Calc, elt) {
      this._calc = Calc(elt);
      this._calc.interceptTouch();
    };

    proto.setExpression = function (expression) {
      var expressions = this._calc.expressions.model;
      var validatedState = {};
      var id = validatedState.id = expression.id.toString();
      if (!id) return;
      if (expression.hasOwnProperty('latex')) {
        validatedState.latex = expression.latex.toString();
      }
      if (expression.hasOwnProperty('color')) {
        validatedState.color = expression.color.toString();
      }
      if (expression.hasOwnProperty('style')) {
        validatedState.style = expression.style.toString();
      }
      if (expression.hasOwnProperty('hidden')) {
        validatedState.userRequestedGraphing = (expression.hidden) ?
          'never' : 'always'
        ;
      }

      if (expressions.getItemById(id)) {
        //Update
        expressions.updateItemById(id, validatedState);
      } else {
        //Set
        var obj = expressions.fromState(_parseExpression(validatedState));
        expressions.addItem(obj);
      }
    };

    proto.setExpressions = function (expressions) {
      expressions.forEach(this.setExpression.bind(this));
    };

    proto.setViewport = function (bounds) {
      if (
        bounds.length == 4 &&
        bounds[1] > bounds[0] &&
        bounds[3] > bounds[2]
      ) {
        this._calc.setViewport(bounds);
      } else {
        console.warn('Invalid viewport.  Expected [xmin, xmax, ymin, ymax].  Got ' + bounds);
      }
    };

    proto.resize = function () {
      this._calc.resize();
    };
  });

  // Spelling these out to avoid giving access to Colors.all. This is a
  // mutable array, and changing it would change the colors we cycle through.
  // That might be desirable, but we would want a better API for doing it.
  window.Desmos.Colors = {
    RED: Colors.RED,
    BLUE: Colors.BLUE,
    GREEN: Colors.GREEN,
    ORANGE: Colors.ORANGE,
    PURPLE: Colors.PURPLE,
    BLACK: Colors.BLACK,
    next: Colors.next
  };

  return AbstractAPI;
});
define('api/forwardmessages',['require'],function (require) {
  var init = function (Calc) {
    function reply(event, data) {
      event.source.postMessage(JSON.stringify(data), event.origin);
    }

    var receiveMessage = function (event) {
      var eventData = JSON.parse(event.data);
      if (listeners.hasOwnProperty(eventData.type)) {
        listeners[eventData.type](event, eventData.payload);
      } else {
        console.warn(
          'Unsupported API call [' + eventData.type + '].' +
          'Only getState, setState, and setBlank are supported in the iframe API.'
        );
      }
    };

    var listeners = {};

    listeners.setState = function (event, state) { Calc.setState(JSON.parse(state)); };
    listeners.setBlank = function (event) { Calc.setBlank(); };
    listeners.setOptions = function (event, options) { Calc.setOptions(options); };

    listeners.getState = function (event) {
      var state = Calc.getState();
      reply(event, {type: 'getState', payload: JSON.stringify(state)});
    };

    window.addEventListener("message", receiveMessage, false);

    // This allows us to get things moving earlier than onLoad. Need to post to
    // '*' because we don't know the parent's origin yet. In the worst case, the
    // parent doesn't get this message, and can still resolve after the iFrame's
    // onLoad.
    if (parent !== window) parent.postMessage(JSON.stringify({type: 'ready'}), '*');
  };

  return init;
});

define('api/calculator',['require','pjs','jquery','main/calc_embed','./abstract_api','config','./forwardmessages'],function (require) {
  var P = require('pjs');
  var $ = require('jquery');
  var Calc = require('main/calc_embed');
  var AbstractAPI = require('./abstract_api');
  var Config = require('config');
  var ForwardMessages = require('./forwardmessages');

  if (Config.get('cssURL')) {
    $('head').append('<link rel="stylesheet" href="' + Config.get('cssURL') + '" />');
  }

  var Calculator = P(AbstractAPI, function (proto, _super) {
    proto.init = function (elt) {
      _super.init.call(this, Calc, elt);
      ForwardMessages(this._calc);

      // Create a special element, and poll its css content property until
      // we can verify that our css has loaded. This lets us notify the
      // calculator to resize after the css has been loaded.
      var sentinal = $('<div class="dcg-sentinal" style="display: none">');
      $(elt).append(sentinal);

      var self = this;
      var sentinalTimeout;
      function checkSentinal () {
        clearTimeout(sentinalTimeout);
        if (sentinal.css('content') === '"loaded"') {
          self.resize();
        } else {
          setTimeout(checkSentinal, 200);
        }
      }
      checkSentinal();
    };

    proto.setState = function () { return this._calc.setState.apply(this._calc, arguments); };
    proto.getState = function () { return this._calc.getState.apply(this._calc, arguments); };
    proto.setBlank = function () { return this._calc.setBlank.apply(this._calc, arguments); };
    proto.setOptions = function () { return this._calc.setOptions.apply(this._calc, arguments)};
  });

  window.Desmos.Calculator = Calculator;

  return Calculator;
});
//Used for /api/v0.2/calculator.js

var Desmos = window.Desmos || {};
Desmos.require = require;
Desmos.requirejs = requirejs;

requirejs(['api/calculator', 'jquery', 'underscore'], function (calculator, $, _) {
  Desmos.$ = $;
  Desmos._ = _;
  $.noConflict(true);
  _.noConflict();
}, undefined, true);
// passing "true" as the 4th argument forces the previous code to run synchronously
// in almond, so that other pages don't have time to stick an _ or $ on the page
// in the interim. This is an undocumented feature of almond. See line 357 in
// almond 0.2.5.
;
define("toplevel/calculator_embed", function(){});
}());